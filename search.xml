<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spring Boot中使用RabbitMQ</title>
      <link href="/2018/11/26/Spring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8RabbitMQ/"/>
      <url>/2018/11/26/Spring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8RabbitMQ/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h2><p>RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在RabbitMQ官网的<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a>中，我们可以获取到针对各种不同操作系统的安装包和说明文档。这里，就用windows版来做说明。</p><ul><li>Erlang/OTP 21.1</li><li>RabbitMQ Server 3.7.9</li></ul><h3 id="安装Erland"><a href="#安装Erland" class="headerlink" title="安装Erland"></a>安装Erland</h3><ol><li>通过官方下载页面<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">http://www.erlang.org/downloads</a> 获取exe安装包，直接打开并完成安装。</li><li>添加系统变量 <code>ERLANG_HOME=D:\erl10.1</code></li><li>系统变量Path下加入<code>%ERLANG_HOME%\bin;</code></li></ol><h3 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h3><p>安装RabbitMQ，通过官方下载页面<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a>获取exe安装包。</p><p>需要注意：默认安装的RabbitMQ 监听端口是5672</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>我的目录是：<code>D:\RabbitMQ Server\rabbitmq_server-3.7.9\sbin</code></p><p>cmd进入该目录,在后面输入<code>rabbitmq-plugins enable rabbitmq_management</code>命令进行安装</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20181126195119.png" alt=""></p><p>访问<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20181126195657.png" alt=""></p><p>默认账号密码都是guest,登录即可<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20181126195722.png" alt=""></p><h2 id="RabbitMQ用户创建、密码、绑定角色、修改密码等"><a href="#RabbitMQ用户创建、密码、绑定角色、修改密码等" class="headerlink" title="RabbitMQ用户创建、密码、绑定角色、修改密码等"></a>RabbitMQ用户创建、密码、绑定角色、修改密码等</h2><p>cmd进入<code>D:\RabbitMQ Server\rabbitmq_server-3.7.9\sbin</code></p><p>查看已有用户及用户的角色：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl<span class="selector-class">.bat</span> list_users</span><br></pre></td></tr></table></figure></p><p>新增一个用户：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.<span class="keyword">bat </span><span class="keyword">add_user </span>username password</span><br></pre></td></tr></table></figure></p><p>给用户添加角色<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl<span class="selector-class">.bat</span> set_user_tags username administrator</span><br></pre></td></tr></table></figure></p><p>rabbitmq用户角色可分为五类：超级管理员, 监控者, 策略制定者, 普通管理者以及其他。<br>(1) 超级管理员(administrator)<br>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。<br>(2) 监控者(monitoring)<br>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)<br>(3) 策略制定者(policymaker)<br>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。<br>(4) 普通管理者(management)<br>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。<br>(5) 其他的<br>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><p>用户也可以同时具有多个角色,设置方式:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat  <span class="keyword">set</span>_user_tags  username tag1 tag2 <span class="string">...</span></span><br></pre></td></tr></table></figure></p><p>更改密码:<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl change_password userName <span class="keyword">new</span><span class="type">Password</span></span><br></pre></td></tr></table></figure></p><p>删除用户：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl<span class="selector-class">.bat</span> delete_user username</span><br></pre></td></tr></table></figure></p><p>当然，不想敲命令的话可以进管理页面直接操作：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20181126200654.png" alt=""></p><h2 id="Spring-Boot整合"><a href="#Spring-Boot整合" class="headerlink" title="Spring Boot整合"></a>Spring Boot整合</h2><p>下面，我们通过在Spring Boot应用中整合RabbitMQ，并实现一个简单的发送、接收消息的例子来对RabbitMQ有一个直观的感受和理解。</p><p>在Spring Boot中整合RabbitMQ是一件非常容易的事，因为之前我们已经介绍过Starter POMs，其中的AMQP模块就可以很好的支持RabbitMQ，下面我们就来详细说说整合过程：</p><ul><li><p>在<code>pom.xml</code>中引入如下依赖内容，其中<code>spring-boot-starter-amqp</code>用于支持RabbitMQ。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>application.properties</code>中配置关于RabbitMQ的连接和用户信息，用户可以回到上面的安装内容，在管理页面中创建用户。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.host</span>=<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.port</span>=<span class="number">5672</span></span><br><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.username</span>=felix</span><br><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.password</span>=<span class="number">123456</span></span><br></pre></td></tr></table></figure></li><li><p>创建消息生产者<code>Sender</code>。通过注入<code>AmqpTemplate</code>接口的实例来实现消息的发送，<code>AmqpTemplate</code>接口定义了一套针对AMQP协议的基础操作。在Spring Boot中会根据配置来注入其具体实现。在该生产者，我们会产生一个字符串，并发送到名为<code>hello</code>的队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建消息消费者<code>Receiver</code>。通过@RabbitListener注解定义该类对<code>hello</code>队列的监听，并用<code>@RabbitHandler</code>注解来指定对消息的处理方法。所以，该消费者实现了对<code>hello</code>队列的消费，消费操作为输出消息的字符串内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建RabbitMQ的配置类<code>RabbitConfig</code>，用来配置队列、交换器、路由等高级信息。这里我们以入门为主，先以最小化的配置来定义，以完成一个基本的生产和消费过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">helloQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建应用主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建单元测试类，用来调用消息生产</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringApplicationConfiguration</span>(classes = HelloApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>完成程序编写之后，下面开始尝试运行。首先确保RabbitMQ Server已经开始，然后进行下面的操作：</p><ul><li>启动应用主类，从控制台中，我们看到如下内容，程序创建了一个访问<code>127.0.0.1:5672</code>中springcloud的连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">26</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">33.495</span>  INFO <span class="number">9728</span> --- [cTaskExecutor-<span class="number">1</span>] o.s.a.r.c.CachingConnectionFactory : </span><br><span class="line">Created <span class="keyword">new</span> connection: SimpleConnection@<span class="number">15</span>ed453c [delegate=amqp:<span class="comment">//felix@127.0.0.1:5672/, localPort= 5202]</span></span><br></pre></td></tr></table></figure><p>同时，我们通过RabbitMQ的控制面板，可以看到Connection和Channels中包含当前连接的条目<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20181126202249.png" alt=""></p><ul><li><p>运行单元测试类，我们可以看到控制台中输出下面的内容，消息被发送到了RabbitMQ Server的<code>hello队</code>列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sender : hello Mon Nov <span class="number">26</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">10</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure></li><li><p>切换到应用主类的控制台，我们可以看到类似如下输出，消费者对<code>hello</code>队列的监听程序执行了，并输出了接受到的消息信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Receiver  : hello Mon Nov <span class="number">26</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">10</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure></li></ul><p>通过上面的示例，我们在Spring Boot应用中引入spring-boot-starter-amqp模块，进行简单配置就完成了对RabbitMQ的消息生产和消费的开发内容。然而在实际应用中，我们还有很多内容没有演示，这里不做更多的讲解，读者可以自行查阅<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ的官方教程</a>，有更全面的了解。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法的时间与空间复杂度</title>
      <link href="/2018/11/23/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/11/23/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>那么我们应该如何去衡量不同算法之间的优劣呢？</p><p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li></ul><p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p><p>下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。</p><h2 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a>一、时间复杂度</h2><p>我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。</p><p>这种方式可以吗？当然可以，不过它也有很多弊端。<br>这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。</p><p>因此，另一种更为通用的方法就出来了：「 <strong>大O符号表示法</strong> 」，即 T(n) = O(f(n))</p><p>我们先来看个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?</p><p>在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong> 。</p><p>我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) =  (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) =  O(n)</p><p>为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。</p><p>所以上面的例子中，如果n无限大的时候，T(n) =  time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) =  O(n) 就可以了。</p><p>常见的时间复杂度量级有：</p><ul><li>常数阶O(1)</li><li>对数阶O(logN)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)</li><li>指数阶(2^n)</li></ul><p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</p><p>下面选取一些较为常用的来讲解一下（没有严格按照顺序）：</p><h3 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h3><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p><h3 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n"></a>线性阶O(n</h3><p>这个在最开始的代码示例中就讲解过了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。</p><h3 id="对数阶O-logN"><a href="#对数阶O-logN" class="headerlink" title="对数阶O(logN)"></a>对数阶O(logN)</h3><p>还是先来看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br>也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：<strong>O(logn)</strong></p><h3 id="线性对数阶O-nlogN"><a href="#线性对数阶O-nlogN" class="headerlink" title="线性对数阶O(nlogN)"></a>线性对数阶O(nlogN)</h3><p>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。</p><p>就拿上面的代码加一点修改来举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平方阶O-n²"><a href="#平方阶O-n²" class="headerlink" title="平方阶O(n²)"></a>平方阶O(n²)</h3><p>平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²)<br>如果将其中一层循环的n改成m，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=m; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那它的时间复杂度就变成了 O(m*n)</p><h3 id="立方阶O-n³-、K次方阶O-n-k"><a href="#立方阶O-n³-、K次方阶O-n-k" class="headerlink" title="立方阶O(n³)、K次方阶O(n^k)"></a>立方阶O(n³)<strong>、</strong>K次方阶O(n^k)</h3><p>参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。</p><p>除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。</p><h2 id="二、空间复杂度"><a href="#二、空间复杂度" class="headerlink" title="二、空间复杂度"></a>二、空间复杂度</h2><p>既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。</p><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：</p><h3 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O(1)"></a>空间复杂度 O(1)</h3><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)<br>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h3 id="空间复杂度-O-n"><a href="#空间复杂度-O-n" class="headerlink" title="空间复杂度 O(n)"></a>空间复杂度 O(n)</h3><p>我们先看一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><p>以上，就是对算法的时间复杂度与空间复杂度基础的分析。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 空间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>还在用Synchronized？Atomic你了解不？</title>
      <link href="/2018/11/23/%E8%BF%98%E5%9C%A8%E7%94%A8Synchronized%EF%BC%9FAtomic%E4%BD%A0%E4%BA%86%E8%A7%A3%E4%B8%8D%EF%BC%9F/"/>
      <url>/2018/11/23/%E8%BF%98%E5%9C%A8%E7%94%A8Synchronized%EF%BC%9FAtomic%E4%BD%A0%E4%BA%86%E8%A7%A3%E4%B8%8D%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>在阅读<a href="">《阿里巴巴 Java开发手册》</a>时，还有未解决的问题：</p><blockquote><p>如果是count++操作，使用如下类实现: AtomicInteger count = new AtomicInteger(); count.addAndGet(1);如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好(减少乐观锁的重试次数)。</p></blockquote><p>之前在学习的时候也看过AtomicInteger类很多次了，一直没有去做相关的笔记。现在遇到问题了，于是就过来写写笔记，并希望在<strong>学习的过程中解决掉问题</strong>。</p><h1 id="一、基础铺垫"><a href="#一、基础铺垫" class="headerlink" title="一、基础铺垫"></a>一、基础铺垫</h1><p>首先我们来个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        <span class="comment">// 100个线程对共享变量进行加1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; count.increase());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待上述的线程执行完</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">        service.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(count.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">private</span> Integer count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你们猜猜得出的结果是多少？是100吗？</p><p>多运行几次可以发现：<strong>结果是不确定的</strong>，可能是95，也可能是98，也可能是100</p><p>根据结果我们得知：上面的代码是<strong>线程不安全</strong>的！如果线程安全的代码，多次执行的结果是一致的！</p><p>我们可以发现问题所在：<code>count++</code>并<strong>不是原子</strong>操作。因为<code>count++</code>需要经过<code>读取-修改-写入</code>三个步骤。举个例子：</p><ul><li>如果某一个时刻：线程A读到count的值是10，线程B读到count的值也是10</li><li>线程A对<code>count++</code>，此时count的值为11</li><li>线程B对<code>count++</code>，此时count的值也是11(因为线程B读到的count是10)</li><li>所以到这里应该知道为啥我们的结果是不确定了吧。</li></ul><p>要将上面的代码变成线程安全的(每次得出的结果是100)，那也很简单，毕竟我们是学过synchronized锁的人：</p><ul><li>在<code>increase()</code>加synchronized锁就好了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论执行多少次，得出的都是100</p><p>从上面的代码我们也可以发现，只做一个<code>++</code>这么简单的操作，都用到了synchronized锁，未免有点小题大做了。</p><ul><li>Synchronized锁是独占的，意味着如果有别的线程在执行，当前线程只能是等待！</li></ul><p>于是我们<strong>原子变量</strong>的类就登场了！</p><h2 id="1-2CAS再来看看"><a href="#1-2CAS再来看看" class="headerlink" title="1.2CAS再来看看"></a>1.2CAS再来看看</h2><p>在写文章之前，本以为对CAS有一定的了解了(因为之前已经看过相关概念，以为自己理解了)..但真正敲起键盘写的时候，还是发现没完全弄懂…所以再来看看CAS吧。</p><p>来源维基百科：</p><blockquote><p>比较并交换(compare and swap, CAS)，是<strong>原子</strong>操作的一种，可用于在多线程编程中实现<strong>不被打断的数据交换操作</strong>，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p></blockquote><p>CAS有3个操作数：</p><ul><li>内存值V</li><li>旧的预期值A</li><li>要修改的新值B</li></ul><p>当多个线程尝试使用CAS同时更新同一个变量时，<strong>只有其中一个线程能更新变量的值</strong>(A和内存值V相同时，将内存值V修改为B)，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，<strong>并可以再次尝试(或者什么都不做)</strong>。</p><p>我们画张图来理解一下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542939061247_3.png" alt="CAS理解" title="CAS理解"></p><p>我们可以发现CAS有两种情况：</p><ul><li>如果内存值V和我们的预期值A<strong>相等</strong>，则将内存值修改为B，操作成功！</li><li><p>如果内存值V和我们的预期值A<strong>不相等</strong>，一般也有两种情况：</p><ul><li>重试(自旋)</li><li>什么都不做</li></ul></li></ul><p>我们再继续往下看，如果内存值V和我们的预期值A<strong>不相等</strong>时，应该什么时候重试，什么时候什么都不做。</p><h3 id="1-2-1CAS失败重试-自旋"><a href="#1-2-1CAS失败重试-自旋" class="headerlink" title="1.2.1CAS失败重试(自旋)"></a>1.2.1CAS失败重试(自旋)</h3><p>比如说，我上面用了100个线程，对count值进行加1。我们都知道：如果在线程安全的情况下，这个count值最终的结果一定是为100的。那就意味着：<strong>每个线程都会对这个count值实质地进行加1</strong>。</p><p>我继续画张图来说明一下CAS是如何重试(循环再试)的：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542939062141_4.png" alt="CAS循环重试" title="CAS循环重试"></p><p>上面图只模拟出两个线程的情况，但足够说明问题了。</p><h3 id="1-2-2CAS失败什么都不做"><a href="#1-2-2CAS失败什么都不做" class="headerlink" title="1.2.2CAS失败什么都不做"></a>1.2.2CAS失败什么都不做</h3><p>上面是每个线程都要为count值加1，但我们也可以有这种情况：<strong>将count值设置为5</strong></p><p>我也来画个图说明一下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542939063924_5.png" alt="CAS失败什么都不做" title="CAS失败什么都不做"></p><p>理解CAS的核心就是：<strong>CAS是原子性的</strong>，虽然你可能看到比较后再修改(compare and swap)觉得会有两个操作，但终究是原子性的！</p><h1 id="二、原子变量类简单介绍"><a href="#二、原子变量类简单介绍" class="headerlink" title="二、原子变量类简单介绍"></a>二、原子变量类简单介绍</h1><p>原子变量类在<code>java.util.concurrent.atomic</code>包下，总体来看有这么多个：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542939065970_6.png" alt="原子变量类" title="原子变量类"></p><p>我们可以对其进行分类：</p><ul><li><p>基本类型：</p><ul><li>AtomicBoolean：布尔型</li><li>AtomicInteger：整型</li><li>AtomicLong：长整型</li></ul></li><li><p>数组：</p><ul><li>AtomicIntegerArray：数组里的整型</li><li>AtomicLongArray：数组里的长整型</li><li>AtomicReferenceArray：数组里的引用类型</li></ul></li><li><p>引用类型：</p><ul><li>AtomicReference：引用类型</li><li>AtomicStampedReference：带有版本号的引用类型</li><li>AtomicMarkableReference：带有标记位的引用类型</li></ul></li><li><p>对象的属性：</p><ul><li>AtomicIntegerFieldUpdater：对象的属性是整型</li><li>AtomicLongFieldUpdater：对象的属性是长整型</li><li>AtomicReferenceFieldUpdater：对象的属性是引用类型</li></ul></li><li><p>JDK8新增DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder</p><ul><li>是对AtomicLong等类的改进。比如LongAccumulator与LongAdder在高并发环境下比AtomicLong更高效。</li></ul></li></ul><p>Atomic包里的类基本都是使用<strong>Unsafe</strong>实现的包装类。</p><p>Unsafe里边有几个我们喜欢的方法(CAS)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>从原理上概述就是：Atomic包的类的实现绝大调用Unsafe的方法，而Unsafe底层实际上是调用C代码，C代码调用汇编，最后生成出<strong>一条</strong>CPU指令cmpxchg，完成操作。这也就为啥CAS是原子性的，因为它是一条CPU指令，不会被打断。</p><h2 id="2-1原子变量类使用"><a href="#2-1原子变量类使用" class="headerlink" title="2.1原子变量类使用"></a>2.1原子变量类使用</h2><p>既然我们上面也说到了，使用Synchronized锁有点小题大作了，我们用原子变量类来改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量(使用AtomicInteger来替代Synchronized锁)</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main方法还是如上</span></span><br></pre></td></tr></table></figure><p>修改完，无论执行多少次，我们的结果永远是100！</p><p>其实Atomic包下原子类的使用方式都不会差太多，了解原子类各种类型，看看API，基本就会用了(网上也写得比较详细，所以我这里果断偷懒了)…</p><h2 id="2-2ABA问题"><a href="#2-2ABA问题" class="headerlink" title="2.2ABA问题"></a>2.2ABA问题</h2><p>使用CAS有个缺点就是ABA的问题，什么是ABA问题呢？首先我用文字描述一下：</p><ul><li>现在我有一个变量<code>count=10</code>，现在有三个线程，分别为A、B、C</li><li>线程A和线程C同时读到count变量，所以线程A和线程C的内存值和预期值都为10</li><li>此时线程A使用CAS将count值修改成100</li><li>修改完后，就在这时，线程B进来了，读取得到count的值为100(内存值和预期值都是100)，将count值修改成10</li><li>线程C拿到执行权，发现内存值是10，预期值也是10，将count值修改成11</li></ul><p>上面的操作都可以正常执行完的，这样会发生什么问题呢？？线程C无法得知线程A和线程B修改过的count值，这样是有<strong>风险</strong>的。</p><p>下面我再画个图来说明一下ABA的问题(以链表为例)：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542939066892_7.png" alt="CAS ABA的问题讲解" title="CAS ABA的问题讲解"></p><h2 id="2-3解决ABA问题"><a href="#2-3解决ABA问题" class="headerlink" title="2.3解决ABA问题"></a>2.3解决ABA问题</h2><p>要解决ABA的问题，我们可以使用JDK给我们提供的AtomicStampedReference和AtomicMarkableReference类。</p><p>AtomicStampedReference：</p><blockquote><p>An {@code AtomicStampedReference} maintains an object referencealong with an integer “stamp”, that can be updated atomically.</p></blockquote><p>简单来说就是在给为这个对象提供了一个<strong>版本</strong>，并且这个版本如果被修改了，是自动更新的。</p><p>原理大概就是：维护了一个Pair对象，Pair对象存储我们的对象引用和一个stamp值。每次CAS比较的是两个Pair对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pair对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较的是Pari对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为多了一个版本号比较，所以就不会存在ABA的问题了。</p><h2 id="2-4LongAdder性能比AtomicLong要好"><a href="#2-4LongAdder性能比AtomicLong要好" class="headerlink" title="2.4LongAdder性能比AtomicLong要好"></a>2.4LongAdder性能比AtomicLong要好</h2><blockquote><p>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好(减少乐观锁的重试次数)。</p></blockquote><p>去查阅了一些博客和资料，大概的意思就是：</p><ul><li>使用AtomicLong时，在高并发下大量线程会同时去竞争更新<strong>同一个原子变量</strong>，但是由于同时只有一个线程的CAS会成功，所以其他线程会不断尝试自旋尝试CAS操作，这会浪费不少的CPU资源。</li><li><p>而LongAdder可以概括成这样：内部核心数据value<strong>分离</strong>成一个数组(Cell)，每个线程访问时,通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的<strong>求和累加</strong>。</p><ul><li>简单来说就是将一个值分散成多个值，在并发的时候就可以<strong>分散压力</strong>，性能有所提高。</li></ul></li></ul><p>参考资料：</p><ul><li>AtomicLong与LongAdder性能对比<a href="https://zhuanlan.zhihu.com/p/45489739" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45489739</a></li><li>LongAdder源码详解<a href="https://zhuanlan.zhihu.com/p/38288416" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38288416</a></li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>参考资料：</p><ul><li>Java并发编程札记-目录<a href="https://blog.csdn.net/panweiwei1994/article/details/78483167" target="_blank" rel="noopener">https://blog.csdn.net/panweiwei1994/article/details/78483167</a></li><li>《Java并发编程实战》</li><li>《Java并发编程的艺术》</li></ul><div class="note info"><p>作者：Java3y<br>出处：<a href="https://segmentfault.com/u/java_3y" target="_blank" rel="noopener">https://segmentfault.com/u/java_3y</a></p></div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CAS </tag>
            
            <tag> Atomic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CopyOnWriteArrayList你都不知道，怎么拿offer？</title>
      <link href="/2018/11/21/CopyOnWriteArrayList%E4%BD%A0%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8B%BFoffer%EF%BC%9F/"/>
      <url>/2018/11/21/CopyOnWriteArrayList%E4%BD%A0%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8B%BFoffer%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>大家对线程安全容器可能最熟悉的就是ConcurrentHashMap了，因为这个容器经常会在面试的时候考查。</p><p>比如说，一个常见的面试场景：</p><ul><li>面试官问：“HashMap是线程安全的吗？如果HashMap线程不安全的话，那有没有安全的Map容器”</li><li>3y：“线程安全的Map有两个，一个是Hashtable，一个是ConcurrentHashMap”</li><li>面试官继续问：“那Hashtable和ConcurrentHashMap有什么区别啊？”</li><li>3y：“balabalabalabalabalabala”</li><li>面试官：”ok,ok,ok,看你Java基础挺不错的呀“</li></ul><p>那如果有这样的面试呢？</p><ul><li>面试官问：“ArrayList是线程安全的吗？如果ArrayList线程不安全的话，那有没有安全的类似ArrayList的容器”</li><li>3y：“线程安全的ArrayList我们可以使用Vector，或者说我们可以使用Collections下的方法来包装一下”</li><li>面试官继续问：“嗯，我相信你也知道Vector是一个比较老的容器了，还有没有其他的呢？”</li><li>3y：“Emmmm,这个…“</li><li>面试官<strong>提示</strong>：“就比如JUC中有ConcurrentHashMap，那JUC中有类似”ArrayList”的线程安全容器类吗？“</li><li>3y：“Emmmm,这个…“</li><li>面试官：”ok,ok,ok,<strong>今天的面试时间也差不多了，你回去等通知吧</strong>。“</li></ul><p>今天主要讲解的是CopyOnWriteArrayList~</p><p>本文<strong>力求简单讲清每个知识点</strong>，希望大家看完能有所收获</p><h1 id="一、Vector和SynchronizedList"><a href="#一、Vector和SynchronizedList" class="headerlink" title="一、Vector和SynchronizedList"></a>一、Vector和SynchronizedList</h1><h2 id="1-1回顾线程安全的Vector和SynchronizedList"><a href="#1-1回顾线程安全的Vector和SynchronizedList" class="headerlink" title="1.1回顾线程安全的Vector和SynchronizedList"></a>1.1回顾线程安全的Vector和SynchronizedList</h2><p>我们知道ArrayList是用于替代Vector的，Vector是线程安全的容器。因为它几乎在每个方法声明处都加了<strong>synchronized关键字</strong>来使容器安全。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793882153_1.png" alt="" title="Vector实现"></p><p>Vector实现</p><p>如果使用<code>Collections.synchronizedList(new ArrayList())</code>来使ArrayList变成是线程安全的话，也是几乎都是每个方法都加上synchronized关键字的，只不过<strong>它不是加在方法的声明处，而是方法的内部</strong>。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793882444_2.png" alt="" title="Collections.synchronizedList()的实现"></p><p>Collections.synchronizedList()的实现</p><h2 id="1-2Vector和SynchronizedList可能会出现的问题"><a href="#1-2Vector和SynchronizedList可能会出现的问题" class="headerlink" title="1.2Vector和SynchronizedList可能会出现的问题"></a>1.2Vector和SynchronizedList可能会出现的问题</h2><p>在讲解CopyOnWrite容器之前，我们还是先来看一下线程安全容器的一些<strong>可能没有注意到</strong>的地方~</p><p>下面我们直接来看一下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到Vector最后一个元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除Vector最后一个元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">     list.remove(lastIndex);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以我们第一反应来分析一下上面两个方法：<strong>在多线程环境下，是否有问题</strong>？</p><ul><li>我们可以知道的是Vector的<code>size()和get()以及remove()</code>都被synchronized修饰的。</li></ul><p>答案：从调用者的角度是<strong>有问题</strong>的</p><p>我们可以写段代码测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeVectorHelpers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化Vector</span></span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector();</span><br><span class="line">        vector.add(<span class="string">"关注公众号"</span>);</span><br><span class="line">        vector.add(<span class="string">"Java3y"</span>);</span><br><span class="line">        vector.add(<span class="string">"买Linux可到我下面的链接，享受最低价"</span>);</span><br><span class="line">        vector.add(<span class="string">"给3y加鸡腿"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; getLast(vector)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; deleteLast(vector)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; getLast(vector)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; deleteLast(vector)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到Vector最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除Vector最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现的是，有可能会抛出异常的：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793882774_3.png" alt="" title="代码抛出异常"></p><p>代码抛出异常</p><p>原因也很简单，我们照着流程走一下就好了：</p><ul><li><p>线程A执行<code>getLast()</code>方法，线程B执行<code>deleteLast()</code>方法</p></li><li><p>线程A执行<code>int lastIndex = list.size() - 1;</code>得到lastIndex的值是3。<strong>同时</strong>，线程B执行<code>int lastIndex = list.size() - 1;</code>得到的lastIndex的值<strong>也</strong>是3</p></li><li><p>此时线程B先得到CPU执行权，执行<code>list.remove(lastIndex)</code>将下标为3的元素删除了</p></li><li><p>接着线程A得到CPU执行权，执行<code>list.get(lastIndex);</code>，发现已经没有下标为3的元素，抛出异常了.</p></li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793883158_4.png" alt="" title="交替执行导致异常发生"></p><p>交替执行导致异常发生</p><p>出现这个问题的原因也很简单：</p><ul><li><code>getLast()</code>和<code>deleteLast()</code>这两个方法并不是原子性的，即使他们<strong>内部的每一步操作是原子性</strong>的(被Synchronize修饰就可以实现原子性)，但是内部之间还是可以<strong>交替</strong>执行。</li></ul><ul><li>这里的意思就是：`size()和get()以及remove()`都是原子性的，但是如果并发执行`getLast()`和`deleteLast()`，方法里面的`size()和get()以及remove()`是可以交替执行的。</li></ul><p>要解决上面这种情况也很简单，因为我们都是对Vector进行操作的，<strong>只要操作Vector前把它锁住就没毛病了</strong>！</p><p>所以我们可以改成这样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到Vector最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除Vector最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps:如果有人去测试一下，发现会抛出异常java.lang.ArrayIndexOutOfBoundsException: -1，这是<strong>没有检查角标的异常</strong>，不是并发导致的问题。</p></blockquote><p>经过上面的例子我们可以看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化Vector</span></span><br><span class="line">     Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector();</span><br><span class="line">     vector.add(<span class="string">"关注公众号"</span>);</span><br><span class="line">     vector.add(<span class="string">"Java3y"</span>);</span><br><span class="line">     vector.add(<span class="string">"买Linux可到我下面的链接，享受最低价"</span>);</span><br><span class="line">     vector.add(<span class="string">"给3y加鸡腿"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历Vector</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 比如在这执行vector.clear();</span></span><br><span class="line">         <span class="comment">//new Thread(() -&gt; vector.clear()).start();</span></span><br><span class="line"></span><br><span class="line">         System.out.println(vector.get(i));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样地：如果在遍历Vector的时候，有别的线程修改了Vector的长度，那还是会<strong>有问题</strong>！</p><ul><li><p>线程A遍历Vector，执行<code>vector.size()</code>时，发现Vector的长度为5</p></li><li><p>此时<strong>很有可能存在</strong>线程B对Vector进行<code>clear()</code>操作</p></li><li><p>随后线程A执行<code>vector.get(i)</code>时，抛出异常</p></li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793883418_5.png" alt="" title="Vector遍历抛出异常"></p><p>Vector遍历抛出异常</p><p>在JDK5以后，Java推荐使用<code>for-each</code>(迭代器)来遍历我们的集合，好处就是<strong>简洁、数组索引的边界值只计算一次</strong>。</p><p>如果使用<code>for-each</code>(迭代器)来做上面的操作，会抛出ConcurrentModificationException异常</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793883700_6.png" alt="" title="迭代器遍历会抛出ConcurrentModificationException"></p><p>迭代器遍历会抛出ConcurrentModificationException</p><p>SynchronizedList在使用<strong>迭代器遍历</strong>的时候同样会有问题的，源码已经提醒我们要手动加锁了。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793883978_7.png" alt="" title="SynchronizedList在遍历的时候同样会有问题的"></p><p>SynchronizedList在遍历的时候同样会有问题的</p><p>如果想要完美解决上面所讲的问题，我们可以在<strong>遍历前加锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历Vector</span></span><br><span class="line"> <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">        vector.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有经验的同学就可以知道：<strong>哇，遍历一下容器都要我加上锁，这这这不是要慢死了吗</strong>.的确是挺慢的..</p><p>所以我们的CopyOnWriteArrayList就登场了！</p><h1 id="二、CopyOnWriteArrayList-Set-介绍"><a href="#二、CopyOnWriteArrayList-Set-介绍" class="headerlink" title="二、CopyOnWriteArrayList(Set)介绍"></a>二、CopyOnWriteArrayList(Set)介绍</h1><p>一般来说，我们会认为：CopyOnWriteArrayList是同步List的替代品，CopyOnWriteArraySet是同步Set的替代品。</p><p>无论是Hashtable–&gt;ConcurrentHashMap，还是说Vector–&gt;CopyOnWriteArrayList。JUC下支持并发的容器与老一代的线程安全类相比，总结起来就是加锁<strong>粒度</strong>的问题</p><ul><li>Hashtable、Vector加锁的粒度大(直接在方法声明处使用synchronized)</li><li>ConcurrentHashMap、CopyOnWriteArrayList加锁粒度小(用各种的方式来实现线程安全，比如我们知道的ConcurrentHashMap用了cas锁、volatile等方式来实现线程安全..)</li><li>JUC下的线程安全容器在遍历的时候<strong>不会</strong>抛出ConcurrentModificationException异常</li></ul><p>所以一般来说，我们都会<strong>使用JUC包下给我们提供的线程安全容器</strong>，而不是使用老一代的线程安全容器。</p><p>下面我们来看看CopyOnWriteArrayList是怎么实现的，为什么使用<strong>迭代器遍历</strong>的时候就<strong>不用额外加锁</strong>，也不会抛出ConcurrentModificationException异常。</p><h2 id="2-1CopyOnWriteArrayList实现原理"><a href="#2-1CopyOnWriteArrayList实现原理" class="headerlink" title="2.1CopyOnWriteArrayList实现原理"></a>2.1CopyOnWriteArrayList实现原理</h2><p>我们还是先来回顾一下COW：</p><blockquote><p>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取<strong>相同的指针指向相同的资源</strong>，直到某个调用者<strong>试图修改</strong>资源的内容时，系统才会<strong>真正复制一份专用副本</strong>（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。<strong>优点</strong>是如果调用者<strong>没有修改该资源，就不会有副本</strong>（private copy）被建立，因此多个调用者只是读取操作时可以<strong>共享同一份资源</strong>。</p></blockquote><p>参考自维基百科：<a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD</a></p><blockquote><p>之前写博客的时候，如果是要看源码，一般会翻译一下源码的注释并用图贴在文章上的。Emmm，发现阅读体验并不是很好，所以我这里就<strong>直接概括一下源码注释</strong>说了什么吧。另外，如果使用IDEA的话，可以下一个插件<strong>Translation</strong>(免费好用).</p></blockquote><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793884303_8.png" alt="" title="Translation插件"></p><p>Translation插件</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793884659_9.png" alt="" title="Translation插件"></p><p>Translation插件</p><hr><p>概括一下CopyOnWriteArrayList源码注释介绍了什么：</p><ul><li>CopyOnWriteArrayList是线程安全容器(相对于ArrayList)，底层通过<strong>复制数组</strong>的方式来实现。</li><li>CopyOnWriteArrayList在遍历的使用不会抛出ConcurrentModificationException异常，并且遍历的时候就不用额外加锁</li><li>元素可以为null</li></ul><h2 id="2-1-1看一下CopyOnWriteArrayList基本的结构"><a href="#2-1-1看一下CopyOnWriteArrayList基本的结构" class="headerlink" title="2.1.1看一下CopyOnWriteArrayList基本的结构"></a>2.1.1看一下CopyOnWriteArrayList基本的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 可重入锁对象 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CopyOnWriteArrayList底层由数组实现，volatile修饰 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化CopyOnWriteArrayList相当于初始化数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来挺简单的，CopyOnWriteArrayList底层就是数组，加锁就交由ReentrantLock来完成。</p><h2 id="2-1-2常见方法的实现"><a href="#2-1-2常见方法的实现" class="headerlink" title="2.1.2常见方法的实现"></a>2.1.2常见方法的实现</h2><p>根据上面的分析我们知道如果遍历<code>Vector/SynchronizedList</code>是需要自己手动加锁的。</p><p>CopyOnWriteArrayList使用迭代器遍历时不需要显示加锁，看看<code>add()、clear()、remove()</code>与<code>get()</code>方法的实现可能就有点眉目了。</p><p>首先我们可以看看<code>add()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 加锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 得到原数组的长度和元素</span></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 复制出一个新数组</span></span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 添加时，将新元素添加到新数组中</span></span><br><span class="line">           newElements[len] = e;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将volatile Object[] array 的指向替换成新数组</span></span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过代码我们可以知道：在添加的时候就上锁，并<strong>复制一个新数组，增加操作在新数组上完成，将array指向到新数组中</strong>，最后解锁。</p><p>再来看看<code>size()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接得到array数组的长度</span></span><br><span class="line">    <span class="keyword">return</span> getArray().length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>get()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那再来看看<code>set()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到原数组的旧值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断新值和旧值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制新数组，新值在新数组中完成</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将array引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; enssures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>remove()、clear()</code>跟<code>set()和add()</code>是类似的，这里我就不再贴出代码了。</p><p>总结：</p><ul><li><p><strong>在修改时，复制出一个新数组，修改的操作在新数组中完成，最后将新数组交由array变量指向</strong>。</p></li><li><p><strong>写加锁，读不加锁</strong></p></li></ul><h2 id="2-1-3剖析为什么遍历时不用调用者显式加锁"><a href="#2-1-3剖析为什么遍历时不用调用者显式加锁" class="headerlink" title="2.1.3剖析为什么遍历时不用调用者显式加锁"></a>2.1.3剖析为什么遍历时不用调用者显式加锁</h2><p>常用的方法实现我们已经基本了解了，但还是不知道为啥能够在容器遍历的时候对其进行修改而不抛出异常。所以，来看一下他的迭代器吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 返回的迭代器是COWIterator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 迭代器的成员属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 迭代器的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 迭代器的方法...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.... 可以发现的是，迭代器所有的操作都基于snapshot数组，而snapshot是传递进来的array数组</span></span><br></pre></td></tr></table></figure><p>到这里，我们应该就可以想明白了！CopyOnWriteArrayList在使用迭代器遍历的时候，操作的都是<strong>原数组</strong>！</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542793884946_10.png" alt="" title="一张图来解析COW容器"></p><p>一张图来解析COW容器</p><h2 id="2-1-4CopyOnWriteArrayList缺点"><a href="#2-1-4CopyOnWriteArrayList缺点" class="headerlink" title="2.1.4CopyOnWriteArrayList缺点"></a>2.1.4CopyOnWriteArrayList缺点</h2><p>看了上面的实现源码，我们应该也大概能分析出CopyOnWriteArrayList的缺点了。</p><ul><li><strong>内存占用</strong>：如果CopyOnWriteArrayList经常要增删改里面的数据，经常要执行<code>add()、set()、remove()</code>的话，那是比较耗费内存的。</li></ul><ul><li>因为我们知道每次`add()、set()、remove()`这些增删改操作都要<strong>复制一个数组</strong>出来。</li></ul><ul><li><strong>数据一致性</strong>：CopyOnWrite容器<strong>只能保证数据的最终一致性，不能保证数据的实时一致性</strong>。</li></ul><ul><li>从上面的例子也可以看出来，比如线程A在迭代CopyOnWriteArrayList容器的数据。线程B在线程A迭代的间隙中将CopyOnWriteArrayList部分的数据修改了(已经调用`setArray()`了)。但是线程A迭代出来的是原有的数据。</li></ul><h2 id="2-1-5CopyOnWriteSet"><a href="#2-1-5CopyOnWriteSet" class="headerlink" title="2.1.5CopyOnWriteSet"></a>2.1.5CopyOnWriteSet</h2><p>CopyOnWriteArraySet的原理就是CopyOnWriteArrayList。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note info"><p>作者：Java3y<br>出处：<a href="https://segmentfault.com/u/java_3y" target="_blank" rel="noopener">https://segmentfault.com/u/java_3y</a></p></div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CopyOnWriteArrayList </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解Java常用数据结构(一)</title>
      <link href="/2018/11/16/%E5%9B%BE%E8%A7%A3Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80/"/>
      <url>/2018/11/16/%E5%9B%BE%E8%A7%A3Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>最近在整理数据结构方面的知识, 系统化看了下Java中常用数据结构.<br>主要基于jdk8, 可能会有些特性与jdk7之前不相同, 例如LinkedList LinkedHashMap中的双向列表不再是回环的.<br>HashMap中的单链表是尾插, 而不是头插入等等, 后文不再赘叙这些差异, 本文目录结构如下:</p><p> <img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717140301329-1795204354.png" alt=""></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>经典的双链表结构, 适用于乱序插入, 删除. 指定序列操作则性能不如ArrayList, 这也是其数据结构决定的.</p><p><strong>add(E) / addLast(E)</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717133746276-313211308.gif" alt=""></p><p><strong>add(index, E)</strong></p><p>这边有个小的优化, 他会先判断index是靠近队头还是队尾, 来确定从哪个方向遍历链入.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">Node&lt;E&gt; x = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">x = x.next;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; x = last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">x = x.prev;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134043714-1008528320.gif" alt=""></p><p><strong>靠队尾</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134100309-1487165805.gif" alt=""></p><p><strong>get(index)</strong></p><p>也是会先判断index, 不过性能依然不好, 这也是为什么不推荐用for(int i = 0; i &lt; lengh; i++)的方式遍历linkedlist, 而是使用iterator的方式遍历.</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134201828-1536755274.gif" alt=""></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134212062-1192617618.gif" alt=""></p><p><strong>remove(E)</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134240000-783801823.gif" alt=""></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>底层就是一个数组, 因此按序查找快, 乱序插入, 删除因为涉及到后面元素移位所以性能慢.</p><p><strong>add(index, E)</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134402495-1450834113.gif" alt=""></p><p><strong>扩容</strong></p><p>一般默认容量是10, 扩容后, 会length*1.5.</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180718113204058-1401567917.gif" alt=""></p><p><strong>remove(E)</strong></p><p>循环遍历数组, 判断E是否equals当前元素, 删除性能不如LinkedList.</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134440963-1609104909.gif" alt=""></p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>经典的数据结构, 底层也是数组, 继承自Vector, 先进后出FILO, 默认new Stack()容量为10, 超出自动扩容.</p><p><strong>push(E)</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134532106-566548837.gif" alt=""></p><p><strong>pop()</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134546142-1425174736.gif" alt=""></p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>Stack的一个典型应用就是计算表达式如 9 + (3 - 1) * 3 + 10 / 2, 计算机将中缀表达式转为后缀表达式, 再对后缀表达式进行计算.</p><p><strong>中缀转后缀</strong></p><ul><li>数字直接输出</li><li>栈为空时，遇到运算符，直接入栈</li><li>遇到左括号, 将其入栈</li><li>遇到右括号, 执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。</li><li>遇到运算符(加减乘除)：弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈</li><li>最终将栈中的元素依次出栈，输出。</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134649235-361366195.gif" alt=""></p><p><strong>计算后缀表达</strong></p><ul><li>遇到数字时，将数字压入堆栈</li><li>遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算, 并将结果入栈</li><li>重复上述过程直到表达式最右端</li><li>运算得出的值即为表达式的结果</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134706912-413651296.gif" alt=""></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与Stack的区别在于, Stack的删除与添加都在队尾进行, 而Queue删除在队头, 添加在队尾.</p><p><strong>ArrayBlockingQueue</strong></p><p>生产消费者中常用的阻塞有界队列, FIFO.</p><p><strong>put(E)</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134917471-223068187.gif" alt=""></p><p><strong>put(E) 队列满了</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134930548-1581371083.gif" alt=""></p><p><strong>take()</strong></p><p>当元素被取出后, 并没有对数组后面的元素位移, 而是更新takeIndex来指向下一个元素.</p><p>takeIndex是一个环形的增长, 当移动到队列尾部时, 会指向0, 再次循环.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717134947090-1857674903.gif" alt=""></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>最常用的哈希表, 面试的童鞋必备知识了, 内部通过数组 + 单链表的方式实现. jdk8中引入了红黑树对长度 &gt; 8的链表进行优化, 我们另外篇幅再讲.</p><p><strong>put(K, V**</strong>)**</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717135210703-312944088.gif" alt=""></p><p><strong>put(K, V) 相同hash值</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717135235292-826682325.gif" alt=""></p><p><strong>resize 动态扩容</strong></p><p>当map中元素超出设定的阈值后, 会进行resize (length * 2)操作, 扩容过程中对元素一通操作, 并放置到新的位置.</p><p>具体操作如下:</p><ul><li>在jdk7中对所有元素直接rehash, 并放到新的位置.</li><li>在jdk8中判断元素原hash值新增的bit位是0还是1, 0则索引不变, 1则索引变成”原索引 + oldTable.length”.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义两条链</span></span><br><span class="line">    <span class="comment">//原来的hash值新增的bit为0的链，头部和尾部</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//原来的hash值新增的bit为1的链，头部和尾部</span></span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">//循环遍历出链条链</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//扩容前后位置不变的链</span></span><br><span class="line">    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j] = loHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容后位置加上原数组长度的链</span></span><br><span class="line">    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j + oldCap] = hiHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717135330300-1394283875.gif" alt=""></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>继承自HashMap, 底层额外维护了一个双向链表来维持数据有序. 可以通过设置accessOrder来实现FIFO(插入有序)或者LRU(访问有序)缓存.</p><p><strong>put(K, V)</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717135428093-1692938646.gif" alt=""></p><p><strong>get(K)</strong></p><p>accessOrder为false的时候, 直接返回元素就行了, 不需要调整位置. </p><p>accessOrder为true的时候, 需要将最近访问的元素, 放置到队尾.</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717135449262-926868516.gif" alt=""></p><p><strong>removeEldestEntry 删除最老的元素</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1285727-20180717135601748-1338089287.gif" alt=""></p><div class="note info"><p>作者：大道方圆<br>出处：<a href="https://www.cnblogs.com/xdecode/" target="_blank" rel="noopener">https://www.cnblogs.com/xdecode</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx 思维导图</title>
      <link href="/2018/11/12/Nginx-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2018/11/12/Nginx-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1542003576573_0.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenCV + Python 实现简单人脸识别</title>
      <link href="/2018/11/12/OpenCV-Python-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
      <url>/2018/11/12/OpenCV-Python-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>如果读取图像首先要导入OpenCV包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br></pre></td></tr></table></figure></p><p>OpenCV自带的haarcascade_frontalface_default.xml，在cv2/data/目录下能找到,包含了所有OpenCV的人脸检测XML文件。</p><ul><li>haarcascade_eye.xml</li><li>haarcascade_eye_tree_eyeglasses.xml</li><li>haarcascade_frontalcatface.xml</li><li>haarcascade_frontalcatface_extended.xml</li><li>haarcascade_frontalface_alt.xml</li><li>haarcascade_frontalface_alt_tree.xml</li><li>haarcascade_frontalface_alt2.xml</li><li>haarcascade_frontalface_default.xml</li><li>haarcascade_fullbody.xml</li><li>haarcascade_lefteye_2splits.xml</li><li>haarcascade_licence_plate_rus_16stages.xml</li><li>haarcascade_lowerbody.xml</li><li>haarcascade_profileface.xml</li><li>haarcascade_righteye_2splits.xml</li><li>haarcascade_russian_plate_number.xml</li><li>haarcascade_smile.xml</li><li>haarcascade_upperbody.xml</li></ul><p>直接上代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/11/5 14:21</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : face_id.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"><span class="comment"># 人脸识别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">filename = <span class="string">"C:\\Users\\Administrator\\Pictures\\2018-05-16\\1865.JPG"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment"># haarcascade_frontalface_default.xml存储在package安装的位置</span></span><br><span class="line">    <span class="comment"># haarcascade_frontalface_default 识别人脸</span></span><br><span class="line">    <span class="comment"># haarcascade_eye 识别眼睛</span></span><br><span class="line">    face_cascade = cv2.CascadeClassifier(</span><br><span class="line">        <span class="string">"D:\\Python\\Python37\\Lib\\site-packages\\cv2\\data\\haarcascade_frontalface_default.xml"</span>)</span><br><span class="line">    eye_cascade = cv2.CascadeClassifier(<span class="string">"D:\\Python\\Python37\\Lib\\site-packages\\cv2\\data\\haarcascade_eye.xml"</span>)</span><br><span class="line">    img = cv2.imread(filename)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 传递参数是scaleFactor和minNeighbors,分别表示人脸检测过程中每次迭代时图像的压缩率以及每个人脸矩形保留近邻数目的最小值</span></span><br><span class="line">    <span class="comment"># 检测结果返回人脸矩形数组</span></span><br><span class="line">    faces = face_cascade.detectMultiScale(gray, <span class="number">1.1</span>, <span class="number">5</span>)</span><br><span class="line">    print(faces)</span><br><span class="line">    <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">        <span class="comment"># 给最新的检测到的人脸图片外面，标明一个方框</span></span><br><span class="line">        img = cv2.rectangle(img, (x, y), (x + w, y + h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line">        face_re = img[y:y + h, x:x + h]</span><br><span class="line">        face_re_g = gray[y:y + h, x:x + h]</span><br><span class="line">        eyes = eye_cascade.detectMultiScale(face_re_g)</span><br><span class="line">        <span class="keyword">for</span> (ex, ey, ew, eh) <span class="keyword">in</span> eyes:</span><br><span class="line">            cv2.rectangle(face_re, (ex, ey), (ex + ew, ey + eh), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cv2.namedWindow("Human Face Result!")</span></span><br><span class="line">    <span class="comment"># cv2.imshow("Human Face Result!", img)</span></span><br><span class="line">    <span class="comment"># 吧识别后的图片保存至指定目录</span></span><br><span class="line">    cv2.imwrite(<span class="string">"C:\\Users\\Administrator\\Pictures\\2018-05-16\\Face.jpg"</span>, img)</span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line">detect(filename)</span><br></pre></td></tr></table></figure></p><p>效果如下图：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/3ed14e189ed9a8c50d9759a50e6b362.png" alt=""></p><p>根据检测结果，可以看到，OpenCV人脸检测效果好像并不太好。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Class.getResource和ClassLoader.getResource的区别分析</title>
      <link href="/2018/11/12/Class-getResource%E5%92%8CClassLoader-getResource%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/"/>
      <url>/2018/11/12/Class-getResource%E5%92%8CClassLoader-getResource%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="Class-getResource-String-path"><a href="#Class-getResource-String-path" class="headerlink" title="Class.getResource(String path)"></a>Class.getResource(String path)</h2><p>path不以’/‘开头时，默认是从此类所在的包下取资源；path以’/‘开头时，则是从项目的ClassPath根下获取资源。在这里’/‘表示ClassPath<br>JDK设置这样的规则，是很好理解的，path不以’/‘开头时，我们就能获取与当前类所在的路径相同的资源文件，而以’/‘开头时可以获取ClassPath根下任意路径的资源。<br>如下所示的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Test.class.getResource(<span class="string">""</span>));</span><br><span class="line">        System.out.println(Test.class.getResource(<span class="string">"/"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>file:/D:/work_space/java/bin/net/swiftlet/<br>file:/D:/work_space/java/bin/</p><h2 id="Class-getClassLoader-getResource-String-path"><a href="#Class-getClassLoader-getResource-String-path" class="headerlink" title="Class.getClassLoader().getResource(String path)"></a>Class.getClassLoader().getResource(String path)</h2><p>path不能以’/‘开头时，path是指类加载器的加载范围，在资源加载的过程中，使用的逐级向上委托的形式加载的，’/‘表示Boot ClassLoader中的加载范围，因为这个类加载器是C++实现的，所以加载范围为null。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Test.class.getClassLoader().getResource(<span class="string">""</span>));</span><br><span class="line">        System.out.println(Test.class.getClassLoader().getResource(<span class="string">"/"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>file:/D:/work_space/java/bin/<br>null<br><strong>从上面可以看出：</strong><br>class.getResource(“/“) == class.getClassLoader().getResource(“”)<br>其实，Class.getResource和ClassLoader.getResource本质上是一样的，都是使用ClassLoader.getResource加载资源的。下面请看一下jdk的Class源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.net.<span class="function">URL <span class="title">getResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        name = resolveName(name);</span><br><span class="line">        ClassLoader cl = getClassLoader0();</span><br><span class="line">        <span class="keyword">if</span> (cl==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A system class.</span></span><br><span class="line">            <span class="keyword">return</span> ClassLoader.getSystemResource(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cl.getResource(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面就可以看才出来：Class.getResource和ClassLoader.getResource本质上是一样的。至于为什么Class.getResource(String path)中path可以’/‘开头，是因为在name = resolveName(name);进行了处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">resolveName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> name;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!name.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">           Class c = <span class="keyword">this</span>;</span><br><span class="line">           <span class="keyword">while</span> (c.isArray()) &#123;</span><br><span class="line">               c = c.getComponentType();</span><br><span class="line">           &#125;</span><br><span class="line">           String baseName = c.getName();</span><br><span class="line">           <span class="keyword">int</span> index = baseName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">           <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">               name = baseName.substring(<span class="number">0</span>, index).replace(<span class="string">'.'</span>, <span class="string">'/'</span>)</span><br><span class="line">                   +<span class="string">"/"</span>+name;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是以"/"开头，则去掉</span></span><br><span class="line">           name = name.substring(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手写mini版本的Spring</title>
      <link href="/2018/11/09/%E6%89%8B%E5%86%99mini%E7%89%88%E6%9C%AC%E7%9A%84Spring/"/>
      <url>/2018/11/09/%E6%89%8B%E5%86%99mini%E7%89%88%E6%9C%AC%E7%9A%84Spring/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此篇文章面向有spring、反射机制有基础的人。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天看了个大佬的视屏，1小时手写了个简单的Spring框架，感触极深。今天特地花了一天时间，也写了个mini版的Spring框架，基本功能完整，不过离真正的Spring还差十万八千里。</p><p>首先，先来介绍一下Spring的三个阶段，配置阶段、初始化阶段和运行阶段：</p><ul><li>配置阶段：主要是完成application.xml配置和Annotation配置。</li><li>初始化阶段：主要是加载并解析配置信息，然后，初始化IOC容器，完成容器的DI操作，已经完成HandlerMapping的初始化。</li><li>运行阶段：主要是完成Spring容器启动以后，完成用户请求的内部调度，并返回响应结果。</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/145547vx81m3ypcdrp3hh1.png" alt=""></p><p>项目结构(如下图)：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20181109193035.png" alt=""></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="pom-xml需要的依赖："><a href="#pom-xml需要的依赖：" class="headerlink" title="pom.xml需要的依赖："></a>pom.xml需要的依赖：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 编译测试期间有效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没错只需要一个servlet-api。</p><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@FFController</span>()</span><br><span class="line"><span class="meta">@FFRequestMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FFAutowired</span></span><br><span class="line">    <span class="keyword">private</span> IDemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FFRequestMapping</span>(<span class="string">"/query.json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                      @FFRequestParam(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        String result = demoService.get(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().write(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FFRequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @FFRequestParam(<span class="string">"a"</span>)</span> String a, @<span class="title">FFRequestParam</span><span class="params">(<span class="string">"b"</span>)</span> String b) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().write(a + b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FFRequestMapping</span>(<span class="string">"/remove"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       @FFRequestParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().write(id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解为自定义注解，可暂时不加</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FFService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> <span class="keyword">implements</span> <span class="title">IDemoService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello,"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解为自定义注解，可暂时不加</p><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanPackage=com<span class="selector-class">.felix</span><span class="selector-class">.demo</span></span><br></pre></td></tr></table></figure><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Felix Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ffmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.felix.mvcframework.servlet.FFDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ffmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写自定义注解"><a href="#编写自定义注解" class="headerlink" title="编写自定义注解"></a>编写自定义注解</h2><h3 id="FFController、FFAutowired、FFRequestMapping、FFRequestParam、FFService"><a href="#FFController、FFAutowired、FFRequestMapping、FFRequestParam、FFService" class="headerlink" title="FFController、FFAutowired、FFRequestMapping、FFRequestParam、FFService"></a>FFController、FFAutowired、FFRequestMapping、FFRequestParam、FFService</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建FFController注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Target</span>说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、</span></span><br><span class="line"><span class="comment"> * 类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Retention</span>定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中， 而被编译器丢弃；</span></span><br><span class="line"><span class="comment"> * 而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，</span></span><br><span class="line"><span class="comment"> * 而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Documented</span>用于描述其它类型的annotation应该被作为被标注的程序成员的公共API， 因此可以被例如javadoc此类的工具文档化。</span></span><br><span class="line"><span class="comment"> * Documented是一个标记注解，没有成员。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FFController &#123;</span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//FFAutowired</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FFAutowired &#123;</span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FFRequestMapping</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FFRequestMapping &#123;</span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FFRequestParam</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FFRequestParam &#123;</span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FFService</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FFService &#123;</span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义注解方面配置具体功能百度</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>创建FFDispatcherServlet，继承HttpServlet，重写init(),doGet(),doPost()</p><p>声明几个成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动入口类</span></span><br><span class="line"><span class="comment"> * 继承HttpServlet，重写init()、doGet()和doPost()方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Felix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FFDispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与web.xml中param_name一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCATION = <span class="string">"contextConfigLocation"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存所有的配置信息</span></span><br><span class="line">    <span class="keyword">private</span> Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存所有被扫描的相关的类名</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心IOC容器，保存所有初始化bean</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存所有的url和方法的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Method&gt; handlerMapping = <span class="keyword">new</span> HashMap&lt;String, Method&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FFDispatcherServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Servlet容器启动时，会调用FFDispatcherServlet的init()方法，从init方法的参数中，我们可以拿到主配置文件的路径，从能够读取到配置文件中的信息。前面我们已经介绍了Spring的三个阶段，现在来完成初始化阶段的代码。在init()方法中，定义好执行步骤，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，加载配置文件</span></span><br><span class="line"><span class="comment"> * 当Servlet容器启动时，会调用FFDispatcherServlet的init()方法，</span></span><br><span class="line"><span class="comment"> * 从init方法的参数中，我们可以拿到主配置文件的路径，从能够读取到配置文件中的信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.加载配置文件</span></span><br><span class="line">    doLoadConfig(config.getInitParameter(LOCATION));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.扫描所有相关类</span></span><br><span class="line">    doScanner(p.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.初始化所有相关类的实例，保存到IOC容器中</span></span><br><span class="line">    doInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.依赖注入</span></span><br><span class="line">    doAutowired();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.构造HandlerMapping</span></span><br><span class="line">    initHandlerMapping();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.等待请求，匹配URL,定位方法，反射调用执行</span></span><br><span class="line">    <span class="comment">//调用doGet或者doPost方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提示信息</span></span><br><span class="line">    System.out.println(<span class="string">"felix mvcframework is init"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doLoadConfig-方法的实现，将文件读取到Properties对象中"><a href="#doLoadConfig-方法的实现，将文件读取到Properties对象中" class="headerlink" title="doLoadConfig()方法的实现，将文件读取到Properties对象中"></a>doLoadConfig()方法的实现，将文件读取到Properties对象中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件读取到Properties对象中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    InputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(location);</span><br><span class="line">        p.load(fis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doScanner-方法，递归扫描出所有的Class文件"><a href="#doScanner-方法，递归扫描出所有的Class文件" class="headerlink" title="doScanner()方法，递归扫描出所有的Class文件"></a>doScanner()方法，递归扫描出所有的Class文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归扫描出所有的Class文件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将所有包路径转换为文件路径  com.felix.demo -&gt; /com/felix/demo</span></span><br><span class="line">    URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(scanPackage.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">    File dir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        <span class="comment">//如果是文件夹，递归扫描</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            doScanner(scanPackage + <span class="string">"."</span> + file.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            classNames.add(scanPackage + <span class="string">"."</span> + file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>).trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doInstance-方法，初始化所有相关的类，并放入到IOC容器之中。"><a href="#doInstance-方法，初始化所有相关的类，并放入到IOC容器之中。" class="headerlink" title="doInstance()方法，初始化所有相关的类，并放入到IOC容器之中。"></a>doInstance()方法，初始化所有相关的类，并放入到IOC容器之中。</h3><p>IOC容器的key默认是类名首字母小写，如果是自己设置类名，则优先使用自定义的。因此，要先写一个针对类名首字母处理的工具方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首字母小写</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowerFirstCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] &gt;= <span class="string">'A'</span> &amp;&amp; chars[<span class="number">0</span>] &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            chars[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，再处理相关的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化所有相关的类，并放入到IOC容器之中。</span></span><br><span class="line"><span class="comment">// IOC容器的key默认是类名首字母小写，如果是自己设置类名，则优先使用自定义的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (classNames.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// isAnnotationPresent:如果指定类型的注解存在于此元素上，则返回 true，否则返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(FFController.class)) &#123;</span><br><span class="line">                <span class="comment">//默认将首字母小写座位beanName</span></span><br><span class="line">                String beanName = StringUtil.lowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                ioc.put(beanName, clazz.newInstance());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(FFService.class)) &#123;</span><br><span class="line">                <span class="comment">//getAnnotation:该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。</span></span><br><span class="line">                FFService service = clazz.getAnnotation(FFService.class);</span><br><span class="line">                String beanName = service.value();</span><br><span class="line">                <span class="comment">//若用户设置了名字，用用户设置的</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                    ioc.put(beanName, clazz.newInstance());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//用户没设置，就按照接口类型创建一个实例</span></span><br><span class="line">                <span class="comment">//getInterfaces返回该类所实现的接口的一个数组</span></span><br><span class="line">                Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">                    ioc.put(anInterface.getName(), clazz.newInstance());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="doAutowired-方法，将初始化到IOC容器中的类，需要赋值的字段进行赋值"><a href="#doAutowired-方法，将初始化到IOC容器中的类，需要赋值的字段进行赋值" class="headerlink" title="doAutowired()方法，将初始化到IOC容器中的类，需要赋值的字段进行赋值"></a>doAutowired()方法，将初始化到IOC容器中的类，需要赋值的字段进行赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将初始化到IOC容器中的类，需要赋值的字段进行赋值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAutowired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//拿到实例对象中所有属性</span></span><br><span class="line">        Field[] fields = entry.getValue().getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!field.isAnnotationPresent(FFAutowired.class)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            FFAutowired autowired = field.getAnnotation(FFAutowired.class);</span><br><span class="line">            String beanName = autowired.value().trim();</span><br><span class="line">            <span class="comment">//默认就用字段名</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName)) &#123;</span><br><span class="line">                beanName = field.getType().getName();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置私有属性访问权</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//赋值</span></span><br><span class="line">                field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initHandlerMapping-方法，将FFRequestMapping中配置的信息和Method进行关联，并保存这些关系。"><a href="#initHandlerMapping-方法，将FFRequestMapping中配置的信息和Method进行关联，并保存这些关系。" class="headerlink" title="initHandlerMapping()方法，将FFRequestMapping中配置的信息和Method进行关联，并保存这些关系。"></a>initHandlerMapping()方法，将FFRequestMapping中配置的信息和Method进行关联，并保存这些关系。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将FFRequestMapping中配置的信息和Method进行关联，并保存这些关系。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = entry.getValue().getClass();</span><br><span class="line">        <span class="keyword">if</span> (!clazz.isAnnotationPresent(FFController.class)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String baseUrl = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//读取Controller的url值</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(FFRequestMapping.class)) &#123;</span><br><span class="line">            FFRequestMapping mapping = clazz.getAnnotation(FFRequestMapping.class);</span><br><span class="line">            baseUrl = mapping.value();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取method的url</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没FFRequestMapping注解的忽略</span></span><br><span class="line">            <span class="keyword">if</span> (!method.isAnnotationPresent(FFRequestMapping.class)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FFRequestMapping mapping = method.getAnnotation(FFRequestMapping.class);</span><br><span class="line">            <span class="comment">//吧多个/替换成一个/</span></span><br><span class="line">            String url = (<span class="string">"/"</span> + baseUrl + <span class="string">"/"</span> + mapping.value()).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">            handlerMapping.put(url, method);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"mapped"</span> + url + <span class="string">","</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，初始化阶段的所有代码全部写完。</p><h2 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h2><p>来到运行阶段，当用户发送请求被Servlet接受时，都会统一调用doPost方法，我先在doPost方法中再调用doDispach()方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行业务逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doDispatch(req, resp);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        resp.getWriter().write(<span class="string">"500 Exception,Details:\r\n"</span> + Arrays.toString(e.getStackTrace())</span><br><span class="line">                .replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>).replaceAll(<span class="string">"\\s"</span>, <span class="string">"\r\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch()"></a>doDispatch()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMapping.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String url = req.getRequestURI();</span><br><span class="line">    String contextPath = req.getContextPath();</span><br><span class="line">    url = url.replaceAll(contextPath, <span class="string">""</span>)</span><br><span class="line">            .replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.handlerMapping.containsKey(url)) &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">"404 Not Found！！！！！！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">    Method method = <span class="keyword">this</span>.handlerMapping.get(url);</span><br><span class="line">    <span class="comment">//获取方法的参数列表</span></span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    <span class="comment">//获取请求的参数</span></span><br><span class="line">    Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</span><br><span class="line">    <span class="comment">//保存参数</span></span><br><span class="line">    Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line">    <span class="comment">//方法的参数列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">        <span class="comment">//根据参数名称，做某些处理</span></span><br><span class="line">        Class parameterType = parameterTypes[i];</span><br><span class="line">        <span class="keyword">if</span> (parameterType == HttpServletRequest.class) &#123;</span><br><span class="line">            <span class="comment">//参数类型已明确，强转</span></span><br><span class="line">            paramValues[i] = req;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterType == HttpServletResponse.class) &#123;</span><br><span class="line">            paramValues[i] = resp;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterType == String.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</span><br><span class="line">                String value = Arrays.toString(param.getValue())</span><br><span class="line">                        .replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>)</span><br><span class="line">                        .replaceAll(<span class="string">",\\s"</span>, <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">                paramValues[i] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String beanName = StringUtil.lowerFirstCase(method.getDeclaringClass().getSimpleName());</span><br><span class="line">        <span class="comment">//利用反射机制调用</span></span><br><span class="line">        method.invoke(<span class="keyword">this</span>.ioc.get(beanName), paramValues);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们完成了一个mini版本的Spring，麻雀虽小，五脏俱全。我们把服务发布到web容器中，然后，在浏览器输入：<a href="http://localhost:8080/ffmvc/demo/query.json?name=felix" target="_blank" rel="noopener">http://localhost:8080/ffmvc/demo/query.json?name=felix</a>，就会得到下面的结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/3211e612dea72bc7d6761b5c273efcf.png" alt=""></p><p>当然，真正的Spring要复杂很多，但核心设计思路基本如此。</p><p>代码已上传至我的github： <a href="https://github.com/542869246/felix-mvcframework" target="_blank" rel="noopener">https://github.com/542869246/felix-mvcframework</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDB学习笔记（增删改查、聚合、索引、连接、备份与恢复、监控等）</title>
      <link href="/2018/11/06/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E3%80%81%E8%81%9A%E5%90%88%E3%80%81%E7%B4%A2%E5%BC%95%E3%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%EF%BC%89/"/>
      <url>/2018/11/06/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E3%80%81%E8%81%9A%E5%90%88%E3%80%81%E7%B4%A2%E5%BC%95%E3%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E3%80%81%E7%9B%91%E6%8E%A7%E7%AD%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h1 id="MongoDB-简介"><a href="#MongoDB-简介" class="headerlink" title="MongoDB - 简介"></a>MongoDB - 简介</h1><div class="note info"><p>官网：<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com</a></p></div><ul><li>MongoDB 是一个基于分布式文件存储的数据库，由 C++ 语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li><li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li><li>MongoDB 将数据存储在类似JSON的灵活文档中，这意味着字段可能因文档而异，并且数据结构可能会随时间而变化</li><li>文档模型映射到应用程序代码中的对象，使数据易于使用</li><li>即席查询，索引和实时聚合提供了访问和分析数据的强大方法</li><li>MongoDB是一个分布式数据库，因此内置了高可用性，水平扩展和地理分布，并且易于使用</li><li>MongoDB是免费的开源软件。2018年10月16日之前发布的版本根据AGPL发布。2018年10月16日之后发布的所有版本（包括先前版本的修补程序）都在<a href="https://www.mongodb.com/licensing/server-side-public-license" target="_blank" rel="noopener">服务器端公共许可证（SSPL）v1下发布</a>。</li></ul><h1 id="MongoDB-安装及运行"><a href="#MongoDB-安装及运行" class="headerlink" title="MongoDB - 安装及运行"></a>MongoDB - 安装及运行</h1><ol><li><p>下载<br>我下载的是4.0.3版本<br><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community</a></p></li><li><p>创建数据目录<br>MongoDB 将数据目录存储在 db 目录下，需手动创建。<br> <code>D:\MongoDB\data\db</code></p></li><li><p>运行 MongoDB 服务器<br>为了从命令提示符下运行MongoDB服务器，你必须从<code>MongoDB\bin</code>目录中执行<code>mongod.exe</code>文件，不要关闭服务。<code>ctrl + c</code>关闭。<br><code>mongod.exe --dbpath D:\MongoDB\data\db</code></p></li><li><p>MongoDB 后台管理<br>运行 mongo.exe<br>MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。</p></li><li><p>将 MongoDB 服务器作为 Windows 服务运行<br>添加系统环境 path <code>D:\MongoDB\Server\3.4\bin</code><br>检测：cmd 中输入 <code>mongod --help</code><br>新建文件：<code>D:\MongoDB\logs\logs.log</code><br>将 MongoDB 服务器作为 Windows 服务随 Windows 启动而开启：<br>mongod.exe –logpath “D:\MongoDB\logs\logs.log” –logappend –dbpath “D:\MongoDB\data” –directoryperdb –serviceName MongoDB –install</p></li></ol><p>开启 MongoDB 服务：<code>net start MongoDB</code><br>停止 MongoDB 服务：<code>net stop MongoDB</code><br>删除 MongoDB 服务：<code>sc delete MongoDB</code></p><p>接下来就可以在 cmd 中运行 <code>D:\MongoDB\Server\3.4\bin</code> 里面的 <code>*.exe</code> 程序了</p><ul><li>shell 控制台 <code>mongo</code></li><li>数据库的还原 <code>mongorestore</code></li><li>备份 <code>mongodump</code></li></ul><ol start="6"><li>mongodb 启动的参数</li></ol><p><img src="//upload-images.jianshu.io/upload_images/5832745-f4af7e3ac87f58db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/742/format/webp" alt=""></p><h1 id="mongoDB-主要特点"><a href="#mongoDB-主要特点" class="headerlink" title="mongoDB - 主要特点"></a>mongoDB - 主要特点</h1><ul><li>MongoDB安装简单。</li><li>MongoDB的提供了一个面向文档存储，没有表结构的概念，每天记录可以有完全不同的结构，操作起来比较简单和容易。</li><li>完全的索引支持（单键索引、数组索引、全文索引、地理位置索引 等）</li><li>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li><li>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li><li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li><li>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。</li><li>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</li><li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</li><li>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</li><li>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li><li>MongoDB 支持多种编程语言:C C++ C# .NET Erlang Haskell Java JavaScript Lisp node.JS Perl PHP Python Ruby Scala 等</li></ul><h1 id="mongoDB-工具"><a href="#mongoDB-工具" class="headerlink" title="mongoDB - 工具"></a>mongoDB - 工具</h1><p>监控</p><ul><li>Munin：网络和系统监控工具</li><li>Gangila：网络和系统监控工具</li><li>Cacti：用于查看CPU负载, 网络带宽利用率，它也提供了一个应用于监控 MongoDB 的插件。</li></ul><p>GUI</p><ul><li>Robomongo（Robo 3T）</li><li>Fang of Mongo – 网页式，由Django和jQuery所构成。</li><li>Futon4Mongo – 一个CouchDB Futon web的mongodb山寨版。</li><li>Mongo3 – Ruby写成。</li><li>MongoHub – 适用于OSX的应用程序。</li><li>Opricot – 一个基于浏览器的MongoDB控制台, 由PHP撰写而成。</li><li>Database Master — Windows的mongodb管理工具</li><li>RockMongo — 最好的PHP语言的MongoDB管理工具，轻量级, 支持多国语言.</li><li>Navicat Premium 12 — 个人最喜欢用的一款数据库管理工具，12版本支持了mongodb,支持mysql,oracle,sql server等多种数据库(<a href="/2018/11/06/Navicat-Premium-12-1-8-0安装与激活/">破解方法点击这里</a>)<h1 id="mongoDB-三大重要概念"><a href="#mongoDB-三大重要概念" class="headerlink" title="mongoDB - 三大重要概念"></a>mongoDB - 三大重要概念</h1></li></ul><p><img src="//upload-images.jianshu.io/upload_images/5832745-62123818bf6065c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/742/format/webp" alt="" title="该表将帮助您更容易理解Mongo中的一些概念"></p><p><img src="//upload-images.jianshu.io/upload_images/5832745-306219905f1cb2fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/858/format/webp" alt=""></p><h2 id="1-database-数据库"><a href="#1-database-数据库" class="headerlink" title="1. database 数据库"></a>1. database 数据库</h2><p>多个集合逻辑上组织在一起，就是数据库。</p><p>数据库命名规范：</p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、/、\和\0 (空字符)。</li><li>应全部小写。</li><li>最多64字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li>admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li><li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li><li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li></ul><h2 id="2-collection-集合"><a href="#2-collection-集合" class="headerlink" title="2. collection 集合"></a>2. collection 集合</h2><p>多个文档组成一个集合，相当于关系数据库的表。</p><p>所有存储在集合中的数据都是 BSON 格式，BSON 是类 JSON 的一种二进制形式的存储格式，简称 Binary JSON。</p><p>集合名命名规范：</p><ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li><li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</li></ul><p><img src="//upload-images.jianshu.io/upload_images/5832745-7b32e19155165d6d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/743/format/webp" alt=""></p><h2 id="3-document-文档"><a href="#3-document-文档" class="headerlink" title="3. document 文档"></a>3. document 文档</h2><p>MongoDB 将数据存储为一个文档，数据结构由键值对组成。</p><p>MongoDB 文档是一组键值对(即BSON，二进制的 JSON)，类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><p>文档键命名规范：</p><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><p>需要注意的是：</p><ul><li>文档中的键值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ul><p><img src="//upload-images.jianshu.io/upload_images/5832745-2faceb92a959341b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/570/format/webp" alt=""></p><h1 id="MongoDB-数据类型"><a href="#MongoDB-数据类型" class="headerlink" title="MongoDB - 数据类型"></a>MongoDB - 数据类型</h1><p>ObjectId：主键，一种特殊而且非常重要的类型，每个文档都会默认配置这个属性，属性名为_id，除非自己定义，方可覆盖</p><p><img src="//upload-images.jianshu.io/upload_images/5832745-9b33ceb394bb84f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/744/format/webp" alt=""></p><h1 id="MongoDB-常见操作"><a href="#MongoDB-常见操作" class="headerlink" title="MongoDB - 常见操作"></a>MongoDB - 常见操作</h1><h2 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">db</span></span><br></pre></td></tr></table></figure><h2 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h2><p>没有数据的数据库不予显示</p><p>MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">show dbs</span></span><br></pre></td></tr></table></figure></p><h2 id="连接到指定的数据库"><a href="#连接到指定的数据库" class="headerlink" title="连接到指定的数据库"></a>连接到指定的数据库</h2><p>如果数据库不存在，则创建数据库，否则切换到指定数据库。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> db_name</span><br></pre></td></tr></table></figure></p><h2 id="查看服务器状态"><a href="#查看服务器状态" class="headerlink" title="查看服务器状态"></a>查看服务器状态</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.serverStatus</span>()</span><br></pre></td></tr></table></figure><h2 id="查看数据库统计信息"><a href="#查看数据库统计信息" class="headerlink" title="查看数据库统计信息"></a>查看数据库统计信息</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.stats</span>()</span><br></pre></td></tr></table></figure><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.dropDatabase</span>()</span><br></pre></td></tr></table></figure><h2 id="查看数据库中所有集合"><a href="#查看数据库中所有集合" class="headerlink" title="查看数据库中所有集合"></a>查看数据库中所有集合</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show tables</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">show collections</span><br></pre></td></tr></table></figure><h2 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h2><p>删除里面的文档，但集合还在<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_name</span><span class="selector-class">.remove</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>删除集合<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.drop</span>()</span><br></pre></td></tr></table></figure></p><p>查看集合详细信息</p><p>MongoDB 的3.0后的版本分了三种模式 queryPlanner、executionStats、allPlansExecution<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_name</span><span class="selector-class">.find</span>(&#123;<span class="attribute">key</span>:value&#125;)<span class="selector-class">.explain</span>("<span class="selector-tag">allPlansExecution</span>")</span><br></pre></td></tr></table></figure></p><h1 id="MongoDB-增删改查"><a href="#MongoDB-增删改查" class="headerlink" title="MongoDB - 增删改查"></a>MongoDB - 增删改查</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档：<br>如果该集合不在该数据库中， MongoDB 会<code>自动创建该集合并插入文档</code>。</p><p>insert() 或 save() 方法都可以向collection里插入数据，两者区别：</p><ul><li>如果不指定 _id 字段，<strong>save() 方法</strong>类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</li><li>使用save函数，如果原来的对象不存在，那他们都可以向collection里插入数据，如果已经存在，save会调用update更新里面的记录，而insert则会忽略操作</li><li>insert可以一次性插入一个列表，而不用遍历，效率高， save则需要遍历列表，一个个插入。<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.insert</span>(document)</span><br><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.save</span>(document)</span><br></pre></td></tr></table></figure></li></ul><p>插入一个文档到 col 集合中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_1</span><span class="selector-class">.insert</span>(&#123;</span><br><span class="line">    <span class="attribute">title</span>: <span class="string">'MongoDB 教程'</span>,</span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'菜鸟教程'</span>,</span><br><span class="line">    url: <span class="string">'http://www.runoob.com'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>也可以将文档数据定义为一个变量，如下所示：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span> = (&#123;</span><br><span class="line">    title: <span class="string">'MongoDB 教程'</span>,</span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'菜鸟教程'</span>,</span><br><span class="line">    url: <span class="string">'http://www.runoob.com'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: <span class="number">101</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.col_2.insert(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>remove() 函数是用来删除集合中的数据</p><p>在执行 remove() 函数前先执行 find() 命令来判断执行的条件是否正确，这是一个比较好的习惯。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_name</span><span class="selector-class">.remove</span>(</span><br><span class="line">   &lt;<span class="selector-tag">query</span>&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attribute">justOne</span>: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><p>删除集合中所有文档<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col</span><span class="selector-class">.remove</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>移除 col_1 集合中 title 为 MongoDB save 的文档，只删除第一条找到的记录<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_1</span><span class="selector-class">.remove</span>(&#123;<span class="string">'title'</span>:<span class="string">'MongoDB save'</span>&#125;, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>MongoDB 使用 update() 和 save() 方法来更新集合中的文档</p><p><strong>update() 方法</strong>用于更新已存在的文档<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.col_name.update(</span><br><span class="line">   <span class="params">&lt;query&gt;</span>,</span><br><span class="line">   <span class="params">&lt;update&gt;</span>,</span><br><span class="line">   &#123;</span><br><span class="line"><span class="symbol">     upsert:</span> <span class="params">&lt;boolean&gt;</span>,</span><br><span class="line"><span class="symbol">     multi:</span> <span class="params">&lt;boolean&gt;</span>,</span><br><span class="line"><span class="symbol">     writeConcern:</span> <span class="params">&lt;document&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ul><li>query : update 的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在 update 的记录，是否插入记录，true 为插入，默认是 false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li>writeConcern :可选，抛出异常的级别。</li></ul><p>通过 update() 方法来更新 col_1 集合中的 title</p><p>$set 操作符为部分更新操作符，只更新 $set 之后的数据，而不是覆盖之前的数据<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col_1.<span class="keyword">update</span>(&#123; <span class="string">'title'</span>: <span class="string">'MongoDB 教程'</span> &#125;, &#123; $set: &#123; <span class="string">'title'</span>: <span class="string">'MongoDB'</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></p><p>以上语句只会修改第一条发现的文档，如果要修改多条相同的文档，则需要设置 multi 参数为 true。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col_1.<span class="keyword">update</span>(&#123; <span class="string">'title'</span>: <span class="string">'MongoDB 教程'</span> &#125;, &#123; $set: &#123; <span class="string">'title'</span>: <span class="string">'MongoDB'</span> &#125; &#125;, &#123; multi: true &#125;)</span><br></pre></td></tr></table></figure></p><p><strong>save() 方法</strong>通过传入的文档来替换已有文档。语法格式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_name</span><span class="selector-class">.save</span>(</span><br><span class="line">   &lt;<span class="selector-tag">document</span>&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attribute">writeConcern</span>: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>以下实例中我们替换了 col_1 的文档数据：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span> = (&#123;</span><br><span class="line">    <span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"MongoDB save"</span>,</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line">    <span class="string">"by"</span>: <span class="string">"菜鸟"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">    <span class="string">"tags"</span>: [<span class="string">"mongodb"</span>, <span class="string">"database"</span>, <span class="string">"NoSQL"</span>],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.col_1.save(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>find() 方法，它返回集合中所有文档。</p><p>findOne() 方法，它只返回一个文档。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.find</span>(query, projection)</span><br></pre></td></tr></table></figure></p><ul><li>query ：可选，使用查询操作符指定查询条件</li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式化输出</span></span><br><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.find</span>().pretty()</span><br><span class="line"><span class="comment">//查看集合中文档的个数</span></span><br><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.find</span>().count()</span><br><span class="line"><span class="comment">//跳过指定数量的数据</span></span><br><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.find</span>().skip(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//读取指定记录的条数</span></span><br><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.find</span>().limit(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>排序：<br>sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_name</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>(&#123;<span class="attribute">key</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</p><h3 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h3><p>如果你想获取”col”集合中 “likes” 大于100，小于 200 的数据，你可以使用以下命令：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;<span class="symbol">$</span><span class="keyword">lt</span> :<span class="number">200</span>, <span class="symbol">$</span><span class="keyword">gt</span> : <span class="number">100</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于SQL语句：</span></span><br><span class="line">select * from col where likes&gt;<span class="number">100</span> <span class="keyword">AND</span>  likes&lt;<span class="number">200</span>;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">条件操作符</th><th style="text-align:center">中文</th><th style="text-align:center">全英文</th></tr></thead><tbody><tr><td style="text-align:center">$gt</td><td style="text-align:center">大于</td><td style="text-align:center">greater than</td></tr><tr><td style="text-align:center">$gte</td><td style="text-align:center">大于等于</td><td style="text-align:center">greater than equal</td></tr><tr><td style="text-align:center">$lt</td><td style="text-align:center">小于</td><td style="text-align:center">less than</td></tr><tr><td style="text-align:center">$lte</td><td style="text-align:center">小于等于</td><td style="text-align:center">less than equal</td></tr><tr><td style="text-align:center">$ne</td><td style="text-align:center">不等于</td><td style="text-align:center">not equal</td></tr></tbody></table><p><img src="//upload-images.jianshu.io/upload_images/5832745-27e67e57e7f046b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/741/format/webp" alt=""></p><h3 id="type-操作符"><a href="#type-操作符" class="headerlink" title="$type 操作符"></a>$type 操作符</h3><p>用来检索集合中匹配的数据类型</p><p><img src="//upload-images.jianshu.io/upload_images/5832745-4b259a703b51d8c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/743/format/webp" alt=""></p><p>如果想获取 “col” 集合中 title 为 String 的数据，你可以使用以下命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;<span class="string">"title"</span> : &#123;<span class="variable">$type</span> : <span class="number">2</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="AND-条件"><a href="#AND-条件" class="headerlink" title="AND 条件"></a>AND 条件</h3><p>find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，语法格式如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.col_name.find(<span class="comment">&#123;key1:value1, key2:value2&#125;</span>).pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 SQL and 语句：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> col_name <span class="keyword">WHERE</span> key1=<span class="string">'value1'</span> <span class="keyword">AND</span> key2=value2</span><br></pre></td></tr></table></figure></p><h3 id="OR-条件"><a href="#OR-条件" class="headerlink" title="OR 条件"></a>OR 条件</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.col_name.<span class="built_in">find</span>(&#123; $<span class="built_in">or</span>: [&#123; <span class="string">"by"</span>: <span class="string">"菜鸟教程"</span> &#125;, &#123; <span class="string">"title"</span>: <span class="string">"MongoDB 教程"</span> &#125;] &#125;).pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 SQL or 语句：</span></span><br><span class="line"><span class="built_in">SELECT</span> * <span class="keyword">FROM</span> col_name WHERE key1=value1 <span class="built_in">OR</span> key2=value2</span><br></pre></td></tr></table></figure><h3 id="AND-和-OR-联合使用"><a href="#AND-和-OR-联合使用" class="headerlink" title="AND 和 OR 联合使用"></a>AND 和 OR 联合使用</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.col_name.find(&#123;</span><br><span class="line">    <span class="string">"likes"</span>: &#123;</span><br><span class="line">        $gt: <span class="number">50</span></span><br><span class="line">    &#125;,</span><br><span class="line">    $or: [&#123;</span><br><span class="line">        <span class="string">"by"</span>: <span class="string">"菜鸟教程"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"MongoDB 教程"</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;).pretty()</span><br><span class="line"></span><br><span class="line">// 类似常规 SQL 语句：</span><br><span class="line">SELECT * FROM col_name <span class="keyword">where</span> likes&gt;<span class="number">50</span> AND (<span class="keyword">by</span> = <span class="string">'菜鸟教程'</span> OR title = <span class="string">'MongoDB 教程'</span>)</span><br></pre></td></tr></table></figure><h1 id="MongoDB-索引"><a href="#MongoDB-索引" class="headerlink" title="MongoDB - 索引"></a>MongoDB - 索引</h1><blockquote><p>注意：从 mongoDB 3.0 开始，ensureIndex 被废弃，今后都仅仅是 createIndex 的一个别名。</p></blockquote><p>索引通常能够极大的<strong><em>提高查询的效率</em></strong>，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。<br>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p><h2 id="索引常用命令"><a href="#索引常用命令" class="headerlink" title="索引常用命令"></a>索引常用命令</h2><p>getIndexes 查看集合索引情况<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.getIndexes</span>()</span><br></pre></td></tr></table></figure></p><p>hint 强制使用索引<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_name</span><span class="selector-class">.find</span>(&#123;<span class="attribute">age</span>:&#123;$lt:<span class="number">30</span>&#125;&#125;)<span class="selector-class">.hint</span>(&#123;<span class="attribute">name</span>:<span class="number">1</span>, age:<span class="number">1</span>&#125;)<span class="selector-class">.explain</span>()</span><br></pre></td></tr></table></figure></p><p>删除索引(不会删除 _id 索引)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.dropIndexes</span>()</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.dropIndex</span>(&#123;firstname: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="createIndex-方法"><a href="#createIndex-方法" class="headerlink" title="createIndex() 方法"></a>createIndex() 方法</h2><p>MongoDB使用 createIndex() 方法来创建索引</p><p>key 为你要创建的索引字段，1为按升序创建索引，-1为按降序创建索引。<br>也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col_name</span><span class="selector-class">.createIndex</span>(&#123;<span class="attribute">key</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>createIndex() 接收可选参数，可选参数列表如下：</p><p><img src="//upload-images.jianshu.io/upload_images/5832745-a421f1c25b2a04ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" alt=""></p><h3 id="id-索引"><a href="#id-索引" class="headerlink" title="_id 索引"></a>_id 索引</h3><p>对于每个插入的数据，都会自动生成一条唯一的 _id 字段，_id 索引是绝大多数集合默认建立的索引<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.insert</span>(&#123;x:<span class="number">10</span>&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59658e56aaf42d1c98dd95a2"</span>), <span class="string">"x"</span> : <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.getIndexes</span>()</span><br><span class="line">[</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"v"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"key"</span> : &#123;</span><br><span class="line">                        <span class="string">"_id"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"name"</span> : <span class="string">"_id_"</span>,</span><br><span class="line">                <span class="string">"ns"</span> : <span class="string">"runoob.col_1"</span></span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>字段解释：</p><ul><li>v 表示 version，在 Mongo3.2 之前的版本中，会存在 {v:0}（版本锁为0）的情况。在3.2之后的版本中，{v:0} 不再允许使用，这部分可以不去关注，因为 v 由系统自动管理</li><li>key 表示作为索引的键。1 或 -1表示排序模式，1为升序，1为降序</li><li>name 表示索引的名字，默认生成名称的规则是作为<code>索引的字段_排序模式</code></li><li>ns 表示 namespace 命名空间，由<code>数据库名称.集合名称</code>组成</li></ul><h3 id="单键索引"><a href="#单键索引" class="headerlink" title="单键索引"></a>单键索引</h3><p>最普通的索引，不会自动创建<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 x 字段创建升序索引</span></span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.createIndex</span>(&#123;x:<span class="number">1</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"createdCollectionAutomatically"</span> : false,</span><br><span class="line">        <span class="string">"numIndexesBefore"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"numIndexesAfter"</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59658e56aaf42d1c98dd95a2"</span>), <span class="string">"x"</span> : <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.getIndexes</span>()</span><br><span class="line">[</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"v"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"key"</span> : &#123;</span><br><span class="line">                        <span class="string">"_id"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"name"</span> : <span class="string">"_id_"</span>,</span><br><span class="line">                <span class="string">"ns"</span> : <span class="string">"runoob.col_1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"v"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"key"</span> : &#123;</span><br><span class="line">                        <span class="string">"x"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"name"</span> : <span class="string">"x_1"</span>,</span><br><span class="line">                <span class="string">"ns"</span> : <span class="string">"runoob.col_1"</span></span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h3><p>单键索引的值为一个单一的值，多键索引的值有多个数据（如数组）<br>如果mongoDB中插入数组类型的多键数据，索引是<strong>自动建立</strong>的，无需刻意指定<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.insert</span>(&#123;z:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59658e56aaf42d1c98dd95a2"</span>), <span class="string">"x"</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965923eaaf42d1c98dd95a3"</span>), <span class="string">"y"</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59659828aaf42d1c98dd95a4"</span>), <span class="string">"z"</span> : [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ] &#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_1</span><span class="selector-class">.find</span>(&#123;z:<span class="number">3</span>&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59659828aaf42d1c98dd95a4"</span>), <span class="string">"z"</span> : [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ] &#125;</span><br></pre></td></tr></table></figure></p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>同时对多个字段创建索引<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col_2</span><span class="selector-class">.insert</span>(&#123;x:<span class="number">10</span>,y:<span class="number">20</span>,z:<span class="number">30</span>&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_2</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59659a57aaf42d1c98dd95a5"</span>), <span class="string">"x"</span> : <span class="number">10</span>, <span class="string">"y"</span> : <span class="number">20</span>, <span class="string">"z"</span> : <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_2</span><span class="selector-class">.createIndex</span>(&#123;x:<span class="number">1</span>,y:<span class="number">1</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"createdCollectionAutomatically"</span> : false,</span><br><span class="line">        <span class="string">"numIndexesBefore"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"numIndexesAfter"</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_2</span><span class="selector-class">.getIndexes</span>()</span><br><span class="line">[</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"v"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"key"</span> : &#123;</span><br><span class="line">                        <span class="string">"_id"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"name"</span> : <span class="string">"_id_"</span>,</span><br><span class="line">                <span class="string">"ns"</span> : <span class="string">"runoob.col_2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"v"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"key"</span> : &#123;</span><br><span class="line">                        <span class="string">"x"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"y"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"name"</span> : <span class="string">"x_1_y_1"</span>,</span><br><span class="line">                <span class="string">"ns"</span> : <span class="string">"runoob.col_2"</span></span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h3><p>又称 TTL（Time To Live，生存时间）索引，即在一段时间后会过期的索引（如登录信息、日志等）<br>过期后的索引会连同文档一起删除<br>expireAfterSeconds：指定一个以秒为单位的数值，设定集合的生存时间。</p><p>注意：</p><ul><li>存储在过期索引字段的值必须是指定的时间类型（必须是 ISODate 或 ISODate 数组，不能使用时间戳，否则不能被自动删除）</li><li>如果指定了 ISODate 数组，则按照最小的时间进行删除</li><li>过期索引不能是复合索引（不能指定两个过期时间）</li><li>删除时间存在些许误差（1 分钟左右）<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.col_3</span><span class="selector-class">.insert</span>(&#123;x:new Date()&#125;)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_3</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"59659f3baaf42d1c98dd95a7"</span>), <span class="string">"x"</span> : ISODate(<span class="string">"2017-07-12T04:02:03.835Z"</span>) &#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_3</span><span class="selector-class">.createIndex</span>(&#123;x:<span class="number">1</span>&#125;,&#123;expireAfterSeconds:<span class="number">10</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"createdCollectionAutomatically"</span> : false,</span><br><span class="line">        <span class="string">"numIndexesBefore"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"numIndexesAfter"</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_3</span><span class="selector-class">.getIndexes</span>()</span><br><span class="line">[</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"v"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"key"</span> : &#123;</span><br><span class="line">                        <span class="string">"_id"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"name"</span> : <span class="string">"_id_"</span>,</span><br><span class="line">                <span class="string">"ns"</span> : <span class="string">"runoob.col_3"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"v"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"key"</span> : &#123;</span><br><span class="line">                        <span class="string">"x"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"name"</span> : <span class="string">"x_1"</span>,</span><br><span class="line">                <span class="string">"ns"</span> : <span class="string">"runoob.col_3"</span>,</span><br><span class="line">                <span class="string">"expireAfterSeconds"</span> : <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&gt; db<span class="selector-class">.col_3</span><span class="selector-class">.find</span>()</span><br><span class="line"><span class="comment">// 无返回</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>场景：全网站关键词搜索<br>key-value 中，key 此时为 <code>$**</code>（也可以是具体某 key），value 此时为一个固定的字符串（如 <code>text</code>）<br>全文索引相似度，与 sort 函数一起使用效果更好<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.col_7.find(&#123;</span><br><span class="line">    $text: &#123;</span><br><span class="line">        $search: <span class="string">"aa bb"</span></span><br><span class="line">    &#125;&#125;, &#123;</span><br><span class="line">    score: &#123;</span><br><span class="line">        $meta: <span class="string">"textScore"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).sort(&#123;</span><br><span class="line">    score: &#123;</span><br><span class="line">        $meta: <span class="string">"textScore"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>注意：</p><ul><li>每个集合只能创建一个全文索引</li><li>MongoDB 从 2.4 版本开始支持全文检索，从 3.2 版本开始支持中文</li><li>（好像）只能对整个单词查询，不能对单词的截取部分查询</li><li>关键词之间的空格表示<code>或</code></li><li>关键词之前的 - 表示<code>非</code></li><li>关键词加引号表示<code>与</code> （需用 \ 转义）<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col_7.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa84aaf42d1c98dd95b0"</span>), <span class="string">"title"</span> : <span class="string">"aa bb cc"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa8faaf42d1c98dd95b1"</span>), <span class="string">"title"</span> : <span class="string">"abc def"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aedfaaf42d1c98dd95b2"</span>), <span class="string">"title"</span> : <span class="string">"aa bb"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.createIndex(&#123;<span class="string">"title"</span>: <span class="string">"text"</span>&#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.find(&#123;$text:&#123;$search:<span class="string">"aa"</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa84aaf42d1c98dd95b0"</span>), <span class="string">"title"</span> : <span class="string">"aa bb cc"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aedfaaf42d1c98dd95b2"</span>), <span class="string">"title"</span> : <span class="string">"aa bb"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.find(&#123;$text:&#123;$search:<span class="string">"aa cc"</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa84aaf42d1c98dd95b0"</span>), <span class="string">"title"</span> : <span class="string">"aa bb cc"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aedfaaf42d1c98dd95b2"</span>), <span class="string">"title"</span> : <span class="string">"aa bb"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.find(&#123;$text:&#123;$search:<span class="string">"\"</span>aa\<span class="string">" \"</span>cc\<span class="string">""</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa84aaf42d1c98dd95b0"</span>), <span class="string">"title"</span> : <span class="string">"aa bb cc"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.find(&#123;$text:&#123;$search:<span class="string">"aa bb"</span>&#125;&#125;,&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;).sort(&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aedfaaf42d1c98dd95b2"</span>), <span class="string">"title"</span> : <span class="string">"aa bb"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span>, <span class="string">"score"</span> : <span class="number">1.5</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa84aaf42d1c98dd95b0"</span>), <span class="string">"title"</span> : <span class="string">"aa bb cc"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span>, <span class="string">"score"</span> : <span class="number">1.3333333333333333</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; db.col_7.dropIndexes()</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.createIndex(&#123;<span class="string">"author"</span>: <span class="string">"text"</span>&#125;))</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.find(&#123;$text:&#123;$search:<span class="string">"小明"</span>&#125;&#125;)&#125;)</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">&gt; db.col_7.find(&#123;$text:&#123;$search:<span class="string">"白小明"</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa84aaf42d1c98dd95b0"</span>), <span class="string">"title"</span> : <span class="string">"aa bb cc"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aa8faaf42d1c98dd95b1"</span>), <span class="string">"title"</span> : <span class="string">"abc def"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5965aedfaaf42d1c98dd95b2"</span>), <span class="string">"title"</span> : <span class="string">"aa bb"</span>, <span class="string">"author"</span> : <span class="string">"白小明"</span>, <span class="string">"article"</span> : <span class="string">"这是白小明的一篇文章，标题《aa bb cc》"</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="地理位置索引"><a href="#地理位置索引" class="headerlink" title="地理位置索引"></a>地理位置索引</h3><p>查看最近的点<br>在此不介绍,想了解更多请<a href="https://docs.mongodb.com/manual/core/2dsphere/" target="_blank" rel="noopener">点击这里</a></p><h1 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB - 聚合"></a>MongoDB - 聚合</h1><p>分组计算<br>MongoDB 中聚合主要用于处理数据(如平均值,求和等)，并返回计算后的数据结果。类似sql语句中的 count(*)。</p><h2 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_name</span><span class="selector-class">.aggregate</span>(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure><p>下表展示了一些聚合的表达式:</p><p><img src="//upload-images.jianshu.io/upload_images/5832745-8a6d608934b86d65.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/740/format/webp" alt=""></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>计算每个作者所写的文章数</strong></p><p>在下面的例子中，我们通过字段by_user字段对数据进行分组，并计算by_user字段相同值的总和。</p><p>集合中的数据如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"_id"</span> : ObjectId(<span class="string">"5963b992a812aa05b9d2e765"</span>),</span><br><span class="line">        <span class="attr">"title"</span> : <span class="string">"MongoDB Overview"</span>,</span><br><span class="line">        <span class="attr">"description"</span> : <span class="string">"MongoDB is no sql database"</span>,</span><br><span class="line">        <span class="attr">"by_user"</span> : <span class="string">"runoob.com"</span>,</span><br><span class="line">        <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">        <span class="attr">"tags"</span> : [</span><br><span class="line">                <span class="string">"mongodb"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"likes"</span> : <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"_id"</span> : ObjectId(<span class="string">"5963b9aaa812aa05b9d2e766"</span>),</span><br><span class="line">        <span class="attr">"title"</span> : <span class="string">"NoSQL Overview"</span>,</span><br><span class="line">        <span class="attr">"description"</span> : <span class="string">"No sql database is very fast"</span>,</span><br><span class="line">        <span class="attr">"by_user"</span> : <span class="string">"runoob.com"</span>,</span><br><span class="line">        <span class="attr">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">        <span class="attr">"tags"</span> : [</span><br><span class="line">                <span class="string">"mongodb"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"likes"</span> : <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"_id"</span> : ObjectId(<span class="string">"5963b9bba812aa05b9d2e767"</span>),</span><br><span class="line">        <span class="attr">"title"</span> : <span class="string">"Neo4j Overview"</span>,</span><br><span class="line">        <span class="attr">"description"</span> : <span class="string">"Neo4j is no sql database"</span>,</span><br><span class="line">        <span class="attr">"by_user"</span> : <span class="string">"Neo4j"</span>,</span><br><span class="line">        <span class="attr">"url"</span> : <span class="string">"http://www.neo4j.com"</span>,</span><br><span class="line">        <span class="attr">"tags"</span> : [</span><br><span class="line">                <span class="string">"neo4j"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"likes"</span> : <span class="number">750</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用aggregate()计算结果如下：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.col_1.aggregate([&#123;</span><br><span class="line">    $<span class="built_in">group</span>: &#123;</span><br><span class="line">        _id: <span class="string">"$by_user"</span>,</span><br><span class="line">        num_tutorial: &#123;</span><br><span class="line">            $<span class="built_in">sum</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"Neo4j"</span>, <span class="string">"num_tutorial"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"runoob.com"</span>, <span class="string">"num_tutorial"</span> : <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上实例类似sql语句</span></span><br><span class="line"><span class="keyword">select</span> by_user, <span class="built_in">count</span>(*) <span class="keyword">from</span> col_1 <span class="built_in">group</span> <span class="keyword">by</span> by_user</span><br></pre></td></tr></table></figure></p><h2 id="聚合管道"><a href="#聚合管道" class="headerlink" title="聚合管道"></a>聚合管道</h2><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p><p>MongoDB 的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p><p>聚合管道常用的几个操作：</p><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><strong>$project 实例</strong></p><p>0 为不显示，1为显示，默认情况下 _id 字段是 1<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.articles.aggregate(&#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">        _id: <span class="number">0</span>,</span><br><span class="line">        title: <span class="number">1</span>,</span><br><span class="line">        by_user: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> // 返回</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"MongoDB Overview"</span>, <span class="string">"by_user"</span> : <span class="string">"runoob.com"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"NoSQL Overview"</span>, <span class="string">"by_user"</span> : <span class="string">"runoob.com"</span> &#125;</span><br><span class="line">&#123; <span class="string">"title"</span> : <span class="string">"Neo4j Overview"</span>, <span class="string">"by_user"</span> : <span class="string">"Neo4j"</span> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>$match 实例</strong></p><p>$match 用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.articles.aggregate([</span><br><span class="line">    &#123; $match: &#123; score: &#123; $gt: <span class="number">70</span>, $lte: <span class="number">90</span> &#125; &#125; &#125;,</span><br><span class="line">    &#123; $group: &#123; _id: null, count: &#123; $sum: <span class="number">1</span> &#125; &#125; &#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"> // 返回</span><br><span class="line">&#123; <span class="string">"_id"</span> : null, <span class="string">"count"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>$skip 实例</strong></p><p>经过 $skip 管道操作符处理后，前2个文档被”过滤”掉。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.col_1</span><span class="selector-class">.aggregate</span>(&#123; <span class="variable">$skip</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure></p><h1 id="MongoDB-复制"><a href="#MongoDB-复制" class="headerlink" title="MongoDB - 复制"></a>MongoDB - 复制</h1><p>MongoDB 复制（副本集）是==将数据同步在多个服务器==的过程。</p><p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p><p>特点：</p><ul><li>保障数据的安全性</li><li>数据高可用性 (24*7)</li><li>灾难恢复，复制允许您从硬件故障和服务中断中恢复数据。</li><li>无需停机维护（如备份，重建索引，压缩）</li><li>分布式读取数据</li><li>N 个节点的集群</li><li>任何节点可作为主节点</li><li>所有写入操作都在主节点上</li><li>自动故障转移</li><li>自动恢复</li></ul><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>mongodb 的复制至少需要两个节点。</p><ul><li>其中一个是==主节点==，负责处理客户端请求，</li><li>其余的都是==从节点==，负责复制主节点上的数据。</li></ul><p>mongodb各个节点常见的搭配方式为：一主一从、一主多从。</p><p>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p><p><img src="//upload-images.jianshu.io/upload_images/5832745-e9d69c889fe53ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt=""></p><h2 id="复制设置"><a href="#复制设置" class="headerlink" title="复制设置"></a>复制设置</h2><ol><li>关闭正在运行的MongoDB服务器。</li></ol><p>现在我们通过指定 –replSet 选项来启动mongoDB<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mongod </span><span class="built_in">--port</span> <span class="string">"PORT"</span> <span class="built_in">--dbpath</span> <span class="string">"YOUR_DB_DATA_PATH"</span> <span class="built_in">--replSet</span> <span class="string">"REPLICA_SET_INSTANCE_NAME"</span></span><br></pre></td></tr></table></figure></p><p>实例：</p><p>下面实例会启动一个名为rs0的MongoDB实例，其端口号为27017。</p><p>启动后打开命令提示框并连接上mongoDB服务。</p><p>在Mongo客户端使用命令rs.initiate()来启动一个新的副本集。</p><p>我们可以使用rs.conf()来查看副本集的配置</p><p>查看副本集状态使用 rs.status() 命令<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mongod </span><span class="built_in">--port</span> <span class="string">27017 </span><span class="built_in">--dbpath</span> <span class="string">"D:\set up\mongodb\data"</span> <span class="built_in">--replSet</span> <span class="string">rs0</span></span><br></pre></td></tr></table></figure></p><h2 id="副本集添加成员"><a href="#副本集添加成员" class="headerlink" title="副本集添加成员"></a>副本集添加成员</h2><p>添加副本集的成员，我们需要使用多条服务器来启动mongo服务。</p><p>进入Mongo客户端，并使用rs.add()方法来添加副本集的成员。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rs</span><span class="selector-class">.add</span>(<span class="selector-tag">HOST_NAME</span><span class="selector-pseudo">:PORT)</span></span><br></pre></td></tr></table></figure></p><p>实例：</p><p>假设你已经启动了一个名为 mongod1.net，端口号为27017的Mongo服务。</p><p>在客户端命令窗口使用rs.add() 命令将其添加到副本集中，命令如下所示：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rs</span><span class="selector-class">.add</span>("<span class="selector-tag">mongod1</span><span class="selector-class">.net</span><span class="selector-pseudo">:27017")</span></span><br></pre></td></tr></table></figure></p><p>MongoDB 中你只能通过主节点将Mongo服务添加到副本集中， 判断当前运行的Mongo服务是否为主节点可以使用命令<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.isMaster</span>()</span><br></pre></td></tr></table></figure></p><p>MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。</p><h1 id="MongoDB-分片"><a href="#MongoDB-分片" class="headerlink" title="MongoDB - 分片"></a>MongoDB - 分片</h1><p>当MongoDB存储海量的数据时，==一台机器可能不足以存储数据==，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p><p>为什么使用分片？</p><ul><li>复制所有的写入操作到主节点</li><li>延迟的敏感数据会在主节点查询</li><li>单个副本集限制在12个节点</li><li>当请求量巨大时会出现内存不足。</li><li>本地磁盘不足</li><li>垂直扩展价格昂贵</li></ul><h2 id="分片集群结构"><a href="#分片集群结构" class="headerlink" title="分片集群结构"></a>分片集群结构</h2><p><img src="//upload-images.jianshu.io/upload_images/5832745-d9664d2b1c06bbae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt=""></p><p>三个主要组件：</p><ul><li>Shard: 用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</li><li>Config Server: mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。</li><li>Query Routers: 前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</li></ul><h1 id="MongoDB-监控"><a href="#MongoDB-监控" class="headerlink" title="MongoDB - 监控"></a>MongoDB - 监控</h1><p>监控可以了解 MongoDB 的==运行情况==及==性能==</p><p>MongoDB中提供了 mongostat 和 mongotop 两个命令来监控MongoDB的运行情况。</p><h2 id="mongostat"><a href="#mongostat" class="headerlink" title="mongostat"></a>mongostat</h2><p>它会间隔固定时间获取 mongodb 的当前运行状态，并输出。</p><p>如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用 mongostat 来查看 mongo 的状态。</p><pre><code>mongostat</code></pre><p><img src="//upload-images.jianshu.io/upload_images/5832745-56bf2bffa5a97ef4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/973/format/webp" alt=""></p><h2 id="mongotop"><a href="#mongotop" class="headerlink" title="mongotop"></a>mongotop</h2><p>mongotop用来跟踪MongoDB的实例，提供每个集合的统计数据。默认情况下，mongotop每一秒刷新一次。</p><pre><code>mongotop</code></pre><p><img src="//upload-images.jianshu.io/upload_images/5832745-c423bb3678ba4d12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/661/format/webp" alt=""></p><p>输出结果字段说明：</p><ul><li>ns：包含数据库命名空间，后者结合了数据库名称和集合。</li><li>db：包含数据库的名称。名为 . 的数据库针对全局锁定，而非特定数据库。</li><li>total：mongod花费的时间工作在这个命名空间提供总额。</li><li>read：提供了大量的时间，这mongod花费在执行读操作，在此命名空间。</li><li>write：提供这个命名空间进行写操作，这mongod花了大量的时间。</li></ul><p>等待的时间长度，以秒为单位，默认 1s</p><pre><code>mongotop 10</code></pre><p>报告每个数据库的<strong>锁</strong>的使用</p><pre><code>mongotop --locks</code></pre><h1 id="MongoDB-备份与恢复"><a href="#MongoDB-备份与恢复" class="headerlink" title="MongoDB - 备份与恢复"></a>MongoDB - 备份与恢复</h1><h2 id="mongodump"><a href="#mongodump" class="headerlink" title="mongodump"></a>mongodump</h2><p>在Mongodb中我们使用 <code>mongodump</code> 命令来备份MongoDB数据。</p><p>该命令可以导出所有数据到指定目录中。</p><p>mongodump命令可以通过参数指定导出的数据量级转存的服务器。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mongodump -h dbhost -d dbname -o dbdirectory</span></span><br></pre></td></tr></table></figure></p><p>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：需要备份的数据库实例，例如：test<br>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>备份 mongodb_study 数据库中的所有集合到 E:\MongoDB\dump<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mongodump</span> <span class="selector-tag">-h</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">-d</span> <span class="selector-tag">mongodb_study</span> <span class="selector-tag">-o</span> <span class="selector-tag">E</span>:\<span class="selector-tag">MongoDB</span>\<span class="selector-tag">dump</span></span><br></pre></td></tr></table></figure></p><p>不带任何参数，即在当前目录下备份所有数据库实例</p><pre><code>mongodump</code></pre><p>备份所有MongoDB数据<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mongodump <span class="params">--host</span> HOST_NAME <span class="params">--port</span> PORT_NUMBER</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 如</span><br><span class="line">mongodump <span class="params">--host</span> w3cschool.cc <span class="params">--port</span> 27017</span><br></pre></td></tr></table></figure></p><p>备份指定数据库的集合<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mongodump <span class="params">--collection</span> COLLECTION_NAME <span class="params">--db</span> DB_NAME</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 如</span><br><span class="line">mongodump <span class="params">--collection</span> mycol <span class="params">--db</span> test</span><br></pre></td></tr></table></figure></p><h2 id="mongorestore"><a href="#mongorestore" class="headerlink" title="mongorestore"></a>mongorestore</h2><p>在Mongodb中我们使用 <code>mongorestore</code> 命令来恢复MongoDB数据。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h <span class="tag">&lt;<span class="name">hostname</span>&gt;</span><span class="tag">&lt;<span class="name">:port</span>&gt;</span> -d dbname <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>–host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br>–path：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 <path></path> 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：指定备份的目录，你不能同时指定 <path></path> 和 –dir 选项。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>恢复存放在 E:\MongoDB\dump 中的数据库 mongodb_study，恢复前后的数据库名不必相同<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h localhost /db mongodb_study /dir E:<span class="symbol">\M</span>ongoDB<span class="symbol">\d</span>ump<span class="symbol">\m</span>ongodb_study</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Navicat Premium 12.1.8.0安装与激活</title>
      <link href="/2018/11/06/Navicat-Premium-12-1-8-0%E5%AE%89%E8%A3%85%E4%B8%8E%E6%BF%80%E6%B4%BB/"/>
      <url>/2018/11/06/Navicat-Premium-12-1-8-0%E5%AE%89%E8%A3%85%E4%B8%8E%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>前阵子升级了Navicat Premium到12.1.8，支持MongoDB了，再也不要用Robo 3T了。</p><p>顺便按照网上教程破解了下，比较正版要9999RMB，用不起。</p><p>破解亲测有效。<a href="https://www.jianshu.com/p/5f693b4c9468?mType=Group" title="点这里查看教程" target="_blank" rel="noopener">点这里查看教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Navicat Premium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再有人问你Java内存模型是什么,就把这篇文章发给他</title>
      <link href="/2018/11/01/%E5%86%8D%E6%9C%89%E4%BA%BA%E9%97%AE%E4%BD%A0Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E5%B0%B1%E6%8A%8A%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%8F%91%E7%BB%99%E4%BB%96/"/>
      <url>/2018/11/01/%E5%86%8D%E6%9C%89%E4%BA%BA%E9%97%AE%E4%BD%A0Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E5%B0%B1%E6%8A%8A%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%8F%91%E7%BB%99%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>前几天，发了一篇文章，介绍了一下<a href="/2018/11/01/JVM内存结构-VS-Java内存模型-VS-Java对象模型/">JVM内存结构 VS Java内存模型 VS Java对象模型</a>。有很多小伙伴反馈希望可以深入的讲解下每个知识点。Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。</p><p>网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。</p><p>本文中，有很多定义和说法，都是笔者自己理解后定义出来的。希望能够让读者可以对Java内存模型有更加清晰的认识。当然，如有偏颇，欢迎指正。</p><h2 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p><p><strong>内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</strong></p><h3 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p><p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p><blockquote><p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p></blockquote><p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p><p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。</p><p>那么，程序的执行过程就变成了：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><blockquote><p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p></blockquote><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p><p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p><p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>那么，在有了多级缓存之后，程序的执行就变成了：</p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><blockquote><p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p></blockquote><p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><blockquote><p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p><p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p><p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p><p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p></blockquote><p>下图为一个单CPU双核的缓存结构。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/12rwfdwqf3f3.png" alt=""></p><p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong>，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><blockquote><p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p><p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p><p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p><p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p></blockquote><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/h3w4gqt4hqg.png" alt=""></p><h3 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题</strong>。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化</strong>。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong>。</p><p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p><blockquote><p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p></blockquote><h2 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h2><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p><p>其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p><p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p><p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p><p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h2 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h2><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障</strong>。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p><h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p><p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: JavaTM Memory Model and Thread Specification</a> 描述。感兴趣的可以参看下这份PDF文档（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）</a></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/245qhtnerdq34th.png" alt=""></p><p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><p><strong>所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</strong></p><h2 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h2><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在<a href="https://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">synchronized的实现原理</a>文章中，介绍过，这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p><p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像<code>synchronized</code>关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用<code>synchronized</code>的原因。</p><p>但是<code>synchronized</code>是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。</p><p>可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/gtarcoder/p/5295281.html" target="_blank" rel="noopener">cpu缓存与多线程</a><br><a href="http://valleylord.github.io/post/201606-memory-model/" target="_blank" rel="noopener">浅析内存模型</a><br><a href="https://ljalphabeta.gitbooks.io/a-primer-on-memory-consistency-and-cache-coherenc/content/%E7%AC%AC%E4%B8%80%E7%AB%A0-consistency.html" target="_blank" rel="noopener">内存模型 和 缓存一致性</a><br><a href="https://blog.csdn.net/eff666/article/details/66473088" target="_blank" rel="noopener">并发编程——原子性，可见性和有序性</a><br><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机》</a></p><div class="note info"><p>作者：Hollis<br>出处：<a href="https://www.hollischuang.com" target="_blank" rel="noopener">https://www.hollischuang.com</a></p></div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Java内存模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM内存结构 VS Java内存模型 VS Java对象模型</title>
      <link href="/2018/11/01/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-VS-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-VS-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/11/01/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-VS-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-VS-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。不信的话，你去网上搜索Java内存模型，还会有很多文章的内容其实介绍的是JVM内存结构。</p><p>首先，这三个概念是完全不同的三个概念。<strong>本文主要对这三个概念加以区分以及简单介绍。其中每一个知识点都可以单独写一篇文章，本文并不会深入介绍，感兴趣的朋友可以加入我的知识星球和球友们共同学习。</strong></p><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">Java虚拟机规范（Java SE 8）</a>》中描述了JVM运行时内存区域结构如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/QQ20180624-150918.png" alt=""></p><p>各个区域的功能不是本文重点，就不在这里详细介绍了。这里简单提几个需要特别注意的点：</p><p>1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p><p>2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p><p>3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p><p>4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p><p>5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p><p>6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p><p>如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所为。</p><p>在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。</p><p>Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: Java Memory Model and Thread Specification</a>中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p><p>那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/11.png" alt=""></p><p>在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。</p><h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p><p>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20170615230126453.jpg?x-oss-process=style/ys30" alt=""></p><p>这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。</p><p>JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。</p><p>关于这三部分内容，本文并未分别展开，因为涉及到的知识点实在太多，如果读者感兴趣，可以自行学习。</p><div class="note info"><p>作者：Hollis<br>出处：<a href="https://www.hollischuang.com" target="_blank" rel="noopener">https://www.hollischuang.com</a></p></div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM内存结构 </tag>
            
            <tag> Java内存模型 </tag>
            
            <tag> Java对象模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开发高性能的MongoDB应用-浅谈MongoDB性能优化</title>
      <link href="/2018/10/31/%E5%BC%80%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84MongoDB%E5%BA%94%E7%94%A8-%E6%B5%85%E8%B0%88MongoDB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/10/31/%E5%BC%80%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84MongoDB%E5%BA%94%E7%94%A8-%E6%B5%85%E8%B0%88MongoDB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="1-、为什么选择MongoDB？"><a href="#1-、为什么选择MongoDB？" class="headerlink" title="1 、为什么选择MongoDB？"></a>1 、为什么选择MongoDB？</h2><h3 id="1-性能"><a href="#1-性能" class="headerlink" title="1.性能"></a>1.性能</h3><p>在大数据时代中，大数据量的处理已经成了考量一个数据库最重要的原因之一。而MongoDB的一个主要目标就是尽可能的让数据库保持卓越的性能，这很大程度地决定了MongoDB的设计。在一个以传统机械硬盘为主导的年代，硬盘很可能会成为性能的短板，而MongoDB选择了最大程度而利用内存资源用作缓存来换取卓越的性能，并且会自动选择速度最快的索引来进行查询。MongoDB尽可能精简数据库，将尽可能多的操作交给客户端，这种方式也是MongoDB能够保持卓越性能的原因之一。</p><h3 id="2-扩展"><a href="#2-扩展" class="headerlink" title="2.扩展"></a>2.扩展</h3><p>现在互联网的数据量已经从过去的MB、GB变为了现在的TB级别，单一的数据库显然已经无法承受，扩展性成为重要的话题，然而现在的开发人员常常在选择扩展方式的时候犯了难，到底是选择横向扩展还是纵向扩展呢？</p><p><strong>横向扩展</strong> <strong>（scale out）</strong>是以增加分区的方式将数据库拆分成不同的区块来分布到不同的机器中来，这样的优势是扩展成本低但管理困难。</p><p><strong>纵向扩展</strong> <strong>（scale up） </strong>纵向扩展与横向扩展不同的是他会将原本的服务器进行升级，让其拥有更强大的计算能力。这样的优势是易于管理无需考虑扩展带来的众多问题，但缺点也显而易见，那就是成本高。一台大型机的价格往往非常昂贵，并且这样的升级在数据达到极限时，可能就找不到计算能力更为强大的机器了。</p><p><strong>而MongoDB选择的是更为经济的横向扩展，他可以很容易的将数据拆分至不同的服务器中。</strong>而且在获取数据时开发者也无需考虑多服务器带来的问题，MongoDB可以将开发者的请求自动路由到正确的服务器中，让开发者脱离横向扩展带来的弊病，更专注于程序的开发上。</p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><p>MongoDB采用的是NoSQL的设计方式，可以更加灵活的操作数据。在进行传统的RDBMS中你一定遇到过几十行甚至上百行的复杂SQL语句，传统的RDBMS的SQL语句中包含着大量关联，子查询等语句，在增加复杂性的同时还让性能调优变得更加困难。MongoDB的<strong>面向文档（document-oriented）</strong>设计中采用更为灵活的文档来作为数据模型用来取代RDBMS中的行，面向文档的设计让开发人员获取数据的方式更加灵活，甚至于开发人员仅用一条语句即可查询复杂的嵌套关系，让开发人员不必为了获取数据而绞尽脑汁。</p><h2 id="2-、NoSQL对传统数据库设计思维的影响"><a href="#2-、NoSQL对传统数据库设计思维的影响" class="headerlink" title="2 、NoSQL对传统数据库设计思维的影响"></a>2 、NoSQL对传统数据库设计思维的影响</h2><h3 id="1-预设计模式与动态模式"><a href="#1-预设计模式与动态模式" class="headerlink" title="1.预设计模式与动态模式"></a>1.预设计模式与动态模式</h3><p>传统数据库设计思维中，项目的设计阶段需要对数据库表中的字段名称、字段类型、进行规定，如果尝试插入不符合设计的数据，数据库不会接受这条数据以保证数据的完整性。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">--</span>数据库字段<span class="selector-pseudo">:NAME</span>, <span class="selector-tag">SONGINSERT</span> <span class="selector-tag">INTO</span> <span class="selector-tag">T_INFO</span> <span class="selector-tag">VALUES</span>(<span class="string">'John'</span>,<span class="string">'Come Together'</span>);  <span class="selector-tag">--</span>成功<span class="selector-tag">INSERT</span> <span class="selector-tag">INTO</span> <span class="selector-tag">T_INFO</span> <span class="selector-tag">VALUES</span>(<span class="string">'小明'</span>, <span class="number">20</span>, <span class="string">'xiaoming@111.com'</span>);  <span class="selector-tag">--</span>失败</span><br></pre></td></tr></table></figure><p>NoSQL采用的是对集合（类似”表”）中的文档（类似于”行”）进行动态追加，在创建集合之初不会对数据类型进行限定，任何文档都可以追加到任何集合中去，例如我们可以将这样两条文档添加到一个集合中去：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span> : <span class="string">"John"</span>, <span class="attr">"song"</span> : <span class="string">"Come Together"</span>&#125;&#123;<span class="attr">"name"</span> : <span class="string">"小明"</span>,  <span class="attr">"age"</span>:<span class="string">"20"</span>, <span class="attr">"email"</span> : <span class="string">"xiaoming@111.com"</span>&#125;</span><br></pre></td></tr></table></figure><p>MongoDB中文档的格式类似于我们常见的JSON，由此可见，我们第一个拥有”name”、”song”两个字段，而第二个拥有”name”、”age”、”email”三个字段，这在预设计模式中的数据库是不可能插入成功的，但在MongoDB的动态模式是可以的，这样做的优势是我们不必为一些数量很少，但种类很多的字段单独设计一张表，可以将他们集中在单独一张表进行存储，但这样做的弊病也是显而易见的，我们在获取数据时需要对同一张表的不同文档进行区分，增加了开发上的代码量。所以在设计之初需要权衡动态模式的优劣来选择表中的数据类型。  </p><h3 id="2-范式化与反范式化"><a href="#2-范式化与反范式化" class="headerlink" title="2.范式化与反范式化"></a>2.范式化与反范式化</h3><p><strong>范式化（normalization）</strong> 是关系模型的发明者埃德加·科德于1970年提出这一概念，范式化会将数据分散到不同的表中，利用关系模型进行关联，由此带来的优点是，在后期进行修改时，不会影响到与其关联的数据，仅对自身修改即可完成。</p><p><strong>反范式化（denormalization）</strong> 是针对范式化提出的相反理念，反范式化会将当前文档的数据集中存放在本表中，而不会采用拆分的方式进行存储。</p><p><strong>范式化和反范式化之间不存在优劣的问题，范式化的好处是可以在我们写入、修改、删除时的提供更高性能，而反范式化可以提高我们在查询时的性能。</strong> 当然NoSQL中是不存在关联查询的，以此提高查询性能，但我们依旧可以以在表中存储关联表ID的方式进行范式化。但由此可见，NoSQL的理念中反范式化的地位是大于范式化的。</p><h2 id="3-、性能与用户量"><a href="#3-、性能与用户量" class="headerlink" title="3 、性能与用户量"></a>3 、性能与用户量</h2><p>“如何能让软件拥有更高的性能？”，我想这是一个大部分开发者都思考过的问题。性能往往决定了一个软件的质量，如果你开发的是一个互联网产品，那么你的产品性能将更加受到考验，因为你面对的是广大的 <strong>互联网用户</strong>，他们可不是那么有耐心的。严重点说，页面的加载速度每增加一秒也许都会使你失去一部分用户，也就是说，<strong>加载速度和用户量是成反比的</strong> 。那么用户能够接受的加载速度到底是多少呢？</p><p>　<img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/166c7a875b9ca442.webp" alt=""></p><p>如图，如果页面加载时间超过10s那么用户就会离开，如果1s–10s的话就需要有提示，但如果我们的页面没有提示的话需要多快的加载速度呢？是的，<strong>1s</strong> 。</p><p>当然，这是站在一个产品经理的角度来说的，但如果站在一个技术人员的角度来说呢？<strong>加载速度和用户量就是成正比的</strong>，你的用户数量越多需要处理的数据当然也就越多，加载速度当然也就越慢。这是一件很有趣的事，所以如果你的产品如果是一件激动人心的产品，那么作为技术人员你需要做的事就是<strong>让软件的性能和用户的数量同时增长，甚至性能增长要快于用户量的增长。</strong></p><p><strong>数据库性能对软件整体性能的影响是不言而喻的，那么，当我们使用MongoDB时改如何提高数据库性能呢？</strong></p><h2 id="4-、范式化与反范式化"><a href="#4-、范式化与反范式化" class="headerlink" title="4 、范式化与反范式化"></a>4 、范式化与反范式化</h2><p>在项目设计阶段，明确集合的用途是对性能调优非常重要的一步。</p><p>从性能优化的角度来看，集合的设计我们需要考虑的是<strong>集合中数据的常用操作</strong>，例如我们需要设计一个日志（log）集合，日志的查看频率不高，但写入频率却很高，那么我们就可以得到这个集合中常用的操作是<strong>更新（增删改）</strong>。如果我们要保存的是城市列表呢？显而易见，这个集合是一个查看频率很高，但写入频率很低的集合，那么常用的操作就是<strong>查询。</strong></p><p>对于频繁更新和频繁查询的集合，我们最需要关注的重点是他们的范式化程度，在上篇<strong>范式化与反范式化</strong>的介绍中我们了解到，范式化与反范式化的合理运用对于性能的提高至关重要。然而这种设计的使用非常灵活，假设现在我们需要存储一篇图书及其作者，在MongoDB中的关联就可以体现为以下几种形式：</p><h3 id="1-完全分离（范式化设计）"><a href="#1-完全分离（范式化设计）" class="headerlink" title="1.完全分离（范式化设计）"></a>1.完全分离（范式化设计）</h3><p><strong>示例1：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"_id"</span> : ObjectId(<span class="string">"5124b5d86041c7dca81917"</span>), </span><br><span class="line"><span class="string">"title"</span> : <span class="string">"如何使用MongoDB"</span>,</span><br><span class="line"><span class="string">"author"</span> : [</span><br><span class="line">ObjectId(<span class="string">"144b5d83041c7dca84416"</span>), </span><br><span class="line">            ObjectId(<span class="string">"144b5d83041c7dca84418"</span>), </span><br><span class="line">             ObjectId(<span class="string">"144b5d83041c7dca84420"</span>)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将<strong>作者(comment)</strong> 的id数组作为一个字段添加到了<strong>图书</strong>中去。这样的设计方式是在非关系型数据库中常用的，也就是我们所说的范式化设计。在MongoDB中我们将与主键没有直接关系的图书单独提取到另一个集合，用存储主键的方式进行关联查询。当我们要查询文章和评论时需要先查询到所需的文章，再从文章中获取评论id，最后用获得的完整的文章及其评论。在这种情况下查询性能显然是不理想的。但当某位作者的信息需要修改时，范式化的<strong>维护优势</strong>就凸显出来了，我们无需考虑此作者关联的图书，直接进行修改此作者的字段即可。</p><h3 id="2-完全内嵌（反范式化设计）"><a href="#2-完全内嵌（反范式化设计）" class="headerlink" title="2.完全内嵌（反范式化设计）"></a>2.完全内嵌（反范式化设计）</h3><p><strong>示例2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span>: ObjectId(<span class="string">"5124b5d86041c7dca81917"</span>),</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"如何使用MongoDB"</span>,</span><br><span class="line">    <span class="string">"author"</span>: [</span><br><span class="line">        &#123;　　　　</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"丁磊"</span>　　　　</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">40</span>,</span><br><span class="line">            　　　　<span class="string">"nationality"</span>: <span class="string">"china"</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">        &#123;　　　　</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"马云"</span>　　　　</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">49</span>,</span><br><span class="line">            　　　　<span class="string">"nationality"</span>: <span class="string">"china"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#123;　　　　</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"张召忠"</span>　　　　</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">59</span>,</span><br><span class="line">            　　　　<span class="string">"nationality"</span>: <span class="string">"china"</span>,</span><br><span class="line">             &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中我们将作者的字段完全嵌入到了图书中去，在查询的时候直接查询图书即可获得所对应作者的全部信息，但因一个作者可能有多本著作，当修改某位作者的信息时时，我们需要遍历所有图书以找到该作者，将其修改。</p><h3 id="3-部分内嵌（折中方案）"><a href="#3-部分内嵌（折中方案）" class="headerlink" title="3.部分内嵌（折中方案）"></a>3.部分内嵌（折中方案）</h3><p><strong><strong>示例3：</strong></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span>: ObjectId(<span class="string">"5124b5d86041c7dca81917"</span>),</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"如何使用MongoDB"</span>,</span><br><span class="line">    <span class="string">"author"</span>: [</span><br><span class="line">        &#123;　　　　</span><br><span class="line">            <span class="string">"_id"</span>: ObjectId(<span class="string">"144b5d83041c7dca84416"</span>),</span><br><span class="line">            　　　　<span class="string">"name"</span>: <span class="string">"丁磊"</span></span><br><span class="line">       &#125;,</span><br><span class="line">        &#123;　　　　</span><br><span class="line">            <span class="string">"_id"</span>: ObjectId(<span class="string">"144b5d83041c7dca84418"</span>),</span><br><span class="line">            　　　　<span class="string">"name"</span>: <span class="string">"马云"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;　　　　</span><br><span class="line">            <span class="string">"_id"</span>: ObjectId(<span class="string">"144b5d83041c7dca84420"</span>),</span><br><span class="line">            　　　　<span class="string">"name"</span>: <span class="string">"张召忠"</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们将作者字段中的最常用的一部分提取出来。当我们只需要获得图书和作者名时，无需再次进入作者集合进行查询，仅在图书集合查询即可获得。</p><p>这种方式是一种相对折中的方式，既保证了查询效率，也保证的更新效率。但这样的方式显然要比前两种较难以掌握，难点在于需要与<strong>实际业务</strong>进行结合来寻找合适的提取字段。如同示例3所述，名字显然不是一个经常修改的字段，这样的字段如果提取出来是没问题的，但如果提取出来的字段是一个经常修改的字段（比如age）的话，我们依旧在更新这个字段时需要大范围的寻找并依此进行更新。</p><p>在上面三个示例中，第一个示例的更新效率是最高的，但查询效率是最低的，而第二个示例的查询效率最高，但更新效率最低。所以在实际的工作中我们需要根据自己实际的需要来设计表中的字段，以获得最高的效率。</p><h2 id="5-、理解填充因子"><a href="#5-、理解填充因子" class="headerlink" title="5 、理解填充因子"></a>5 、理解填充因子</h2><h3 id="何为填充因子？"><a href="#何为填充因子？" class="headerlink" title="何为填充因子？"></a>何为填充因子？</h3><p><strong>填充因子（padding factor）</strong>是MongoDB为文档的扩展而预留的增长空间，因为MongoDB的文档是以顺序表的方式存储的，每个文档之间会非常紧凑，如图所示。</p><p>　　（注：图片出处：《MongoDB The Definitive Guide》）</p><p>　<img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/166c7a875b6a82a3.webp" alt=""></p><p>　　1.元素之间没有多余的可增长空间。</p><p>　<img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/166c7a875b7750f6.webp" alt=""></p><p>　　2.当我们对顺序表中某个元素的大小进行增长的时候，就会导致原来分配的空间不足，只能要求其向后移动。</p><p>　<img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/166c7a875b8027ec.webp" alt=""></p><p>　　3.当修改元素移动后，后续插入的文档都会提供一定的填充因子，以便于文档频繁的修改，如果没有不再有文档因增大而移动的话，后续插入的文档的填充因子会依此减小。 </p><p>填充因子的理解之所以重要，是因为文档的移动非常消耗性能，频繁的移动会大大增加系统的负担，在实际开发中最有可能会让文档体积变大的因素是数组，所以如果我们的文档会频繁修改并增大空间的话，则一定要充分考虑填充因子。</p><p>那么如果我们的文档是个常常会扩展的话，应该如何提高性能？</p><h3 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h3><h4 id="1-增加初始分配空间。在集合的属性中包含一个-usePowerOf2Sizes-属性，当这个选项为true时，系统会将后续-插入的文档，初始空间都分配为2的N次方。"><a href="#1-增加初始分配空间。在集合的属性中包含一个-usePowerOf2Sizes-属性，当这个选项为true时，系统会将后续-插入的文档，初始空间都分配为2的N次方。" class="headerlink" title="1.增加初始分配空间。在集合的属性中包含一个 usePowerOf2Sizes 属性，当这个选项为true时，系统会将后续**插入的文档，初始空间都分配为2的N次方。"></a>1.<strong>增加初始分配空间。在集合的属性中包含一个 </strong>usePowerOf2Sizes <strong>属性，当这个选项为</strong>true<strong>时，系统会将</strong>后续**插入的文档，初始空间都分配为2的N次方。</h4><p>这种分配机制适用于一个数据会频繁变更的集合使用，他会给每个文档留有更大的空间，但因此空间的分配不会像原来那样高效，如果你的集合在更新时不会频繁的出现移动现象，这种分配方式会导致写入速度相对变慢。</p><h4 id="2-我们可以利用数据强行将初始分配空间扩大。"><a href="#2-我们可以利用数据强行将初始分配空间扩大。" class="headerlink" title="2.我们可以利用数据强行将初始分配空间扩大。"></a>2.我们可以利用数据强行将初始分配空间扩大。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.book.insert(&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"MongoDB"</span>,</span><br><span class="line">    <span class="string">"publishing"</span>: <span class="string">"清华大学出版社"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"john"</span></span><br><span class="line">    <span class="string">"tags"</span>: []</span><br><span class="line">    <span class="string">"stuff"</span>: <span class="string">"ggggggggggggggggggggggggggggggggggggg               </span></span><br><span class="line"><span class="string">ggggggggggggggggggggggggggggggggggggg               </span></span><br><span class="line"><span class="string">ggggggggggggggggggggggggggggggggggggg"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>是的，这样看起来可能不太优雅…但有时却很有效！当我们对这个文档进行增长式修改时，只要将stuff字段删掉即可。当然，这个stuff字段随便你怎么起名，包括里边的填充字符当然也是可以随意添加的。　　</p><h2 id="6-、准确利用索引"><a href="#6-、准确利用索引" class="headerlink" title="6 、准确利用索引"></a>6 、准确利用索引</h2><p>索引对于一个数据库的影响相信大家一定了解，如果一个查询命令进入到数据库中后，查询优化器没有找到合适的索引，那么数据库会进行 <strong>全集合扫描</strong>(在RDBMS中也叫全表扫描)，全集合查询对于性能的影响是灾难性的。</p><p>没有索引的查询就如同在词典那毫无规律的海量词汇中获得某个你想要的词汇，但这个词典是没有目录的，只能通过逐页来查找。这样的查找可能会让你耗费几个小时的时间，但如果要求你查询词汇的频率如同用户访问的频率一样的话。。。嘿嘿，我相信你一定会大喊“老子不干了！”。显然计算机不会这样喊，它一直是一个勤勤恳恳的员工，不论多么苛刻的请求他都会完成。所以请通过索引善待你的计算机：D。</p><p>在MongoDB中索引的类型与RDBMS中大体一致，我们不做过多重复，我们来看一下在MongoDB中如何才能更高效的利用索引。</p><h3 id="6-1-索引越少越好"><a href="#6-1-索引越少越好" class="headerlink" title="6.1 索引越少越好"></a>6.1 索引越少越好</h3><p>索引可以极大地提高查询性能，那么索引是不是越多越好？答案是否定的，并且索引并非越多越好，而是<strong>越少越好</strong>。每当你建立一个索引时，系统会为你添加一个索引表，用于索引指定的列，然而当你对已建立索引的列进行插入或修改时，数据库则需要对原来的索引表进行重新排序，重新排序的过程非常消耗性能，但应对少量的索引压力并不是很大，但如果索引的数量较多的话对于性能的影响可想而知。所以在创建索引时需要谨慎建立索引，要把每个索引的功能都要发挥到极致，也就是说<strong>在可以满足索引需求的情况下，索引的数量越少越好</strong>。</p><p><strong>隐式索引</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立复合索引</span></span><br><span class="line">db.test.ensureIndex(&#123;<span class="string">"age"</span>: <span class="number">1</span>,<span class="string">"no"</span>: <span class="number">1</span>,<span class="string">"name"</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></p><p>我们在查询时可以迅速的将age,no字段进行排序，隐式索引指的是 <strong>如果我们想要排序的字段包含在已建立的复合索引中则无需重复建立索引</strong> 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   db.test.find().sort(<span class="string">"age"</span>: <span class="number">1</span>,<span class="string">"no"</span>: <span class="number">1</span>)</span><br><span class="line">db.test.find().sort(<span class="string">"age"</span>: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>如以上两个排序查询，均可使用上面的复合索引，而不需要重新建立索引。</p><p><strong>翻转索引</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//建立复合索引</span></span><br><span class="line">db.test.ensureIndex(&#123;<span class="string">"age"</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>翻转索引很好理解，就是我们在排序查询时无需考虑索引列的方向，例如这个例子中我们在查询时可以将排序条件写为”{‘age’: 0}”，依旧不会影响性能。</p><h3 id="6-2-索引列颗粒越小越好"><a href="#6-2-索引列颗粒越小越好" class="headerlink" title="6.2 索引列颗粒越小越好"></a>6.2 索引列颗粒越小越好</h3><p>什么叫颗粒越小越好？在索引列中每个数据的重复数量称为颗粒，也叫作索引的 <strong>基数</strong>。如果数据的颗粒过大，索引就无法发挥该有的性能。例如，我们拥有一个”age”列索引，如果在”age”列中，20岁占了50%，如果现在要查询一个20岁，名叫”Tom”的人，我们则需要在表的50%的数据中查询，索引的作用大大降低。所以，我们在建立索引时要尽量将数据颗粒小的列放在索引左侧，以保证索引发挥最大的作用。                 </p><div class="note info"><p>作者：吴纹羽<br>出处：<a href="cnblogs.com/mokafamily">cnblogs.com/mokafamily</a></p></div>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows解除iis占用80端口</title>
      <link href="/2018/10/26/windows%E8%A7%A3%E9%99%A4iis%E5%8D%A0%E7%94%A880%E7%AB%AF%E5%8F%A3/"/>
      <url>/2018/10/26/windows%E8%A7%A3%E9%99%A4iis%E5%8D%A0%E7%94%A880%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="方法一-卸载iis"><a href="#方法一-卸载iis" class="headerlink" title="方法一 卸载iis"></a>方法一 卸载iis</h2><p>我的电脑-添加或删除组件-添加或删除Windows组件-IIS信息服务<br>去掉 IIS前面的勾然后“下一步”就可以了。</p><h2 id="方法二-改iis的端口"><a href="#方法二-改iis的端口" class="headerlink" title="方法二 改iis的端口"></a>方法二 改iis的端口</h2><p>我的电脑-右击-管理-iis管理-Default Web Site右击-编辑绑定</p><h2 id="方法三-停止iis服务"><a href="#方法三-停止iis服务" class="headerlink" title="方法三 停止iis服务"></a>方法三 停止iis服务</h2><ul><li>在管理员命令行运行<code>iisreset/stop</code>  开启使用<code>iisreset/stop</code>即可</li><li>服务里关闭World Wide Web Publishing Service</li></ul><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><p>修改使用的软件的端口</p><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><p>在管理员命令行运行<code>netstat -aon|findstr 80</code>，然后tskill 占用的端口</p>]]></content>
      
      
      <categories>
          
          <category> IIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 80 </tag>
            
            <tag> IIS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx快速入门</title>
      <link href="/2018/10/25/Nginx%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2018/10/25/Nginx%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>假设您已经学习过并已经安装好了nginx服务器。 如果没有，请参阅安装nginx页面(<a href="http://www.yiibai.com/nginx/nginx-install.html" target="_blank" rel="noopener">http://www.yiibai.com/nginx/nginx-install.html</a> )。 本指南介绍如何启动和停止nginx，并重新加载其配置，解释配置文件的结构，并介绍如何设置nginx以提供静态内容，如何配置nginx作为代理服务器，以及如何将其连接到 一个FastCGI应用程序。</p><p>nginx有一个主进程和几个工作进程。 主进程的主要目的是读取和评估配置，并维护工作进程。 工作进程对请求进行实际处理。 nginx采用基于事件的模型和依赖于操作系统的机制来有效地在工作进程之间分配请求。 工作进程的数量可在配置文件中定义，并且可以针对给定的配置进行修改，或者自动调整到可用CPU内核的数量(请参阅<a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes" title="worker_processes" target="_blank" rel="noopener">worker_processes</a>)。</p><p>在配置文件中确定nginx及其模块的工作方式。 默认情况下，配置文件名为<code>nginx.conf</code>，并放在目录：<code>/usr/local/nginx/conf</code>, <code>/etc/nginx</code>, 或 <code>/usr/local/etc/nginx</code> 中。</p><p>在前面安装文章配置中，使用的安装配置目录是：<code>/usr/local/nginx/conf</code> 。所以可以在这个目录下找到这个配置文件。</p><h2 id="1-启动，停止和重新加载Nginx配置"><a href="#1-启动，停止和重新加载Nginx配置" class="headerlink" title="1. 启动，停止和重新加载Nginx配置"></a>1. 启动，停止和重新加载Nginx配置</h2><p>要启动nginx，请运行可执行文件。 当nginx启动后，可以通过使用<code>-s</code>参数调用可执行文件来控制它。 使用以下语法：</p><pre><code>nginx -s signal</code></pre><p>信号(<code>signal</code>)的值可能是以下之一：</p><ul><li><code>stop</code> - 快速关闭服务</li><li><code>quit</code> - 正常关闭服务</li><li><code>reload</code> - 重新加载配置文件</li><li><code>reopen</code> - 重新打开日志文件</li></ul><p>例如，要通过等待工作进程完成服务当前请求来停止<code>nginx</code>进程，可以执行以下命令：</p><pre><code>nginx -s quit</code></pre><blockquote><p>注：该命令应该在启动nginx的同一用户下执行。</p></blockquote><p>在将重新配置命令的命令发送到nginx或重新启动之前，配置文件中的更改将不会被应用。 要重新加载配置文件，请执行：</p><pre><code>nginx -s reload</code></pre><p>当主进程收到要重新加载配置的信号，它将检查新配置文件的语法有效性，并尝试应用其中提供的配置。 如果这是成功的，主进程将启动新的工作进程，并向旧的工作进程发送消息，请求它们关闭。 否则，主进程回滚更改，并继续使用旧配置。 老工作进程，接收关闭命令，停止接受新连接，并继续维护当前请求，直到所有这些请求得到维护。 之后，旧的工作进程退出。</p><p>还可以借助Unix工具(如kill utility)将信号发送到nginx进程。 在这种情况下，信号直接发送到具有给定进程ID的进程。 默认情况下，nginx主进程的进程ID写入目录<code>/usr/local/nginx/logs</code>或<code>/var/run</code>中的nginx.pid。 例如，如果主进程ID为<code>1628</code>，则发送QUIT信号导致nginx的正常关闭，请执行：</p><pre><code>kill -s QUIT 1628</code></pre><p>要获取所有运行的nginx进程的列表，可以使用<code>ps</code>命令，例如，以下列方式：</p><pre><code>ps -ax | grep nginx</code></pre><h2 id="2-配置文件的结构"><a href="#2-配置文件的结构" class="headerlink" title="2. 配置文件的结构"></a>2. 配置文件的结构</h2><p>nginx由配置文件中指定的指令控制的模块组成。 指令分为简单指令和块指令。 一个简单的指令由空格分隔的名称和参数组成，并以分号(<code>;</code>)结尾。 块指令具有与简单指令相同的结构，但不是以分号结尾，而是以大括号(<code>{</code>和<code>}</code>)包围的一组附加指令结束。 如果块指令可以在大括号内部有其他指令，则称为上下文(例如：<code>events</code>，<code>http</code>，<code>server</code>和<code>location</code>)。</p><p>配置文件中放置在任何上下文之外的伪指令都被认为是<strong>主上下文</strong>。 <code>events</code> 和<code>http</code>指令驻留在<strong>主上下文</strong>中，<code>server</code>在<code>http</code>中的，而<code>location</code>在<code>http</code>块中。</p><p><code>#</code>号之后的一行的部分被视为注释。</p><h2 id="3-提供静态内容服务-静态网站"><a href="#3-提供静态内容服务-静态网站" class="headerlink" title="3. 提供静态内容服务(静态网站)"></a>3. 提供静态内容服务(静态网站)</h2><p>一个重要的Web服务器任务是提供文件(如图像或静态HTML页面)。这里我们来学习如何实现一个示例，根据请求，文件将从不同的本地目录提供：<code>/data/www</code>(可能包含HTML文件)和/ <code>data/images</code>(包含图像)。这将需要编辑配置文件，并使用两个位置块在http块内设置服务器块。</p><p>首先，创建<code>/data/www</code>目录，并将一个包含任何文本内容的<code>index.html</code>文件放入其中，并创建<code>/data/images</code>目录并在其中放置一些图像。创建两个目录 -</p><pre><code>[root@localhost ~]# mkdir -p /data/www[root@localhost ~]# mkdir -p /data/images[root@localhost ~]#</code></pre><p>分别在上面创建的两个目录中放入两个文件：<code>/data/www/index.html</code> 和 <code>/data/images/logo.png</code>，<code>/data/www/index.html</code>文件的内容就一行，如下 -</p><pre><code>&lt;h2&gt; New Static WebSite Demo.&lt;/h2&gt;</code></pre><p>接下来，打开配置文件(<code>/usr/local/nginx/conf/nginx.conf</code>)。 默认的配置文件已经包含了服务器块的几个示例，大部分是注释掉的。 现在注释掉所有这样的块，并启动一个新的服务器块：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">   <span class="built_in"> server </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常，配置文件可以包括服务器监听的端口和服务器名称区分的几个<code>server</code>块。当nginx决定哪个服务器处理请求后，它会根据服务器块内部定义的<code>location</code>指令的参数测试请求头中指定的URI。</p><p>将以下<code>location</code>块添加到服务器(<code>server</code>)块：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">   <span class="built_in"> server </span>&#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /data/www;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该<code>location</code>块指定与请求中的URI相比较的“<code>/</code>”前缀。 对于匹配请求，URI将被添加到<code>root</code>指令中指定的路径(即<code>/data/www</code>)，以形成本地文件系统上所请求文件的路径。 如果有几个匹配的<code>location</code>块，nginx将选择具有最长前缀来匹配<code>location</code>块。 上面的<code>location</code>块提供最短的前缀长度为<code>1</code>，因此只有当所有其他<code>location</code>块不能提供匹配时，才会使用该块。</p><p>接下来，添加第二个<code>location</code>块：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">   <span class="built_in"> server </span>&#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /data/www;</span><br><span class="line">        &#125;</span><br><span class="line">        location /images/ &#123;</span><br><span class="line">            root /data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它将是以<code>/images/</code>(位置<code>/</code>也匹配这样的请求，但具有较短前缀，也就是“<code>/images/</code>”比“<code>/</code>”长)的请求来匹配。</p><p><code>server</code>块的最终配置应如下所示：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    <span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">        root</span> /data/www;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">location</span> <span class="title">/images</span>/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这已经是一个在标准端口<code>80</code>上侦听并且可以在本地机器上访问的服务器( <code>http://localhost/</code> )的工作配置。 响应以<code>/images/</code>开头的URI的请求，服务器将从<code>/data/images</code>目录发送文件。 例如，响应<code>http://localhost/images/logo.png</code>请求，nginx将发送服务上的<code>/data/images/logo.png</code>文件。 如果文件不存在，nginx将发送一个指示<code>404</code>错误的响应。 不以<code>/images/</code>开头的URI的请求将映射到<code>/data/www</code>目录。 例如，响应<code>http://localhost/about/example.html</code>请求时，nginx将发送<code>/data/www/about/example.html</code>文件。</p><p>要应用新配置，如果尚未启动nginx或者通过执行以下命令将重载信号发送到nginx的主进程：</p><pre><code>[root@localhost ~]# /usr/local/nginx/sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful[root@localhost ~]# /usr/local/nginx/sbin/nginx -s reload</code></pre><blockquote><p>如果错误或异常导致无法正常工作，可以尝试查看目录<code>/usr/local/nginx/logs</code>或<code>/var/log/nginx</code>中的<code>access.log</code>和<code>error.log</code>文件中查找原因。</p></blockquote><p>打开浏览器或使用CURL访问Nginx服务器如下所示 -</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/974100427_64766.png" alt=""></p><p>完整的<code>nginx.conf</code>文件配置内容如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment"># '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment"># '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 新服务(静态网站)</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /data/www;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /images/ &#123;</span><br><span class="line">            <span class="attribute">root</span> /data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-设置简单的代理服务器"><a href="#4-设置简单的代理服务器" class="headerlink" title="4. 设置简单的代理服务器"></a>4. 设置简单的代理服务器</h2><p>nginx的一个常见用途是将其设置为代理服务器，这意味着它可作为一个接收请求的服务器，将其传递给代理服务器，从代理服务器中检索响应，并将其发送给客户端。</p><p>我们将配置一个基本的代理服务器，它为来自本地目录的文件提供图像请求，并将所有其他请求发送到代理的服务器。 在此示例中，两个服务器将在单个<code>nginx</code>实例上定义。</p><p>首先，通过向nginx配置文件添加一个<code>server</code>块来定义代理服务器，其中包含以下内容：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">root</span> /data/up1;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这将是一个监听端口<code>8080</code>的简单服务器(以前，由于使用了标准端口<code>80</code>，所以没有指定<code>listen</code>指令)，并将所有请求映射到本地文件系统上的<code>/data/up1</code>目录。 创建此目录并将<code>index.html</code>文件放入其中。 请注意，<code>root</code>指令位于<code>server</code>块上下文中。 当选择用于服务请求的<code>location</code>块不包含自己的<code>root</code>指令时，将使用此<code>root</code>指令。</p><p>在上面创建的目录<code>/data/up1</code>中放入一个文件：<code>/data/www/demo.html</code>，文件的内容就一行，如下 -</p><pre><code>&lt;h2&gt;About proxy_pass Page at port 8080&lt;/h2&gt;</code></pre><p>接下来，使用上一节中的服务器配置进行修改，使其成为代理服务器配置。 在第一个位置块中，将<code>proxy_pass</code>指令与参数中指定的代理服务器的协议，名称和端口(在本例中为<code>http://localhost:8080</code>)：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    <span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">        proxy_pass</span> http://localhost:<span class="number">8080</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">location</span> <span class="title">/images</span>/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将修改当前使用<code>/images/prefix</code>将请求映射到<code>/data/images</code>目录下的文件的第二个<code>location</code>块，使其与典型文件扩展名的图像请求相匹配。 修改后的位置块如下所示：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~ \.(gif</span>|jpg|png)$ &#123;</span><br><span class="line">    root /data/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该参数是一个正则表达式，匹配所有以<code>.gif</code>，<code>.jpg</code>或<code>.png</code>结尾的URI。正则表达式之前应该是<code>~</code>字符。 相应的请求将映射到<code>/data/images</code>目录。</p><p>当nginx选择一个<code>location</code>块来提供请求时，它首先检查指定前缀的<code>location</code>指令，记住具有最长前缀的<code>location</code>，然后检查正则表达式。 如果与正则表达式匹配，nginx会选择此<code>location</code>，否则选择之前记住的那一个。</p><p>代理服务器的最终配置将如下所示：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|png)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span> /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此服务器将过滤以<code>.gif</code>，<code>.jpg</code>或<code>.png</code>结尾的请求，并将它们映射到<code>/data/images</code>目录(通过向<code>root</code>指令的参数添加URI)，并将所有其他请求传递到上面配置的代理服务器。</p><p>要应用新配置，如果尚未启动nginx或者通过执行以下命令将重载信号发送到nginx的主进程：</p><pre><code>[root@localhost ~]# /usr/local/nginx/sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful[root@localhost ~]# /usr/local/nginx/sbin/nginx -s reload</code></pre><p>首先测试上面配置的 <code>8080</code> 端口的服务，访问服务的<code>8080</code>端口，得到以下结果：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/183100431_95557.png" alt=""><br>再次访问 <code>80</code> 端口(这里只是一个代理，它会把请求转发给<code>8080</code>的服务，由<code>8080</code>端口这这个服务处理并返回结果到客户端)，得到以下结果 -<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/127100435_72363.png" alt=""></p><p>完整的配置<code>nginx.conf</code>文件内容如下 -</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 新服务(服务处理)</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">root</span> /data/up1;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 代理配置，数据转发</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://localhost:8080/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|png)$</span> &#123;</span><br><span class="line">            <span class="attribute">root</span> /data/images;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-设置FastCGI代理"><a href="#5-设置FastCGI代理" class="headerlink" title="5. 设置FastCGI代理"></a>5. 设置FastCGI代理</h2><p>nginx可用于将请求路由到运行使用各种框架和PHP等编程语言构建的应用程序的FastCGI服务器。<br>使用FastCGI服务器的最基本nginx配置包括使用<code>fastcgi_pass</code>指令(而不是<code>proxy_pass</code>指令)，以及<code>fastcgi_param</code>指令来设置传递给<code>FastCGI</code>服务器的参数。 假设<code>FastCGI</code>服务器可以在<code>localhost:9000</code>上访问。 以上一节的代理配置为基础，用<code>fastcgi_pass</code>指令替换<code>proxy_pass</code>指令，并将参数更改为<code>localhost:9000</code>。 在PHP中，<code>SCRIPT_FILENAME</code>参数用于确定脚本名称，<code>QUERY_STRING</code>参数用于传递请求参数。 最终的配置将是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>  localhost:<span class="number">9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> QUERY_STRING    <span class="variable">$query_string</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|png)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span> /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将设置一个服务器，将除静态图像请求之外的所有请求路由到通过FastCGI协议在<code>localhost:9000</code>上运行的代理服务器。</p><div class="note info"><p>作者：初生不惑<br>出处：<a href="https://www.yiibai.com/nginx/beginners_guide.html" target="_blank" rel="noopener">https://www.yiibai.com/nginx/beginners_guide.html</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>推荐几款个人使用的Chrome插件</title>
      <link href="/2018/10/23/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/10/23/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>今天我们给大家推荐几个我自己一直珍藏的 Chrome 插件，打造一个牛逼，炫酷不一样的浏览器，瞬间让你上一个档次，证明我们就是不一样。</p><h2 id="1-Infinity"><a href="#1-Infinity" class="headerlink" title="1.Infinity"></a>1.<a href="https://chrome.google.com/webstore/detail/infinity-new-tabproductiv/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">Infinity</a></h2><p>百万用户选择的新标签页，自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录。<br>Infinity功能简介：</p><ol><li>精美的图标（logo）：扁平化设计风格，国内外200多个热门常用图标。</li><li>高清壁纸：从3万5千张超清壁纸中，一张一张搭配图标，精心挑选出365张，形成每日一图;当然你也可以从你自己电脑上选择图片作为壁纸。</li><li>云同步：时间备份数据到云端，一键从云端恢复。</li><li>智能邮件通知：Gmail邮件自动提醒功能。</li><li>待办事项：随时查看你要做的事和你做过的事。</li><li>个性化搜索：你可以选择你想使用的搜索引擎，你还可以定制个人的附加搜索引擎。</li><li>App扩展管理：随时随地快捷方便的管理你的扩展。</li><li>历史记录管理：查看搜索你的记录。</li><li>笔记：记录生活点滴。</li></ol><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1_20181023162426.png" alt=""><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/2_20181023162508.png" alt=""></p><h2 id="2-谷歌访问助手"><a href="#2-谷歌访问助手" class="headerlink" title="2.谷歌访问助手"></a>2.<a href="https://chrome.google.com/webstore/detail/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/gocklaboggjfkolaknpbhddbaopcepfp" target="_blank" rel="noopener">谷歌访问助手</a></h2><p>不会科学上网的小伙伴必备插件，有了这款插件你就可以使用谷歌搜索（<a href="https://www.google.com/" target="_blank" rel="noopener">google.com</a>），访问谷歌邮箱（<a href="mail.google.com">mail.google.com</a>），访问chrome商店。<br>但是这款插件会把hao123设置为默认谷歌主页，不过不碍事，我用的Infinity新标签页完美解决。<br>还有一个缺点就是偶尔会出现网页无法访问的情况，此时右上角完全退出谷歌浏览器再打开就好了。</p><h2 id="3-Adblock-Plus"><a href="#3-Adblock-Plus" class="headerlink" title="3.Adblock Plus"></a>3.<a href="https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">Adblock Plus</a></h2><p>Adblock Plus 是世界上最流行的浏览器扩展，世界各地有数百万用户在使用它。这是一个社区驱动的开源项目，有数百名志愿者为 Adblock Plus 的成功作出了贡献，以实现所有烦人的广告被自动阻挡。</p><h2 id="4-WEB前端助手-FeHelper"><a href="#4-WEB前端助手-FeHelper" class="headerlink" title="4.WEB前端助手(FeHelper)"></a>4.<a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">WEB前端助手(FeHelper)</a></h2><p>FeHelper：包括JSON格式化、二维码生成与解码、信息编解码、代码压缩、美化、页面取色、Markdown与HTML互转、网页滚动截屏、正则表达式、时间转换工具、编码规范检测、页面性能检测、Ajax接口调试、密码生成器、JSON比对工具……<br>扩展功能：</p><ul><li>JSON自动美化（页面自动检测并格式化）</li><li>JSON手动美化（粘贴文本、手动格式化）</li><li>JSON比对工具（支持左右两个JSON片段进行键值对比较）</li><li>字符串编解码（Unicode/UTF8/Base64/MD5）</li><li>代码美化工具（HTML/CSS/JS/XML/SQL）</li><li>代码压缩工具（HTML/CSS/JS）</li><li>二维码生成器（支持当前页面、图片、链接、选中的文字生成QrCode）</li><li>二维码解码器（支持网页二维码<code>右键</code>解码）</li><li>网页转为图片（将当前整个网页转为图片并保存）</li><li>Markdown转换（支持Html到Markdown的互转）</li><li>页面取色工具（滑动鼠标随意取色）</li><li>Js正则表达式（正则测试、常用正则列表）</li><li>时间(戳)转换（Unix戳与本地时间的互转）</li><li>图片Base64（任意图片转DataURI格式）</li><li>随机密码生成（任意长度、任意字符、随机）</li><li>编码规范检测（HTML/CSS/JS规范检测）</li><li>页面性能检测（页面响应时间、Header监测）</li><li>Ajax调试功能（需在控制台中使用）<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/3_20181023164411.png" alt=""></li></ul><h2 id="5-右键搜"><a href="#5-右键搜" class="headerlink" title="5.右键搜"></a>5.<a href="https://chrome.google.com/webstore/detail/context-menus/phlfmkfpmphogkomddckmggcfpmfchpn" target="_blank" rel="noopener">右键搜</a></h2><p>扩展右键菜单，超过300种功能，方便的选择、组合或自定义页面、划词、图片菜单，并有生成、解析二维码和短网址功能。设置可使用云存储。最新增加功能共享、资源下载、重命名等功能。右键搜伴侣增加超级拖拽。</p><h2 id="6-Enhanced-Github"><a href="#6-Enhanced-Github" class="headerlink" title="6.Enhanced Github"></a>6.<a href="https://chrome.google.com/webstore/detail/enhanced-github/anlikcnbgdeidpacdbdljnabclhahhmd" target="_blank" rel="noopener">Enhanced Github</a></h2><p>显示仓库大小，每个文件的大小，下载链接和复制文件内容的选项<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/4_20181023165244.png" alt=""><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5_20181023165317.png" alt=""></p><h2 id="7-Isometric-Contributions"><a href="#7-Isometric-Contributions" class="headerlink" title="7.Isometric Contributions"></a>7.<a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien" target="_blank" rel="noopener">Isometric Contributions</a></h2><p>程序员专属了，它可以让我们 Github 的贡献图变成 3D 效果，非常适合用来装逼有没有，是不是很高大上。<br>展示下我的commit情况。<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/6_20181023165747.png" alt=""></p><h2 id="8-Octotree"><a href="#8-Octotree" class="headerlink" title="8.Octotree"></a>8.<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">Octotree</a></h2><p>这个可就屌了，当我们在浏览别人的开源代码时，还要clone下来一个文件查看，而有了这个插件，你可以直接在Chrome侧边栏向打开文件夹一样的查看别人的项目，简直了。给大家看下查看我的开源项目的正确打开方式。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/7_20181023170031.png" alt=""></p><h2 id="9-better-onetab"><a href="#9-better-onetab" class="headerlink" title="9.better-onetab"></a>9.<a href="https://chrome.google.com/webstore/detail/better-onetab/eookhngofldnbnidjlbkeecljkfpmfpg" target="_blank" rel="noopener">better-onetab</a></h2><p>OneTab 对我们技术人员来讲真是犹如神助啊，我们在工作中难免在开发的过程中查阅资料，打开很多标签页但是又舍不得删除，最主要的是浏览器的标签页打开了来以后不仅影响我们查找，还非常占用电脑的内存，是我们的电脑非常卡，以至于怀疑自己的电脑性能不好。</p><p>有了 OneTab 这些根本就不是问题了，它可以帮你把所有标签页都收集到一个标签里，而且还能释放我们的内存，当我们需要的时候直接点击恢复我们继续使用。就是这么简单，粗暴。</p><p>OneTab 的标签储存和标签分组功能是一个非常实用的功能，它可以帮助你储存你打开的标签页，以此来减少资源的使用以及避免杂乱。但是OneTab扩展还缺少一些诸如简易列表，只储存选中的标签等功能。由于开发时间久远长期无人更新，并且也不开源，所有也没办法为 OneTab 增加新的功能，所以这里又做了一个更好的 (Better-Onetab) 扩展。相比于 OneTab 拥有更美观的界面以及更多的功能，并且完全开源。</p><h2 id="10-扩展管理器（Extension-Manager）"><a href="#10-扩展管理器（Extension-Manager）" class="headerlink" title="10. 扩展管理器（Extension Manager）"></a>10. <a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco" target="_blank" rel="noopener">扩展管理器（Extension Manager）</a></h2><p>一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。快捷、简单、安全。<br>一键开启/禁用扩展</p><ol><li>闪电分组：根据场景快速开启/禁用扩展组（被锁定或主题类扩展除外）</li><li>智能排序：可根据您的使用频率智能排序（默认根据名称排序）</li><li>右键菜单：提供锁定、卸载、选项配置、主页、APP运行等快捷功能</li><li>智能搜索：通过关键字或词组快速找到需要的扩展</li><li>角标提醒：实时显示扩展状态，用完后提醒重置，减少资源占用（被锁定或主题类扩展除外）</li></ol><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/8_20181023171441.png" alt=""></p><h2 id="11-Postman-Interceptor"><a href="#11-Postman-Interceptor" class="headerlink" title="11. Postman Interceptor"></a>11. <a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo" target="_blank" rel="noopener">Postman Interceptor</a></h2><p>开发者在调试网络时候，Linux平台一般常用curl这种命令行工具，而如果你不会使用或者不习惯命令行，那Postman是你的不二人选，可以直接发送一个请求，自定义params、header，查看response状态等。<br>此插件也有桌面版，下载地址：<a href="https://www.getpostman.com/apps" title="https://www.getpostman.com/apps" target="_blank" rel="noopener">https://www.getpostman.com/apps</a></p><div class="note primary"><p>暂时先推荐这几个吧，后面用到新插件在更新。</p></div>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式事务，原来可以这么玩？</title>
      <link href="/2018/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%8E%9F%E6%9D%A5%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E7%8E%A9%EF%BC%9F/"/>
      <url>/2018/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%8E%9F%E6%9D%A5%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E7%8E%A9%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>此文摘自微信公众号【架构师之路】</p><p><center>微信扫一扫<br>关注该公众号</center><br><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961431&amp;idx=1&amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;send_time=" alt=""></p><h2 id="多个数据要同时操作，如何保证数据的完整性，以及一致性？"><a href="#多个数据要同时操作，如何保证数据的完整性，以及一致性？" class="headerlink" title="多个数据要同时操作，如何保证数据的完整性，以及一致性？"></a><strong>多个数据要同时操作，如何保证数据的完整性，以及一致性？</strong></h2><h2 id="答：事务，是常见的做法。"><a href="#答：事务，是常见的做法。" class="headerlink" title="答：事务，是常见的做法。"></a><strong>答</strong>：<span style="color: rgb(255, 76, 0);letter-spacing: 1px;">事务</span>，是常见的做法。</h2><p>举个<strong>栗子</strong>：</p><p>用户下了一个订单，需要修改<span style="color: rgb(255, 76, 0);letter-spacing: 1px;">余额表，订单表，流水表</span>，于是会有类似的伪代码：</p><p>start transaction;<br> CURD table t_account;  any Exception rollback;<br> CURD table t_order;      any Exception rollback;<br> CURD table t_flow;        any Exception rollback;<br>commit;</p><ul><li>如果对余额表，订单表，流水表的SQL操作全部成功，则全部提交</li><li>如果任何一个出现问题，则全部回滚</li></ul><p>事务，以保证数据的完整性以及一致性。</p><p><strong>事务的方案会有什么潜在问题？</strong></p><p><strong>答</strong>：互联网的业务特点，数据量较大，并发量较大，经常使用<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">拆库</span>的方式提升系统的性能。如果进行了拆库，<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">余额、订单、流水可能分布在不同的数据库</span>上，甚至不同的数据库实例上，此时就不能用数据库原生事务来保证数据的一致性了。</p><h2 id="高并发易落地的分布式事务，是行业没有很好解决的难题，那怎么办呢？"><a href="#高并发易落地的分布式事务，是行业没有很好解决的难题，那怎么办呢？" class="headerlink" title="高并发易落地的分布式事务，是行业没有很好解决的难题，那怎么办呢？"></a><strong>高并发易落地的分布式事务，是行业没有很好解决的难题，那怎么办呢？</strong></h2><h2 id="答：补偿事务是一种常见的实践。"><a href="#答：补偿事务是一种常见的实践。" class="headerlink" title="答：补偿事务是一种常见的实践。"></a><strong>答</strong>：<span style="color: rgb(255, 76, 0);letter-spacing: 1px;">补偿事务</span>是一种常见的实践。</h2><p><strong>什么是补偿事务？</strong></p><p>答：补偿事务，是一种在业务端实施<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">业务逆向操作事务</span>。</p><p>举个栗子：</p><p><strong>修改余额</strong>，<strong>事务</strong>为：</p><p>int <span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;">Do_AccountT</span>(uid, money){<br>    start transaction;<br>         //余额改变money这么多<br>         CURD table t_account with money for uid;<br>         anyException rollback return NO;<br>    commit;<br>    return YES;<br>}</p><p>那么，<strong>修改余额</strong>，<strong>补偿事务</strong>可以是：</p><p>int <span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;">Compensate_AccountT</span>(uid, money){<br>         //做一个money的反向操作<br>         return Do_AccountT(uid, -1*money){<br>}</p><p>同理，<strong>订单操作</strong>，<strong>事务</strong>是：Do_OrderT，新增一个订单；</p><p><strong>订单操作</strong>，<strong>补偿事务</strong>是：Compensate_OrderT，删除一个订单。</p><p>要保证余额与订单的一致性，伪代码：</p><p>// 执行第一个事务<br>int flag = Do_AccountT();<br>if(flag=YES){<br>    //第一个事务成功，则执行第二个事务<br>    flag= Do_OrderT();<br>    if(flag=YES){<br>        // 第二个事务成功，则成功<br>        return YES;<br>    }<br>    else{<br>        // 第二个事务失败，执行第一个事务的补偿事务<br>        Compensate_AccountT();<br>    }<br>}</p><p><strong>补偿事务有什么缺点？</strong></p><ul><li>不同的业务要写不同的补偿事务，<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">不具备通用性</span>；</li><li><span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">没有考虑补偿事务的失败</span>；</li><li>如果业务流程很复杂，<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">if/else会嵌套非常多层</span>；</li></ul><p><em><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;">画外音：上面的例子还只考虑了余额+订单的一致性，就有2<em>2=4个分支，如果要考虑余额+订单+流水的一致性，则会有2</em>2*2=8个if/else分支，复杂性呈指数级增长。</span></em></p><h2 id="还有其它简易一致性实践么？"><a href="#还有其它简易一致性实践么？" class="headerlink" title="还有其它简易一致性实践么？"></a><strong>还有其它简易一致性实践么？</strong></h2><h2 id="答：多个数据库实例上的多个事务，要保证一致性，可以进行“后置提交优化”。"><a href="#答：多个数据库实例上的多个事务，要保证一致性，可以进行“后置提交优化”。" class="headerlink" title="答：多个数据库实例上的多个事务，要保证一致性，可以进行“后置提交优化”。"></a><strong>答</strong>：多个数据库实例上的多个事务，要保证一致性，可以进行“<span style="color: rgb(255, 76, 0);letter-spacing: 1px;">后置提交优化</span>”。</h2><p><strong>单库</strong>是用这样一个大事务保证一致性：</p><p>start transaction;<br> CURD table t_account;  any Exception rollback;<br> CURD table t_order;      any Exception rollback;<br> CURD table t_flow;        any Exception rollback;<br>commit;</p><p>拆分成了多个库后，大事务会变成三个小事务：</p><p>start transaction1;<br>         //第一个库事务执行<br>         CURD table t_account; any Exception rollback;<br>         …<br>// 第一个库事务提交<br>commit1;</p><p>start transaction2;<br>         //第二个库事务执行<br>         CURD table t_order; any Exception rollback;<br>         …<br>// 第二个库事务提交<br>commit2;</p><p>start transaction3;<br>         //第三个库事务执行<br>         CURD table t_flow; any Exception rollback;<br>         …<br>// 第三个库事务提交<br>commit3;</p><p><span style="letter-spacing: 1px;font-size: 14px;">画外音：再次提醒，这三个事务发生在三个库，甚至3个不同实例的数据库上。</span></p><p>一个事务，分成<strong>执行</strong>与<strong>提交</strong>两个阶段：</p><ul><li>执行(CURD)的时间很长</li><li>提交(commit)的执行很快</li></ul><p>于是整个执行过程的时间轴如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540187917686_0.png" alt=""><br>第一个事务执行200ms，提交1ms；</p><p>第二个事务执行120ms，提交1ms；</p><p>第三个事务执行80ms，提交1ms；</p><p><strong>在什么时候，会出现不一致？</strong></p><p><strong>答</strong>：第一个事务成功提交之后，最后一个事务成功提交之前，如果出现问题（例如服务器重启，数据库异常等），都可能导致数据不一致。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540187918398_1.png" alt=""><br><em><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;">画外音：如上图，最后202ms内出现异常，会出现不一致。</span></em></p><p><strong>什么是后置提交优化？</strong></p><p><strong>答</strong>：如果改变事务执行与提交的时序，变成<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">事务先执行，最后一起提交</span>。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540187920595_2.png" alt=""><br>第一个事务执行200ms，第二个事务执行120ms，第三个事务执行80ms；</p><p>第一个事务提交1ms，第二个事务提交1ms，第三个事务提交1ms；</p><p><strong>后置提交优化后，在什么时候，会出现不一致？</strong></p><p><strong>答</strong>：问题的答案与之前相同，第一个事务成功提交之后，最后一个事务成功提交之前，如果出现问题（例如服务器重启，数据库异常等），都可能导致数据不一致。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540187921316_3.png" alt="">  </p><p><em><span style="letter-spacing: 1px;"><span style="color: rgb(0, 82, 255);letter-spacing: 1px;">画外音：<span style="text-align: left;text-transform: none;text-indent: 0px;letter-spacing: 1px;" sans="sans" helvetica="helvetica" inline="inline" yahei="yahei" px="px" none="none" normal="normal" gb="gb" neue="neue" transparent="transparent" important="important" italic="italic">如上</span></span><span style="text-align: left;color: rgb(0, 82, 255);text-transform: none;text-indent: 0px;letter-spacing: 1px;" sans="sans" helvetica="helvetica" inline="inline" yahei="yahei" px="px" none="none" normal="normal" gb="gb" neue="neue" transparent="transparent" important="important" italic="italic">图，最后2ms内出现异常，会出现不一致。</span></span></em></p><p><strong>有什么区别和差异？</strong></p><p><strong>答</strong>：</p><ul><li><span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">串行事务方案</span>，总执行时间是303ms，最后202ms内出现异常都可能导致不一致；</li><li><span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">后置提交优化方案</span>，总执行时间也是303ms，但最后2ms内出现异常才会导致不一致；</li></ul><p>虽然没有彻底解决数据的一致性问题，但<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">不一致出现的概率大大降低了</span>。</p><p><em><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;">画外音：上面这个例子，概率降低了100倍。</span></em></p><p><strong>后置提交优化，有什么不足？</strong></p><p><strong>答</strong>：对事务吞吐量会有影响：</p><ul><li><span style="margin: 0px;padding: 0px;color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">串行事务方案</span>，第一个库事务提交，数据库连接就释放了；</li><li><span style="margin: 0px;padding: 0px;color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">后置提交优化方案</span>，所有库的连接，要等到所有事务执行完才释放；</li></ul><p>这就意味着，数据库连接占用的时间增长了，系统整体的吞吐量降低了。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>分布式事务，两种常见的实践：</p><ul><li>补偿事务</li><li>后置提交优化</li></ul><p>把<br>trx1.exec(); trx1.commit();<br>trx2.exec(); trx2.commit();<br>trx3.exec(); trx3.commit();</p><p>优化为：<br>trx1.exec(); trx2.exec(); trx3.exec();<br>trx1.commit(); trx2.commit(); trx3.commit();</p><p>这个小小的改动（改动成本极低），不能彻底解决多库分布式事务数据一致性问题，但能大大降低数据不一致的概率，牺牲的是吞吐量。</p><p>对于一致性与吞吐量的折衷，还需要业务架构师谨慎权衡折衷。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="letter-spacing: 1px;font-size: 14px;">画外音：还是那句话，一切脱离业务常见的架构设计，都是耍流氓。</span></em></span></p><p><span style="box-sizing: border-box;color: rgb(255, 76, 0);font-size: 14px;letter-spacing: 1px;margin-bottom: 0px;margin-left: 0px;margin-right: 0px;margin-top: 0px;max-width: 100%;padding-bottom: 0px;padding-left: 0px;padding-right: 0px;padding-top: 0px;word-wrap: break-word;">思路</span>比结论重要，希望大家有收获。</p><p><strong>作业题</strong>：事务执行exec时间长，提交commit却很快，为什么设计成这样呢？数据库内核是怎么考虑的呢？</p>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7使用gnome美化主题</title>
      <link href="/2018/10/21/Centos7%E4%BD%BF%E7%94%A8gnome%E7%BE%8E%E5%8C%96%E4%B8%BB%E9%A2%98/"/>
      <url>/2018/10/21/Centos7%E4%BD%BF%E7%94%A8gnome%E7%BE%8E%E5%8C%96%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>先上效果图<br><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1_20181021143906.png" alt=""></p><h2 id="1-安装必要工具、依赖"><a href="#1-安装必要工具、依赖" class="headerlink" title="1.安装必要工具、依赖"></a>1.安装必要工具、依赖</h2><hr><p>主题配置工具<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> gnome-tweak-tool</span><br></pre></td></tr></table></figure></p><p>依赖<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install chrome-gnome-<span class="keyword">shell</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><h2 id="2-浏览器安装扩展"><a href="#2-浏览器安装扩展" class="headerlink" title="2.浏览器安装扩展"></a>2.浏览器安装扩展</h2><hr><p>浏览器打开<a href="https://extensions.gnome.org/" target="_blank" rel="noopener">https://extensions.gnome.org/</a></p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/3_20181021145247.png" alt="这里写图片描述"></p><h2 id="3-安装User-Themes"><a href="#3-安装User-Themes" class="headerlink" title="3.安装User Themes"></a>3.安装User Themes</h2><hr><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/4_20181021145438.png" alt="这里写图片描述"></p><p>更多请<a href="https://wiki.gnome.org/Projects/GnomeShellIntegrationForChrome/Installation" target="_blank" rel="noopener">点击这里</a></p><h2 id="4-创建主题和图标文件夹"><a href="#4-创建主题和图标文件夹" class="headerlink" title="4.创建主题和图标文件夹"></a>4.创建主题和图标文件夹</h2><hr><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.themes</span><br><span class="line"><span class="built_in">mkdir</span> ~/.icons</span><br></pre></td></tr></table></figure><h2 id="5-下载Github资源地址"><a href="#5-下载Github资源地址" class="headerlink" title="5.下载Github资源地址"></a>5.下载<a href="https://github.com/wangxiaoleiAI/CSDN-CODE/tree/master/Ubuntu18.04-tutorials-themes" target="_blank" rel="noopener">Github资源地址</a></h2><hr><p>只需关注thmes和icons两个文件中的压缩包即可 <a href="https://github.com/wangxiaoleiAI/CSDN-CODE/tree/master/Ubuntu18.04-tutorials-themes" target="_blank" rel="noopener">资源下载</a>。<br>也可以在gnome-look.org 自行提取<a href="https://www.gnome-look.org/p/1013714/" target="_blank" rel="noopener">原始资源地址</a></p><h2 id="6-开始美化，放置资源"><a href="#6-开始美化，放置资源" class="headerlink" title="6.开始美化，放置资源"></a>6.开始美化，放置资源</h2><hr><ul><li>配置应用主题</li><li>配置gnome桌面效果</li></ul><p>themes文件夹中的压缩包Sierra-light-solid.tar.xz打开后包含gnome-shell和gtk3，即gnome桌面效果与应用效果。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xf Sierra-light-solid<span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line">mv Sierra-light-solid ~/.themes</span><br></pre></td></tr></table></figure><p>MacOSX-icon-theme.tar.xz</p><ul><li>配置图标效果</li><li>配置光标（鼠标）效果</li></ul><p>icons文件夹中的MacOSX-cursors.tar.xz和MacOSX-icon-theme.tar.xz解压，放置在~/.icons中</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -xf MacOSX-icon-theme.tar.xz</span><br><span class="line"><span class="keyword">mv</span> MacOSX ~/.icons</span><br><span class="line"><span class="keyword">mv</span> MacOSX-dark ~/.icons</span><br><span class="line">    </span><br><span class="line">tar -xf MacOSX-cursors.tar.xz.xz</span><br><span class="line"><span class="keyword">mv</span> capitaine-cursors ~/.icons</span><br></pre></td></tr></table></figure><blockquote><p>另外也可以配置字体，字体文件解压放置在~/.local/share/fonts/　字体不建议配置，配置不好影响正常内容显示</p></blockquote><h2 id="7-放置好资源后，配置tweaks如下图。"><a href="#7-放置好资源后，配置tweaks如下图。" class="headerlink" title="7.放置好资源后，配置tweaks如下图。"></a>7.放置好资源后，配置tweaks如下图。</h2><hr><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5_20181021150507.png" alt="这里写图片描述"></p><h2 id="8-安装其余扩展插件"><a href="#8-安装其余扩展插件" class="headerlink" title="8.安装其余扩展插件"></a>8.安装其余扩展插件</h2><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/6_20181021150814.png" alt="这里写图片描述"><br><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/7_20181021150855.png" alt="这里写图片描述"></p><p>我推荐几款我用的<br>Dash to Dock：底部任务栏<br>GPaste：记录历史复制黏贴记录<br>OpenWeather：天气插件<br>…<br>更多就去插件中心自己找去吧。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
            <tag> gnome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7安装Google Chrome</title>
      <link href="/2018/10/21/Centos7%E5%AE%89%E8%A3%85Google%20Chrome/"/>
      <url>/2018/10/21/Centos7%E5%AE%89%E8%A3%85Google%20Chrome/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="1-首先进入根目录，然后进入etc-yum-repos-d目录下，创建google-chrome-repo文件"><a href="#1-首先进入根目录，然后进入etc-yum-repos-d目录下，创建google-chrome-repo文件" class="headerlink" title="1.首先进入根目录，然后进入etc/yum.repos.d目录下，创建google-chrome.repo文件"></a>1.首先进入根目录，然后进入etc/yum.repos.d目录下，创建google-chrome.repo文件</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /</span><br><span class="line"><span class="keyword">cd</span> etc/yum.repos.<span class="built_in">d</span></span><br><span class="line">vi google-chrome.repo</span><br></pre></td></tr></table></figure><h2 id="2-在文件中添加："><a href="#2-在文件中添加：" class="headerlink" title="2.在文件中添加："></a>2.在文件中添加：</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[google-chrome]</span> </span><br><span class="line"><span class="attr">name</span>=google-chrome </span><br><span class="line"><span class="attr">baseurl</span>=http://dl.google.com/linux/chrome/rpm/stable/<span class="variable">$basearch</span> </span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span> </span><br><span class="line"><span class="attr">gpgkey</span>=https://dl-ssl.google.com/linux/linux_signing_key.pub</span><br></pre></td></tr></table></figure><p><code>ESC 退出到命令模式，shift+q ， x保存退出</code></p><h2 id="3-加入谷歌的源之后键入："><a href="#3-加入谷歌的源之后键入：" class="headerlink" title="3.加入谷歌的源之后键入："></a>3.加入谷歌的源之后键入：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> google-chrome-stable <span class="comment">--nogpgcheck</span></span><br></pre></td></tr></table></figure><h2 id="4-安装完成。"><a href="#4-安装完成。" class="headerlink" title="4.安装完成。"></a>4.安装完成。</h2><p>在应用程序的互联网中就可以找到谷歌浏览器了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
            <tag> Google Chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7安装jq</title>
      <link href="/2018/10/21/Centos7%E5%AE%89%E8%A3%85jq/"/>
      <url>/2018/10/21/Centos7%E5%AE%89%E8%A3%85jq/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span></span><br><span class="line">rpm -ivh epel-release-latest-<span class="number">7</span><span class="selector-class">.noarch</span><span class="selector-class">.rpm</span></span><br><span class="line">yum repolist</span><br><span class="line">yum install jq</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
            <tag> jq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>10张图带你了解后台服务架构演变</title>
      <link href="/2018/10/16/10%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/"/>
      <url>/2018/10/16/10%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>上篇文章讲了一些高并发相关的知识，相信大家对高并发有些简单的认识。说到高并发，往往离不开分布式系统。人们经常将两者拿来一起讨论，因为高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一。可以这么说，目前应用商城上很多社交应用，网络游戏的后台服务都是分布式服务。那具体什么催生出今天的分布式系统呢？文章的主要内容是讲讲大型网站的服务架构演变。  </p><h3 id="1-初始阶段的网站架构"><a href="#1-初始阶段的网站架构" class="headerlink" title="1.初始阶段的网站架构"></a>1.初始阶段的网站架构</h3><p>在互联网展露出萌芽的网络时代，网站基本都是小型网站。网站的访客也不是很多，通常会将应用程序、数据库、文件等所有资源都在一台服务器上。这里为 Java Web 服务为例。网站开发者可以使用 Tomcat 等 Web 容器直接运行 JSP 程序，然后将数据存储到数据库，文件直接存放到服务器的磁盘中。就像这样子：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690105275_1.png" alt=""></p><h3 id="2-应用服务和数据分离"><a href="#2-应用服务和数据分离" class="headerlink" title="2.应用服务和数据分离"></a>2.应用服务和数据分离</h3><p>随着网站业务的发展和用户量的增加，一台服务器就无法再满足需求了。大量用户访问导致访问速度越来越慢，而逐渐增加的数据也会导致存储空间不足。<strong>这时需要将 Web 应用和数据分离，分别将存放到不同的服务器：应用服务器、文件服务器和数据库服务器</strong>。这样不仅提高了单台机器的负载能力，也提高了容灾能力。  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690105472_2.png" alt=""></p><h3 id="3-使用缓存改善网站性能"><a href="#3-使用缓存改善网站性能" class="headerlink" title="3.使用缓存改善网站性能"></a>3.使用缓存改善网站性能</h3><p>随着用户再增加，网站又会一次面临挑战：数据库压力太大导致整站访问效率再此下降，用户体验受到影响。</p><p>一个网站往往 80% 的业务访问集中在 20% 的数据上。那么将这一小部分频繁读取的数据先提前缓存在内存中，而不是每次都去数据库读取。这样就可以减少数据库的访问压力，从而提高整个网站的访问速度。</p><p>缓存分为本地缓存和分布式缓存服务器，前者更快但容量有限，后者理论上容量可以无限伸缩。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690105616_3.png" alt=""></p><h3 id="4-使用集群改善并发处理能力"><a href="#4-使用集群改善并发处理能力" class="headerlink" title="4.使用集群改善并发处理能力"></a>4.使用集群改善并发处理能力</h3><p>使用缓存后，数据访问压力得到了缓解.但是单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器就成了整个网站的效率瓶颈。因此使用负载均衡处理器势在必然。通过负载均衡调度服务器，可将来自浏览器的访问请求分发到应用的集群中的任何一台服务器上。使用服务器集群也有个好处，Web 应用程序更新可以做到用户无感知。<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690105827_4.png" alt=""></p><p>大部分应用使用软件来实现负载均衡。常见的软件有 Nginx 等。</p><h3 id="5-数据库读写分离"><a href="#5-数据库读写分离" class="headerlink" title="5.数据库读写分离"></a>5.数据库读写分离</h3><p>当用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。虽然前面使用缓存能满足查询的需求，但是大部分数据操作还是需要通过数据库来完成。而目前主流的数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库的数据更新同步到另一台服务器上。网站利用数据库这一功能实现数据库读写分离，从而改善数据库负载压力。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690106000_5.png" alt=""></p><p>应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明。</p><h3 id="6-反向代理和-CDN-加速"><a href="#6-反向代理和-CDN-加速" class="headerlink" title="6.反向代理和 CDN 加速"></a>6.反向代理和 CDN 加速</h3><p>随着网站名气越多越大，用户规模越来越大，网站业务也随着继续壮大。为了满足不同地区的用户快速访问网站的需求，需要提高网站的访问速度。主要手段有使用 CDN 和反向代理。</p><p>同时 Ajax 技术的出现，Web 应用会将数据（内容和图片）和页面框架（指 HTML 文件以及其中的标签）。页面框架内容存放到 CDN 服务器上，数据存放到数据库服务器上。当用户使用浏览器访问网站，会显示页面框架，然后页面框架发起 HTTP 请求加载数据。</p><p>而反向代理是部署在网站的中心机房，当用户请求到达中心机房后，首先访问的反向代理，如果反向代理缓存着用户请求的资源，则直接返回给用户。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690106210_6.png" alt=""></p><p>因此，<strong>CDN 和反向代理的基本原理都是缓存</strong>。</p><h3 id="7-使用分布式文件系统和分布式数据库系统"><a href="#7-使用分布式文件系统和分布式数据库系统" class="headerlink" title="7.使用分布式文件系统和分布式数据库系统"></a>7.使用分布式文件系统和分布式数据库系统</h3><p>任何强大的单一服务器都满足不了大型网站持续增长的业务需求。</p><p>分布式数据库时网站数据库拆分的最后手段，只用在单表数据规模非常大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务拆分，将不同业务的数据部署在不同的物理服务器上。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690106413_7.png" alt=""></p><h3 id="8-使用NoSQL和搜索引擎"><a href="#8-使用NoSQL和搜索引擎" class="headerlink" title="8.使用NoSQL和搜索引擎"></a>8.使用NoSQL和搜索引擎</h3><p>随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。网站需要采用一些非关系数据库技术如 NoSQL 数据库和非数据库查询技术如搜索引擎。而常见的 NoSQL 数据库有 Mongodb、HBase等。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690106594_8.png" alt=""></p><h3 id="9-业务拆分"><a href="#9-业务拆分" class="headerlink" title="9.业务拆分"></a>9.业务拆分</h3><p>大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将真个网站业务拆分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690106829_9.png" alt=""></p><h3 id="10-啥分布式服务"><a href="#10-啥分布式服务" class="headerlink" title="10.啥分布式服务"></a>10.啥分布式服务</h3><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。</p><p>既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539690106993_10.png" alt=""></p><p>大型网站的架构演化到这里，基本上大多数的技术问题都可以得以解决了。</p><blockquote><p>本文本分内容以及图片参考书籍《大型网站技术架构：核心原理与案例分析》 作者: 李智慧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Idea开发环境中搭建Maven并且使用Maven打包部署程序</title>
      <link href="/2018/10/16/Idea%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%90%AD%E5%BB%BAMaven%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8Maven%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/10/16/Idea%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%90%AD%E5%BB%BAMaven%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8Maven%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><div class="note info no-icon"><p>作者：怪才<br>来源：<a href="http://www.cnblogs.com/hanyinglong" target="_blank" rel="noopener">www.cnblogs.com/hanyinglong</a><br></p></div><h3 id="1-配置Maven的环境变量"><a href="#1-配置Maven的环境变量" class="headerlink" title="1.配置Maven的环境变量"></a>1.配置Maven的环境变量</h3><p>a.首先我们去maven官网下载Maven程序，解压到安装目录，如图所示:</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684037598_0.png" alt=""></p><p>b.配置M2_HOME的环境变量，然后将该变量添加到Path中  </p><blockquote><p>备注：必须要有JAVA_HOME的M2_HOME环境变量，不然Maven会提示错误。配置环境变量如图所示：</p></blockquote><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684038281_1.png" alt=""></p><p>c.如果想要修改Maven的本地仓库位置，则可以直接在Maven的安装目录下找到conf文件下的setting配置文件中，设置localRepository为本地仓库位置<code>&lt;localRepository&gt;E:\java\repo&lt;/localRepository&gt;</code></p><p>d.重新打开命令提示符cmd(管理员)，输入mvn –version ，如图所示，则说明安装成功  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684038925_2.png" alt=""></p><h3 id="2-Idea开发环境中搭建Maven"><a href="#2-Idea开发环境中搭建Maven" class="headerlink" title="2.Idea开发环境中搭建Maven"></a>2.Idea开发环境中搭建Maven</h3><p>a.当配置完Maven之后，我们需要给Idea配置Maven，那么首先必须先要安装Idea，Idea的安装在这里就不累赘了，请自行百度，非常简单，下一步下一步即可，安装完成之后打开Idea设置Maven，如图所示：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684039612_3.png" alt=""></p><p>b.单击Setting之后，设置Maven节点下的Maven home directory和user settings file和local repository  </p><p>如图所示：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684040330_4.png" alt=""></p><p>到这里我们整个Idea配置Maven就完成了，下面来说使用Maven开发JavaWeb项目以及使用Maven打包。  </p><h3 id="3-使用Maven开发JavaWeb项目-Idea14"><a href="#3-使用Maven开发JavaWeb项目-Idea14" class="headerlink" title="3.使用Maven开发JavaWeb项目(Idea14)"></a>3.使用Maven开发JavaWeb项目(Idea14)</h3><p>a.通过上面的步骤我们便给Idea配置好了Maven环境，那么这时候我们更愿意创建Maven管理的Java Web项目，如何创建呢？</p><p>b.单击File-&gt;New Project-&gt;选择Maven,如图所示：<br>选中Createfrom archetype，选择maven-archetype-webapp  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684041208_5.png" alt=""></p><p>c.单击Next，如图所示：填写GroupId和ArtifactId和Version  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684042087_6.png" alt=""></p><p>d.单击Next，如图所示：此页面获取的是maven的安装信息  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684042784_7.png" alt=""></p><p>e.单击Next，如图所示：填写项目名称和项目存放的路劲  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684043486_8.png" alt=""></p><p>f.单击 Finish完成，即创建Maven项目成功，如图所示：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684044109_9.png" alt=""></p><p>g.如果单击完成在下面的提示中报错，出现问题的可能性是Maven和Idea的兼容性问题，建议将Maven换成低版本的即可。报错如图所示：  </p><blockquote><p>备注：当改变Maven版本的时候，必须改变环境变量和Idea中的设置才可以。</p></blockquote><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684044787_10.png" alt=""></p><h3 id="4-使用Maven打包JavaWeb项目"><a href="#4-使用Maven打包JavaWeb项目" class="headerlink" title="4.使用Maven打包JavaWeb项目"></a>4.使用Maven打包JavaWeb项目</h3><p>a.通过以上步骤即安装了Maven和开发了一个Maven的JavaWeb项目，那么接下来就需要将JavaWeb打包(war文件)发布到Tomcat下，如何打包呢？</p><p>b.在Idea中的最右边的导航栏中可以看到一个Maven Projects，单击打开，如图所示：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684045521_11.png" alt=""></p><p>图一</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684046164_12.png" alt=""></p><p>图二</p><p>c.接下来我们就能够利用这个简单的工具对Maven进行打包(war)。  </p><p>d.如图2所示，当单击Run Maven Build的时候，出现错误，如图所示：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684046875_13.png" alt=""></p><p>e.出现以上错误之后，按照下面的步骤解决，单击File-&gt;Setting-&gt;在搜索框中输入Maven回车直接定位到Maven节点-&gt;Runner,打开之后将这段内容  </p><blockquote><p>-Dmaven.multiModuleProjectDirectory=$M2_HOME）</p></blockquote><p>复制到VM Options的文本框中，单击OK即可。</p><p>f.按照图2所示，我们再次运行，发现不会报错，并且输入了一些内容，证明已可以打包程序。</p><p>g.选择install右键选择Run运行即可，运行完成之后则会提示你打包的war包在哪里，如图所示　　  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1539684047718_14.png" alt=""></p><p>h.然后找到war包,复制到Tomcat的WebApps文件夹下面，然后直接访问网站即可访问。  </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Idea </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拜托，面试别再问我时间复杂度了！！！</title>
      <link href="/2018/10/11/%E6%8B%9C%E6%89%98%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2018/10/11/%E6%8B%9C%E6%89%98%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>此文摘自微信公众号【架构师之路】</p><center>微信扫一扫<br>关注该公众号</center><p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961431&amp;idx=1&amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;send_time=" alt=""></p><p>快速排序分为这么几步：</p><p><strong>第一步</strong>，先做一次partition；</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540189487005_0.png" alt=""> </p><p>partition使用第一个元素t=arr[low]为哨兵，把数组分成了两个半区：</p><ul><li><p>左半区比t大</p></li><li><p>右半区比t小</p></li></ul><p><strong>第二步</strong>，左半区递归；</p><p><strong>第三步</strong>，右半区递归；</p><p>伪代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(low== high) <span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">int</span> i = partition(arr, low, high);</span><br><span class="line">         quick_sort(arr, low, i<span class="number">-1</span>);</span><br><span class="line">         quick_sort(arr, i+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为啥，快速排序，时间复杂度是O(n*lg(n))呢？</strong></p><p>今天和大家聊聊时间复杂度。</p><p><em>画外音：往下看，第三类方法很牛逼。</em></p><p><strong>第一大类，简单规则</strong></p><p>为方便记忆，先总结几条简单规则，热热身。</p><p>规则一：“有限次操作”的时间复杂度往往是O(1)。</p><p><strong>例子：交换两个数a和b的值。</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void swap(int&amp; a, int&amp; b)&#123;</span><br><span class="line"></span><br><span class="line">         int <span class="attribute">t</span>=a;</span><br><span class="line"></span><br><span class="line">         <span class="attribute">a</span>=b;</span><br><span class="line"></span><br><span class="line">         <span class="attribute">b</span>=t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：通过了一个中间变量t，进行了3次操作，交换了a和b的值，swap的时间复杂度是O(1)。</p><p><em>画外音：这里的有限次操作，是指不随数据量的增加，操作次数增加。</em></p><p>规则二：“for循环”的时间复杂度往往是O(n)。</p><p><strong>例子：n个数中找到最大值。</strong></p><figure class="highlight plain"><figcaption><span>max(int[] arr, int n)&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         int temp = -MAX;</span><br><span class="line"></span><br><span class="line">         for(int i=0;i&lt;n;++i)</span><br><span class="line"></span><br><span class="line">                   if(arr[i]&gt;temp) temp=arr[i];</span><br><span class="line"></span><br><span class="line">         return temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：通过一个for循环，将数据集遍历，每次遍历，都只执行“有限次操作”，计算的总次数，和输入数据量n呈<strong>线性关系</strong>。</p><p>规则三：“树的高度”的时间复杂度往往是O(lg(n))。</p><p><strong>分析</strong>：树的总节点个数是n，则树的高度是lg(n)。</p><p>在一棵包含n个元素二分查找树上进行<strong>二分查找</strong>，其时间复杂度是O(lg(n))。</p><p>对一个包含n个元素的堆顶元素弹出后，<strong>调整成一个新的堆</strong>，其时间复杂度也是O(lg(n))。</p><p><strong>第二大类：组合规则</strong></p><p>通过简单规则的时间复杂度，来求解组合规则的时间复杂度。</p><p><strong>例如：n个数冒泡排序。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                swap(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：冒泡排序，可以看成三个规则的组合：</p><p>1. 外层for循环</p><p>2. 内层for循环</p><p>3. 最内层的swap</p><p>故，<strong>冒泡排序</strong>的时间复杂度为：</p><p>O(n) <em> O(n) </em> O(1) = O(n^2)</p><p><strong>又例如：TopK问题，通过建立k元素的堆，来从n个数中求解最大的k个数。</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540189487781_1.png" alt=""> </p><p>先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540189488546_2.png" alt=""> </p><p>接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1540189489295_3.png" alt=""> </p><p>直到，扫描完所有n-k个元素，最终堆中的k个元素，就是为所求的TopK。</p><p><strong>伪代码</strong>：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">heap<span class="string">[k]</span> = make_heap(arr<span class="string">[1, k]</span>);</span><br><span class="line"></span><br><span class="line">for(i=k+<span class="number">1</span> to n)&#123;</span><br><span class="line"></span><br><span class="line">         adjust_heap(heep<span class="string">[k]</span>,arr<span class="string">[i]</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return heap<span class="string">[k]</span>;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：可以看成三个规则的组合：</p><p>1. 新建堆</p><p>2. for循环</p><p>3. 调整堆</p><p>故，用<strong>堆求解TopK</strong>，时间复杂度为：</p><p>O(k) + O(n) <em> O(lg(k)) = O(n</em>lg(k))</p><p><em>画外音：注意哪些地方用加，哪些地方用乘；哪些地方是n，哪些地方是k。</em></p><p><strong>第三大类，递归求解</strong></p><p>简单规则和组合规则可以用来求解非递归的算法的时间复杂度。<strong>对于递归的算法，该怎么分析呢？</strong></p><p>接下来，通过几个案例，来说明如何通分析递归式，来分析<strong>递归算法</strong>的时间复杂度。</p><p><strong>案例一：计算 1到n的和，时间复杂度分析。</strong></p><p>如果用<strong>非递归的算法</strong>：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum(<span class="built_in">int</span> n)&#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">int</span> <span class="literal">result</span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">                   <span class="literal">result</span> += i;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据简单规则，for循环，sum的时间复杂度是O(n)。</p><p>但如果是<strong>递归算法</strong>，就没有这么直观了：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span>(<span class="built_in">int</span> <span class="built_in">n</span>)&#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">if</span> (<span class="built_in">n</span>==<span class="number">1</span>) return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         return <span class="built_in">n</span>+<span class="built_in">sum</span>(<span class="built_in">n</span>-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何来进行时间复杂度分析呢？</strong></p><p>用f(n)来表示数据量为n时，算法的计算次数，很容易知道：</p><ul><li>当n=1时，sum函数只计算1次</li></ul><p><em>画外音：if (n==1) return 1;</em></p><p>即：</p><p>f(1)=1<strong>【式子A】</strong></p><p>不难发现，当n不等于1时：</p><ul><li>f(n)的计算次数，等于f(n-1)的计算次数，再加1次计算</li></ul><p><em>画外音：return n+sum(n-1);</em></p><p>即：</p><p>f(n)=f(n-1)+1<strong>【式子B】</strong></p><p>【式子B】不断的展开，再配合【式子A】：</p><p><em>画外音：这一句话，是分析这个算法的关键。</em></p><p>f(n)=f(n-1)+1</p><p>f(n-1)=f(n-2)+1</p><p>…</p><p>f(2)=f(1)+1</p><p>f(1)=1</p><p>上面共n个等式，左侧和右侧分别相加：</p><p>f(n)+f(n-1)+…+f(2)+f(1)</p><p>=</p><p>[f(n-1)+1]+[f(n-2)+1]+…+[f(1)+1]+[1]</p><p><strong>即得到</strong>：</p><p>f(n)=n</p><p>已经有那么点意思了哈，再来个复杂点的算法。</p><p><strong>案例二：二分查找binary_search，时间复杂度分析。</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (low&gt;high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">         mid = (low+high)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (arr[mid]== <span class="keyword">target</span>) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (arr[mid]&gt; <span class="keyword">target</span>)</span><br><span class="line"></span><br><span class="line">                  <span class="function"><span class="keyword">return</span> <span class="title">BS</span><span class="params">(arr, low, mid<span class="number">-1</span>, <span class="keyword">target</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                  <span class="function"><span class="keyword">return</span> <span class="title">BS</span><span class="params">(arr, mid+<span class="number">1</span>, high, <span class="keyword">target</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找，单纯从递归算法来分析，怎能知道其时间复杂度是O(lg(n))呢？</strong></p><p>仍用f(n)来表示数据量为n时，算法的计算次数，很容易知道：</p><ul><li>当n=1时，bs函数只计算1次</li></ul><p><em>画外音：不用纠结是1次还是1.5次，还是2.7次，是一个常数次。</em></p><p>即：</p><p>f(1)=1<strong>【式子A】</strong></p><p>在n很大时，二分会进行一次比较，然后进行左侧或者右侧的递归，以减少一半的数据量：</p><ul><li>f(n)的计算次数，等于f(n/2)的计算次数，再加1次计算</li></ul><p><em>画外音：计算arr[mid]&gt;target，再减少一半数据量迭代</em></p><p>即：</p><p>f(n)=f(n/2)+1<strong>【式子B】</strong></p><p>【式子B】不断的展开，</p><p>f(n)=f(n/2)+1</p><p>f(n/2)=f(n/4)+1</p><p>f(n/4)=f(n/8)+1</p><p>…</p><p>f(n/2^(m-1))=f(n/2^m)+1</p><p>上面共m个等式，左侧和右侧分别相加：</p><p>f(n)+f(n/2)+…+f(n/2^(m-1))<br>=<br>[f(n/2)+1]+[f(n/4)+1]+…+[f(n/2^m)]+[1]</p><p><strong>即得到</strong>：</p><p>f(n)=f(n/2^m)+m</p><p>再配合【式子A】：</p><p>f(1)=1</p><p>即，n/2^m=1时, f(n/2^m)=1, 此时m=lg(n), 这一步，这是分析这个算法的关键。</p><p>将m=lg(n)带入，<strong>得到</strong>：</p><p>f(n)=1+lg(n)</p><p><strong>神奇不神奇？</strong></p><p>最后，大boss，快速排序递归算法，时间复杂度的分析过程。</p><p><strong>案例三：快速排序quick_sort，时间复杂度分析。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, inthigh)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (low==high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">         quick_sort(arr, low, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">         quick_sort(arr, i+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍用f(n)来表示数据量为n时，算法的计算次数，很容易知道：</p><ul><li>当n=1时，quick_sort函数只计算1次</li></ul><p>f(1)=1<strong>【式子A】</strong></p><p>在n很大时：</p><p>第一步，先做一次partition；</p><p>第二步，左半区递归；</p><p>第三步，右半区递归；</p><p>即：</p><p>f(n)=n+f(n/2)+f(n/2)=n+2*f(n/2)<strong>【式子B】</strong></p><p><em>画外音：</em></p><p><em>(1)partition本质是一个for，计算次数是n；</em></p><p><em>(2)二分查找只需要递归一个半区，而快速排序左半区和右半区都要递归，这一点在<strong>分治法</strong>与<strong>减治法</strong>一章节已经详细讲述过；</em></p><p>【式子B】不断的展开，</p><p>f(n)=n+2*f(n/2)</p><p>f(n/2)=n/2+2*f(n/4)</p><p>f(n/4)=n/4+2*f(n/8)</p><p>…</p><p>f(n/2^(m-1))=n/2^(m-1)+2f(n/2^m)</p><p>上面共m个等式，逐步带入，于是得到：</p><p>f(n)=n+2*f(n/2)</p><p>=n+2<em>[n/2+2\</em>f(n/4)]=2n+4*f(n/4)</p><p>=2n+4<em>[n/4+2</em>f(n/8)]=3n+8f(n/8)</p><p>=…</p><p>=m*n+2^m*f(n/2^m)</p><p>再配合【式子A】：</p><p>f(1)=1</p><p>即，n/2^m=1时, f(n/2^m)=1, 此时m=lg(n), 这一步，这是分析这个算法的关键。</p><p>将m=lg(n)带入，<strong>得到：</strong></p><p>f(n)=lg(n)*n+2^(lg(n))*f(1)=n*lg(n)+n</p><p>故，快速排序的时间复杂度是n*lg(n)。</p><p><strong>wacalei，有点意思哈！</strong></p><p><em>画外音：额，估计83%的同学没有细究看，花5分钟细思上述过程，一定有收获。</em>  </p><p><strong>总结</strong></p><ul><li><p><strong>for循环</strong>的时间复杂度往往是O(n)</p></li><li><p><strong>树的高度</strong>的时间复杂度往往是O(lg(n))</p></li><li><p><strong>二分查找</strong>的时间复杂度是O(lg(n))，<strong>快速排序</strong>的时间复杂度n*(lg(n))</p></li><li><p><strong>递归求解</strong>，未来再问时间复杂度，通杀</p></li></ul><p><strong>知其然，知其所以然。</strong></p><p>思路比结论重要。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何对JPA或者MyBatis进行技术选型</title>
      <link href="/2018/10/10/%E5%A6%82%E4%BD%95%E5%AF%B9JPA%E6%88%96%E8%80%85MyBatis%E8%BF%9B%E8%A1%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
      <url>/2018/10/10/%E5%A6%82%E4%BD%95%E5%AF%B9JPA%E6%88%96%E8%80%85MyBatis%E8%BF%9B%E8%A1%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><div class="note info no-icon"><p>作者：springforall<br>来源：<a href="http://www.spring4all.com/common/user/532" target="_blank" rel="noopener">http://www.spring4all.com/common/user/532</a><br></p></div><p>在我们平时的项目中，大家都知道可以使用 JPA 或者 Mybatis 作为 ORM 层。对 JPA 和 Mybatis 如何进行技术选型？</p><p>下面看看大精华总结如下：</p><h2 id="最佳回答"><a href="#最佳回答" class="headerlink" title="最佳回答"></a>最佳回答</h2><p>首先表达个人观点，JPA必然是首选的。</p><p>个人认为仅仅讨论两者使用起来有何区别，何者更加方便，不足以真正的比较这两个框架。要评判出更加优秀的方案，我觉得可以从软件设计的角度来评判。个人对 mybatis 并不熟悉，但 JPA 规范和 springdata 的实现，设计理念绝对是超前的。软件开发复杂性的一个解决手段是遵循 DDD（DDD 只是一种手段，但不是唯一手段），而我着重几点来聊聊 JPA 的设计中是如何体现领域驱动设计思想的，抛砖引玉。</p><h3 id="聚合根和值对象"><a href="#聚合根和值对象" class="headerlink" title="聚合根和值对象"></a>聚合根和值对象</h3><p>领域驱动设计中有两个广为大家熟知的概念，entity（实体）和 value object（值对象）。entity 的特点是具有生命周期的，有标识的，而值对象是起到一个修饰的作用，其具有不可变性，无标识。在 JPA中 ，需要为数据库的实体类添加 <a href="https://github.com/Entity" title="@Entity" target="_blank" rel="noopener">@Entity</a> 注解，相信大家也注意到了，这并不是巧合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"t_order"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String oid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> CustomerVo customer;</span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = &#123;CascadeType.ALL&#125;, orphanRemoval = <span class="keyword">true</span>, fetch = FetchType.LAZY, mappedBy = <span class="string">"order"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述的代码，Order 便是 DDD 中的实体，而 CustomerVo，OrderItem 则是值对象。程序设计者无需关心数据库如何映射这些字段，因为在 DDD 中，需要做的工作是领域建模，而不是数据建模。实体和值对象的意义不在此展开讨论，但通过此可以初见端倪，JPA 的内涵绝不仅仅是一个 ORM 框架。</p><h3 id="仓储"><a href="#仓储" class="headerlink" title="仓储"></a>仓储</h3><p>Repository 模式是领域驱动设计中另一个经典的模式。在早期，我们常常将数据访问层命名为：DAO，而在 SpringData JPA 中，其称之为 Repository（仓储），这也不是巧合，而是设计者有意为之。</p><p>熟悉 SpringData JPA 的朋友都知道当一个接口继承 JpaRepository 接口之后便自动具备了 一系列常用的数据操作方法，<code>findAll</code>， <code>findOne</code> ，<code>save</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Order</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么仓储和DAO到底有什么区别呢？这就要提到一些遗留问题，以及一些软件设计方面的因素。在这次SpringForAll 的议题中我能够预想到有很多会强调 SpringData JPA 具有方便可扩展的 API，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Order</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">      findByOrderNoAndXxxx(String orderNo,Xxx xx);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span>(clearAutomatically = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"update t_order set order_status =?1 where id=?2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateOrderStatusById</span><span class="params">(String orderStatus, String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我要强调的是，这是 SpringData JPA 的妥协，其支持这一特性，并不代表其建议使用。因为这并不符合领域驱动设计的理念。注意对比，SpringData JPA 的设计理念是将 Repository 作为数据仓库，而不是一系列数据库脚本的集合，<code>findByOrderNoAndXxxx</code> 方法可以由下面一节要提到的<code>JpaSpecificationExecutor</code>代替，而 <code>updateOrderStatusById</code> 方法则可以由 <code>findOne</code> + <code>save</code> 代替，不要觉得这变得复杂了，试想一下真正的业务场景，修改操作一般不会只涉及一个字段的修改， <code>findOne</code> + <code>save</code> 可以帮助你完成更加复杂业务操作，而不必关心我们该如何编写 SQL 语句，真正做到了面向领域开发，而不是面向数据库 SQL 开发，面向对象的拥趸者也必然会觉得，这更加的 OO。</p><h3 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h3><p>上面提到 SpringData JPA 可以借助 Specification 模式代替复杂的 <code>findByOrderNoAndXxxx</code> 一类 SQL 脚本的查询。试想一下，业务不停在变，你怎么知道将来的查询会不会多一个条件 变成 <code>findByOrderNoAndXxxxAndXxxxAndXxxx....</code> 。SpringData JPA 为了实现领域驱动设计中的 Specification 模式，提供了一些列的 Specification 接口，其中最常用的便是 ：JpaSpecificationExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Order</span>,<span class="title">String</span>&gt;,<span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Order</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 SpringData JPA 构建复杂查询（join操作，聚集操作等等）都是依赖于 JpaSpecificationExecutor 构建的 Specification 。例子就不介绍，有点长。</p><p>请注意，上述代码并不是一个例子，在真正遵循 DDD 设计规范的系统中，OrderRepository 接口中就应该是干干净净的，没有任何代码，只需要继承 JpaRepository （负责基础CRUD）以及 JpaSpecificationExecutor （负责Specification 查询）即可。当然， SpringData JPA 也提供了其他一系列的接口，根据特定业务场景继承即可。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>为了解决数据并发问题，JPA 中提供了 <code>[@Version](https://github.com/Version &quot;@Version&quot;)</code> ，一般在 Entity 中 添加一个 <code>Long version</code> 字段，配合 <code>[@Version](https://github.com/Version &quot;@Version&quot;)</code> 注解，SpringData JPA 也考虑到了这一点。这一点侧面体现出，JPA 设计的理念和 SpringData 作为一个工程解决方案的双剑合璧，造就出了一个伟大的设计方案。</p><h3 id="复杂的多表查询"><a href="#复杂的多表查询" class="headerlink" title="复杂的多表查询"></a>复杂的多表查询</h3><p>很多人青睐 Mybatis ，原因是其提供了便利的 SQL 操作，自由度高，封装性好……SpringData JPA对复杂 SQL 的支持不好，没有实体关联的两个表要做 join ，的确要花不少功夫。但 SpringData JPA 并不把这个当做一个问题。为什么？因为现代微服务的架构，各个服务之间的数据库是隔离的，跨越很多张表的 join 操作本就不应该交给单一的业务数据库去完成。解决方案是：使用 elasticSearch做视图查询 或者 mongodb 一类的Nosql 去完成。问题本不是问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>真正走进 JPA，真正走进 SpringData 会发现，我们并不是在解决一个数据库查询问题，并不是在使用一个 ORM 框架，而是真正地在实践领域驱动设计。</p><p>（再次补充：DDD 只是一种手段，但不是唯一手段）</p><h2 id="第二名回答"><a href="#第二名回答" class="headerlink" title="第二名回答"></a>第二名回答</h2><p>lexburne 兄说的也很不错了，不过我还想在补充2点，来消除大家对使用spring data jpa 的误解<br>spring data jpa 的好处我相信大家都了解，就是开发速度很快，很方便，大家不愿意使用spring data jpa 的地方通常是因为sql 不是自己写的，不可控，复杂查询不好搞，那么下面我要说的就是其实对于这种需求，spring data jpa 是完全支持的！！</p><ol><li>第一种方式:<a href="https://github.com/query" title="@query" target="_blank" rel="noopener"></a><a href="https://github.com/query" title="@query" target="_blank" rel="noopener">@query</a> 注解指定nativeQuery,这样就可以使用原生sql查询了,示例代码来自官方文档:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line"><span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果单靠sql搞不定怎么办？必须要写逻辑怎么办?可以使用官方文档3.6.1 节：Customizing individual repositories 提供的功能去实现，先看官方文档的代码:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>我来解释下上面的代码，如果搞不定的查询方法，可以自定义接口，例如CustomizedUserRepository ，和他的实现了类，然后在这个实现类里用你自己喜欢的dao 框架，比如说mybatis ,jdbcTemplate ,都随意，最后在用UserRepository 去继承CustomizedUserRepository接口，就实现了和其他dao 框架的组合使用！！</p></div><p>那么下面我在总结1下，有了上面介绍的2种功能，你还在担心，使用spring data jpa 会有局限么，他只会加速你的开发速度，并允许你组合使用其他框架，只有好处，没有坏处。。<br>最后再说1点，我最近在看es ,然后看了下spring data es 的文档，大概扫了1下，我发现，学会spring data 其中某1个系列以后，在看其他的，我发现我都不用花时间学。。直接就可以用，对就是这么神奇～～</p><h2 id="第三"><a href="#第三" class="headerlink" title="第三"></a>第三</h2><p>工作以来一直是使用 hibernate 和 mybatis，总结下来一般传统公司、个人开发（可能只是我）喜欢用jpa，互联网公司更青睐于 mybatis<br>原因：，而mybatis 更加灵活。开发迭代模式决定的，传统公司需求迭代速度慢，项目改动小，hibernate可以帮他们做到一劳永逸；而互联网公司追求快速迭代，需求快速变更，灵活的 mybatis 修改起来更加方便，而且一般每一次的改动不会带来性能上的下降，hibernate经常因为添加关联关系或者开发者不了解优化导致项目越来越糟糕（本来开始也是性能很好的）</p><p>1、mybatis官方文档就说了他是一个半自动化的持久层框架，相对于全自动化的 hibernate 他更加的灵活、可控<br>2、mybatis 的学习成本低于 hibernate。hibernate 使用需要对他有深入的理解，尤其是缓存方面，作为一个持久层框架，性能依然是第一位的。</p><p>hibernate 它有着三级缓存，一级缓存是默认开启的，二级缓存需要手动开启以及配置优化，三级缓存可以整合业界流行的缓存技术 redis，ecache 等等一起去实现<br>hibernate 使用中的优化点：<br>1、缓存的优化<br>2、关联查询的懒加载（在开发中，还是不建议过多使用外键去关联操作）</p><p>jpa（Java Persistence API） 与 hibernate 的关系：<br>Jpa是一种规范，hibernate 也是遵从他的规范的。<br>springDataJpa 是对 repository 的封装,简化了 repository 的操作</p><h2 id="第四"><a href="#第四" class="headerlink" title="第四"></a>第四</h2><ul><li>数据分析型的OLAP应用适合用MyBatis，事务处理型OLTP应用适合用JPA。</li><li>越是复杂的业务，越需要领域建模，建模用JPA实现最方便灵活。但是JPA想用好，门槛比较高，不懂DDD的话，就会沦为增删改查了。</li><li>复杂的查询应该是通过CQRS模式，通过异步队列建立合适查询的视图，通过视图避免复杂的Join，而不是直接查询领域模型。</li><li>从目前的趋势来看OLAP交给NoSQL数据库可能更合适</li></ul><h2 id="第五"><a href="#第五" class="headerlink" title="第五"></a>第五</h2><p>使用了一段时间jpa，而mybatis是之前一直在用的，不说区别是啥，因为有很多人比较这两个框架了！<br>从国内开源的应用框架来看，国内使用jpa做orm的人还是比较少，如果换成hibernate还会多一些，所以面临的风险可能就是你会用，和你合作的人不一定会用，如果要多方协作，肯定要考虑这个问题！<br>灵活性方面，jpa更灵活，包括基本的增删改查、数据关系以及数据库的切换上都比mybatis灵活，但是jpa门槛较高，另外就是更新数据需要先将数据查出来才能进行更新，数据量大的时候，jpa效率会低一些，这时候需要做一些额外的工作去处理！<br>现在结合Springboot有Springdata jpa给到，很多东西都简化了，感兴趣并且有能力可以考虑在公司内部和圈子里推广！我的博客里有一些简单使用jpa的示例，<a href="https://github.com/icnws/spring-data-jpa-demo" target="_blank" rel="noopener">https://github.com/icnws/spring-data-jpa-demo</a></p><h2 id="第六"><a href="#第六" class="headerlink" title="第六"></a>第六</h2><p>1.相对来说，jpa的学习成本比mybatis略高<br>2.公司业务需求频繁变更导致表结构复杂，此处使用mybatis比jpa更灵活<br>3.就方言来讲，一般公司选定数据库后再变更微乎其微，所以此处方言的优势可以忽略</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
            <tag> jpa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyBatis拦截器原理探究</title>
      <link href="/2018/10/08/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/10/08/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><div class="note info no-icon"><p>作者：丶Format<br>来源：<a href="http://fangjian0423.github.io/" target="_blank" rel="noopener">http://fangjian0423.github.io/</a><br></p></div><h2 id="MyBatis拦截器介绍"><a href="#MyBatis拦截器介绍" class="headerlink" title="MyBatis拦截器介绍"></a>MyBatis拦截器介绍</h2><p>MyBatis提供了一种插件(plugin)的功能，虽然叫做插件，但其实这是拦截器功能。那么拦截器拦截MyBatis中的哪些内容呢？</p><p>我们进入<a href="http://mybatis.github.io/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">官网</a>看一看：</p><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ol><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ol><p>我们看到了可以拦截Executor接口的部分方法，比如update，query，commit，rollback等方法，还有其他接口的一些方法等。</p><p>总体概括为：</p><ol><li>拦截执行器的方法</li><li>拦截参数的处理</li><li>拦截结果集的处理</li><li>拦截Sql语法构建的处理</li></ol><h2 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h2><h3 id="拦截器介绍及配置"><a href="#拦截器介绍及配置" class="headerlink" title="拦截器介绍及配置"></a>拦截器介绍及配置</h3><p>首先我们看下MyBatis拦截器的接口定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">     <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">     <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>比较简单，只有3个方法。 MyBatis默认没有一个拦截器接口的实现类，开发者们可以实现符合自己需求的拦截器。</p><p>下面的MyBatis官网的一个拦截器实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">     type= Executor.class,</span><br><span class="line">     method = <span class="string">"update"</span>,</span><br><span class="line">     args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>全局xml配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.format.mybatis.cache.interceptor.ExamplePlugin"</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个拦截器拦截Executor接口的update方法（其实也就是SqlSession的新增，删除，修改操作），所有执行executor的update方法都会被该拦截器拦截到。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>下面我们分析一下这段代码背后的源码。</p><p>首先从源头-&gt;配置文件开始分析：</p><p>XMLConfigBuilder解析MyBatis全局配置文件的pluginElement私有方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">        Properties properties = child.getChildrenAsProperties();</span><br><span class="line">        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">        configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体的解析代码其实比较简单，就不贴了，主要就是通过反射实例化plugin节点中的interceptor属性表示的类。然后调用全局配置类Configuration的addInterceptor方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">   interceptorChain.addInterceptor(interceptor);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这个interceptorChain是Configuration的内部属性，类型为InterceptorChain，也就是一个拦截器链，我们来看下它的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">         target = interceptor.plugin(target);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">       interceptors.add(interceptor);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们理解了拦截器配置的解析以及拦截器的归属，现在我们回过头看下为何拦截器会拦截这些方法（Executor，ParameterHandler，ResultSetHandler，StatementHandler的部分方法）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">       parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">       <span class="keyword">return</span> parameterHandler;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">     ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">       resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">       <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">       statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">       <span class="keyword">return</span> statementHandler;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">       executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">       executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">       Executor executor;</span><br><span class="line">       <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">         executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">         executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">         executor = <span class="keyword">new</span> CachingExecutor(executor, autoCommit);</span><br><span class="line">       &#125;</span><br><span class="line">       executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">       <span class="keyword">return</span> executor;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>以上4个方法都是Configuration的方法。这些方法在MyBatis的一个操作(新增，删除，修改，查询)中都会被执行到，执行的先后顺序是Executor，ParameterHandler，ResultSetHandler，StatementHandler(其中ParameterHandler和ResultSetHandler的创建是在创建StatementHandler[3个可用的实现类CallableStatementHandler,PreparedStatementHandler,SimpleStatementHandler]的时候，其构造函数调用的[这3个实现类的构造函数其实都调用了父类BaseStatementHandler的构造函数])。</p><p>这4个方法实例化了对应的对象之后，都会调用interceptorChain的pluginAll方法，InterceptorChain的pluginAll刚才已经介绍过了，就是遍历所有的拦截器，然后调用各个拦截器的plugin方法。<strong>注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象</strong></p><p>由于可以拦截StatementHandler，这个接口主要处理sql语法的构建，因此比如分页的功能，可以用拦截器实现，只需要在拦截器的plugin方法中处理StatementHandler接口实现类中的sql即可，可使用反射实现。</p><p>MyBatis还提供了@Intercepts和@Signature关于拦截器的注解。官网的例子就是使用了这2个注解，还包括了Plugin类的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>下面我们就分析这3个 “新组合” 的源码，首先先看Plugin类的wrap方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">       Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">       Class&lt;?&gt; type = target.getClass();</span><br><span class="line">       Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">       <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">             type.getClassLoader(),</span><br><span class="line">             interfaces,</span><br><span class="line">             <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Plugin类实现了InvocationHandler接口，很明显，我们看到这里返回了一个JDK自身提供的动态代理类。我们解剖一下这个方法调用的其他方法：</p><p>getSignatureMap方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">       Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">       <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123; <span class="comment">// issue #251</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"No @Intercepts annotation was found in interceptor "</span> + interceptor.getClass().getName());      </span><br><span class="line">       &#125;</span><br><span class="line">       Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">       Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">         Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">         <span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">           methods = <span class="keyword">new</span> HashSet&lt;Method&gt;();</span><br><span class="line">           signatureMap.put(sig.type(), methods);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">           methods.add(method);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"Could not find method on "</span> + sig.type() + <span class="string">" named "</span> + sig.method() + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> signatureMap;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>getSignatureMap方法解释：首先会拿到拦截器这个类的@Interceptors注解，然后拿到这个注解的属性@Signature注解集合，然后遍历这个集合，遍历的时候拿出@Signature注解的type属性(Class类型)，然后根据这个type得到带有method属性和args属性的Method。由于@Interceptors注解的@Signature属性是一个属性，所以最终会返回一个以type为key，value为Set&lt;Method&gt;的Map。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">     type= Executor.class,</span><br><span class="line">     method = <span class="string">"update"</span>,</span><br><span class="line">     args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br></pre></td></tr></table></figure></p><p>比如这个@Interceptors注解会返回一个key为Executor，value为集合(这个集合只有一个元素，也就是Method实例，这个Method实例就是Executor接口的update方法，且这个方法带有MappedStatement和Object类型的参数)。这个Method实例是根据@Signature的method和args属性得到的。如果args参数跟type类型的method方法对应不上，那么将会抛出异常。</p><p>getAllInterfaces方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">       Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">             interfaces.add(c);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         type = type.getSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>getAllInterfaces方法解释：根据目标实例target(这个target就是之前所说的MyBatis拦截器可以拦截的类，Executor,ParameterHandler,ResultSetHandler,StatementHandler)和它的父类们，返回signatureMap中含有target实现的接口数组。</p><p>所以Plugin这个类的作用就是根据@Interceptors注解，得到这个注解的属性@Signature数组，然后根据每个@Signature注解的type，method，args属性使用反射找到对应的Method。最终根据调用的target对象实现的接口决定是否返回一个代理对象替代原先的target对象。</p><p>比如MyBatis官网的例子，当Configuration调用newExecutor方法的时候，由于Executor接口的update(MappedStatement ms, Object parameter)方法被拦截器被截获。因此最终返回的是一个代理类Plugin，而不是Executor。这样调用方法的时候，如果是个代理类，那么会执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>没错，如果找到对应的方法被代理之后，那么会执行Interceptor接口的interceptor方法。</p><p>这个Invocation类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> Method method;</span><br><span class="line">  <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Invocation</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object[] getArgs() &#123;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的proceed方法也就是调用原先方法(不走代理)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MyBatis拦截器接口提供的3个方法中，plugin方法用于某些处理器(Handler)的构建过程。interceptor方法用于处理代理类的执行。setProperties方法用于拦截器属性的设置。</p><p>其实MyBatis官网提供的使用@Interceptors和@Signature注解以及Plugin类这样处理拦截器的方法，我们不一定要直接这样使用。我们也可以抛弃这3个类，直接在plugin方法内部根据target实例的类型做相应的操作。</p><p>总体来说MyBatis拦截器还是很简单的，拦截器本身不需要太多的知识点，但是学习拦截器需要对MyBatis中的各个接口很熟悉，因为拦截器涉及到了各个接口的知识点。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyBatis动态SQL底层原理分析</title>
      <link href="/2018/10/08/MyBatis%E5%8A%A8%E6%80%81SQL%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2018/10/08/MyBatis%E5%8A%A8%E6%80%81SQL%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><div class="note info no-icon"><p>作者：丶Format<br>来源：<a href="http://fangjian0423.github.io/" target="_blank" rel="noopener">http://fangjian0423.github.io/</a><br></p></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>废话不多说，直接进入文章。<br>我们在使用mybatis的时候，会在xml中编写sql语句。<br>比如这段动态sql代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"org.format.dynamicproxy.mybatis.bean.User"</span>&gt;</span></span><br><span class="line">       UPDATE users</span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">prefixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></span><br><span class="line">               name = #&#123;name&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null and age != ''"</span>&gt;</span></span><br><span class="line">               , age = #&#123;age&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null and birthday != ''"</span>&gt;</span></span><br><span class="line">               , birthday = #&#123;birthday&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">       where id = $&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>mybatis底层是如何构造这段sql的？<br>这方面的知识网上资料不多，于是就写了这么一篇文章。<br>下面带着这个疑问，我们一步一步分析。</p><h2 id="介绍MyBatis中一些关于动态SQL的接口和类"><a href="#介绍MyBatis中一些关于动态SQL的接口和类" class="headerlink" title="介绍MyBatis中一些关于动态SQL的接口和类"></a>介绍MyBatis中一些关于动态SQL的接口和类</h2><p><strong>SqlNode接口</strong>，简单理解就是xml中的每个标签，比如上述sql的update,trim,if标签：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql2.png" alt=""></p><p><strong>SqlSource Sql源接口</strong>，代表从xml文件或注解映射的sql内容，主要就是用于创建BoundSql，有实现类DynamicSqlSource(动态Sql源)，StaticSqlSource(静态Sql源)等：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql3.png" alt=""></p><p><strong>BoundSql类</strong>，封装mybatis最终产生sql的类，包括sql语句，参数，参数源数据等参数：</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql1.png" alt=""></p><p><strong>XNode</strong>，一个Dom API中的Node接口的扩展类。</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql6.png" alt=""></p><p><strong>BaseBuilder接口及其实现类</strong>(属性，方法省略了，大家有兴趣的自己看),这些Builder的作用就是用于构造sql:</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql4.png" alt=""></p><p>下面我们简单分析下其中4个Builder：</p><p>1 XMLConfigBuilder</p><p>解析mybatis中configLocation属性中的全局xml文件，内部会使用XMLMapperBuilder解析各个xml文件。</p><p>2 XMLMapperBuilder</p><p>遍历mybatis中mapperLocations属性中的xml文件中每个节点的Builder，比如user.xml，内部会使用XMLStatementBuilder处理xml中的每个节点。</p><p>3 XMLStatementBuilder</p><p>解析xml文件中各个节点，比如select,insert,update,delete节点，内部会使用XMLScriptBuilder处理节点的sql部分，遍历产生的数据会丢到Configuration的mappedStatements中。</p><p>4 XMLScriptBuilder</p><p>解析xml中各个节点sql部分的Builder。</p><p><strong>LanguageDriver接口及其实现类</strong>(属性，方法省略了，大家有兴趣的自己看)，该接口主要的作用就是构造sql:</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql5.png" alt=""></p><p>简单分析下XMLLanguageDriver(处理xml中的sql，RawLanguageDriver处理静态sql)：</p><p>XMLLanguageDriver内部会使用XMLScriptBuilder解析xml中的sql部分。</p><p>ok， 大部分比较重要的类我们都已经介绍了，下面源码分析走起。</p><h2 id="源码分析走起"><a href="#源码分析走起" class="headerlink" title="源码分析走起"></a>源码分析走起</h2><p>Spring与Mybatis整合的时候需要配置SqlSessionFactoryBean，该配置会加入数据源和mybatis xml配置文件路径等信息：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatisConfig.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath*:org/format/dao/*.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们就分析这一段配置背后的细节：</p><p>SqlSessionFactoryBean实现了Spring的InitializingBean接口，InitializingBean接口的afterPropertiesSet方法中会调用buildSqlSessionFactory方法</p><p>buildSqlSessionFactory方法内部会使用XMLConfigBuilder解析属性configLocation中配置的路径，还会使用XMLMapperBuilder属性解析mapperLocations属性中的各个xml文件。</p><p>部分源码如下：</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql7.png" alt=""></p><p>由于XMLConfigBuilder内部也是使用XMLMapperBuilder，我们就看看XMLMapperBuilder的解析细节。</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql8.png" alt=""></p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql9.png" alt=""></p><p>我们关注一下，增删改查节点的解析。</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql10.png" alt=""></p><p>XMLStatementBuilder的解析：</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql11.png" alt=""></p><p>默认会使用XMLLanguageDriver创建SqlSource（Configuration构造函数中设置）。</p><p>XMLLanguageDriver创建SqlSource：</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql12.png" alt=""></p><p>XMLScriptBuilder解析sql：</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql13.png" alt=""></p><p>得到SqlSource之后，会放到Configuration中，有了SqlSource，就能拿BoundSql了，BoundSql可以得到最终的sql。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>我以以下xml的解析大概说下parseDynamicTags的解析过程：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"org.format.dynamicproxy.mybatis.bean.User"</span>&gt;</span></span><br><span class="line">       UPDATE users</span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">prefixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></span><br><span class="line">               name = #&#123;name&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null and age != ''"</span>&gt;</span></span><br><span class="line">               , age = #&#123;age&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null and birthday != ''"</span>&gt;</span></span><br><span class="line">               , birthday = #&#123;birthday&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">       where id = $&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在看这段解析之前，请先了解dom相关的知识，<a href="http://www.w3school.com.cn/xmldom/index.asp" target="_blank" rel="noopener">xml dom知识</a>, <a href="http://www.cnblogs.com/fangjian0423/p/dom-parse-xml-html.html" target="_blank" rel="noopener">dom博文</a></p><p>parseDynamicTags方法的返回值是一个List<sqlnode>，也就是一个Sql节点集合。SqlNode本文一开始已经介绍，分析完解析过程之后会说一下各个SqlNode类型的作用。</sqlnode></p><p>1 首先根据update节点(Node)得到所有的子节点，分别是3个子节点</p><p> (1)文本节点   \n   UPDATE users</p><p> (2)trim子节点 <trim>…</trim></p><p> (3)文本节点  \n    where id = #{id}</p><p>2 遍历各个子节点</p><p> (1) 如果节点类型是文本或者CDATA，构造一个TextSqlNode或StaticTextSqlNode</p><p> (2) 如果节点类型是元素，说明该update节点是个动态sql，然后会使用NodeHandler处理各个类型的子节点。这里的NodeHandler是XMLScriptBuilder的一个内部接口，其实现类包括TrimHandler、WhereHandler、SetHandler、IfHandler、ChooseHandler等。看类名也就明白了这个Handler的作用，比如我们分析的trim节点，对应的是TrimHandler；if节点，对应的是IfHandler… </p><p> 这里子节点trim被TrimHandler处理，TrimHandler内部也使用parseDynamicTags方法解析节点</p><p>3 遇到子节点是元素的话，重复以上步骤</p><p>  trim子节点内部有7个子节点，分别是文本节点、if节点、是文本节点、if节点、是文本节点、if节点、文本节点。文本节点跟之前一样处理，if节点使用IfHandler处理</p><p>遍历步骤如上所示，下面我们看下几个Handler的实现细节。</p><p>IfHandler处理方法也是使用parseDynamicTags方法，然后加上if标签必要的属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IfHandler</span> <span class="keyword">implements</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;</span><br><span class="line">      List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle);</span><br><span class="line">      MixedSqlNode mixedSqlNode = <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">      String test = nodeToHandle.getStringAttribute(<span class="string">"test"</span>);</span><br><span class="line">      IfSqlNode ifSqlNode = <span class="keyword">new</span> IfSqlNode(mixedSqlNode, test);</span><br><span class="line">      targetContents.add(ifSqlNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TrimHandler处理方法也是使用parseDynamicTags方法，然后加上trim标签必要的属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrimHandler</span> <span class="keyword">implements</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;</span><br><span class="line">      List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle);</span><br><span class="line">      MixedSqlNode mixedSqlNode = <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">      String prefix = nodeToHandle.getStringAttribute(<span class="string">"prefix"</span>);</span><br><span class="line">      String prefixOverrides = nodeToHandle.getStringAttribute(<span class="string">"prefixOverrides"</span>);</span><br><span class="line">      String suffix = nodeToHandle.getStringAttribute(<span class="string">"suffix"</span>);</span><br><span class="line">      String suffixOverrides = nodeToHandle.getStringAttribute(<span class="string">"suffixOverrides"</span>);</span><br><span class="line">      TrimSqlNode trim = <span class="keyword">new</span> TrimSqlNode(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides);</span><br><span class="line">      targetContents.add(trim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上update方法最终通过parseDynamicTags方法得到的SqlNode集合如下：</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql14.png" alt=""></p><p>trim节点：</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql15.png" alt=""></p><p>由于这个update方法是个动态节点，因此构造出了DynamicSqlSource。</p><p>DynamicSqlSource内部就可以构造sql了:</p><p><img src="http://format-blog-image.qiniudn.com/dynamicsql16.png" alt=""></p><p>DynamicSqlSource内部的SqlNode属性是一个MixedSqlNode。</p><p>然后我们看看各个SqlNode实现类的apply方法</p><p>下面分析一下两个SqlNode实现类的apply方法实现：</p><p>MixedSqlNode：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (SqlNode sqlNode : contents) &#123;</span><br><span class="line">      sqlNode.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MixedSqlNode会遍历调用内部各个sqlNode的apply方法。</p><p>StaticTextSqlNode:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    context.appendSql(text);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接append sql文本。</p><p>IfSqlNode:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">      contents.apply(context);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的evaluator是一个ExpressionEvaluator类型的实例，内部使用了OGNL处理表达式逻辑。</p><p>TrimSqlNode:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    FilteredDynamicContext filteredDynamicContext = <span class="keyword">new</span> FilteredDynamicContext(context);</span><br><span class="line">    <span class="keyword">boolean</span> result = contents.apply(filteredDynamicContext);</span><br><span class="line">    filteredDynamicContext.applyAll();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sqlBuffer = <span class="keyword">new</span> StringBuilder(sqlBuffer.toString().trim());</span><br><span class="line">     String trimmedUppercaseSql = sqlBuffer.toString().toUpperCase(Locale.ENGLISH);</span><br><span class="line">     <span class="keyword">if</span> (trimmedUppercaseSql.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       applyPrefix(sqlBuffer, trimmedUppercaseSql);</span><br><span class="line">       applySuffix(sqlBuffer, trimmedUppercaseSql);</span><br><span class="line">     &#125;</span><br><span class="line">     delegate.appendSql(sqlBuffer.toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPrefix</span><span class="params">(StringBuilder sql, String trimmedUppercaseSql)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!prefixApplied) &#123;</span><br><span class="line">       prefixApplied = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (prefixesToOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (String toRemove : prefixesToOverride) &#123;</span><br><span class="line">           <span class="keyword">if</span> (trimmedUppercaseSql.startsWith(toRemove)) &#123;</span><br><span class="line">             sql.delete(<span class="number">0</span>, toRemove.trim().length());</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">         sql.insert(<span class="number">0</span>, <span class="string">" "</span>);</span><br><span class="line">         sql.insert(<span class="number">0</span>, prefix);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>TrimSqlNode的apply方法也是调用属性contents(一般都是MixedSqlNode)的apply方法，按照实例也就是7个SqlNode，都是StaticTextSqlNode和IfSqlNode。 最后会使用FilteredDynamicContext过滤掉prefix和suffix。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大致讲解了一下mybatis对动态sql语句的解析过程，其实回过头来看看不算复杂，还算蛮简单的。 之前接触mybaits的时候遇到刚才分析的那一段动态sql的时候总是很费解。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"org.format.dynamicproxy.mybatis.bean.User"</span>&gt;</span></span><br><span class="line">       UPDATE users</span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">prefixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></span><br><span class="line">               name = #&#123;name&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null and age != ''"</span>&gt;</span></span><br><span class="line">               , age = #&#123;age&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null and birthday != ''"</span>&gt;</span></span><br><span class="line">               , birthday = #&#123;birthday&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">       where id = $&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>想搞明白这个trim节点的prefixOverrides到底是什么意思(从字面上理解就是前缀覆盖)，而且官方文档上也没这方面知识的说明。我将这段xml改成如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"org.format.dynamicproxy.mybatis.bean.User"</span>&gt;</span></span><br><span class="line">       UPDATE users</span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">prefixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></span><br><span class="line">               , name = #&#123;name&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null and age != ''"</span>&gt;</span></span><br><span class="line">               , age = #&#123;age&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null and birthday != ''"</span>&gt;</span></span><br><span class="line">               , birthday = #&#123;birthday&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">       where id = $&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>(第二段第一个if节点多了个逗号)  结果我发现这2段xml解析的结果是一样的，非常迫切地想知道这到底是为什么，然后这也促使了我去看源码的决心。最终还是看下来了。</p><p>文章有点长，而且讲的也不是非常直观，希望对有些人有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过源码分析MyBatis的缓存</title>
      <link href="/2018/10/08/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90MyBatis%E7%9A%84%E7%BC%93%E5%AD%98/"/>
      <url>/2018/10/08/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90MyBatis%E7%9A%84%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><div class="note info no-icon"><p>作者：丶Format<br>来源：<a href="http://fangjian0423.github.io/" target="_blank" rel="noopener">http://fangjian0423.github.io/</a><br></p></div><p>前方高能！ 本文内容有点多，通过实际测试例子+源码分析的方式解剖MyBatis缓存的概念，对这方面有兴趣的小伙伴请继续看下去~</p><h2 id="MyBatis缓存介绍"><a href="#MyBatis缓存介绍" class="headerlink" title="MyBatis缓存介绍"></a>MyBatis缓存介绍</h2><p>首先看一段<a href="http://zh.wikipedia.org/wiki/MyBatis" target="_blank" rel="noopener">wiki</a>上关于MyBatis缓存的介绍：</p><p>MyBatis支持声明式数据缓存（declarative data caching）。当一条SQL语句被标记为“可缓存”后，首次执行它时从数据库获取的所有数据会被存储在一段高速缓存中，今后执行这条语句时就会从高速缓存中读取结果，而不是再次命中数据库。MyBatis提供了默认下基于Java HashMap的缓存实现，以及用于与OSCache、Ehcache、Hazelcast和Memcached连接的默认连接器。MyBatis还提供API供其他缓存实现使用。</p><p>重点的那句话就是：<strong>MyBatis执行SQL语句之后，这条语句就是被缓存，以后再执行这条语句的时候，会直接从缓存中拿结果，而不是再次执行SQL</strong></p><p>这也就是大家常说的MyBatis一级缓存，一级缓存的作用域scope是SqlSession。</p><p>MyBatis同时还提供了一种全局作用域global scope的缓存，这也叫做二级缓存，也称作全局缓存。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>同个session进行两次相同查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        User user = (User)sqlSession.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(user);</span><br><span class="line">        User user2 = (User)sqlSession.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(user2);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis只进行1次数据库查询：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br></pre></td></tr></table></figure><p>同个session进行两次不同的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        User user = (User)sqlSession.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(user);</span><br><span class="line">        User user2 = (User)sqlSession.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">2</span>);</span><br><span class="line">        log.debug(user2);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis进行两次数据库查询：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 2(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=2, <span class="attribute">name</span>=<span class="string">'FFF'</span>, <span class="attribute">age</span>=50, <span class="attribute">birthday</span>=Sat Dec 06 17:12:01 CST 2014&#125;</span><br></pre></td></tr></table></figure><p>不同session，进行相同查询： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        User user = (User)sqlSession.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(user);</span><br><span class="line">        User user2 = (User)sqlSession2.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(user2);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis进行了两次数据库查询：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br></pre></td></tr></table></figure><p>同个session,查询之后更新数据，再次查询相同的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        User user = (User)sqlSession.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(user);</span><br><span class="line">        user.setAge(<span class="number">100</span>);</span><br><span class="line">        sqlSession.update(<span class="string">"org.format.mybatis.cache.UserMapper.update"</span>, user);</span><br><span class="line">        User user2 = (User)sqlSession.selectOne(<span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(user2);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新操作之后缓存会被清除：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br><span class="line">==&gt;  Preparing: update<span class="built_in"> USERS </span><span class="builtin-name">SET</span> NAME = ? , AGE = ? , BIRTHDAY = ? where ID = ? </span><br><span class="line">==&gt; Parameters: format(String), 23(Integer), 2014-10-12 23:20:13.0(Timestamp), 1(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br></pre></td></tr></table></figure><p>很明显，结果验证了一级缓存的概念，<strong>在同个SqlSession中，查询语句相同的sql会被缓存，但是一旦执行新增或更新或删除操作，缓存就会被清除</strong></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在分析MyBatis的一级缓存之前，我们先简单看下MyBatis中几个重要的类和接口：</p><p>org.apache.ibatis.session.Configuration类：MyBatis全局配置信息类</p><p>org.apache.ibatis.session.SqlSessionFactory接口：操作SqlSession的工厂接口，具体的实现类是DefaultSqlSessionFactory</p><p>org.apache.ibatis.session.SqlSession接口：执行sql，管理事务的接口，具体的实现类是DefaultSqlSession</p><p>org.apache.ibatis.executor.Executor接口：sql执行器，SqlSession执行sql最终是通过该接口实现的，常用的实现类有SimpleExecutor和CachingExecutor,这些实现类都使用了<a href="http://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">装饰者设计模式</a></p><p>一级缓存的作用域是SqlSession，那么我们就先看一下SqlSession的select过程：</p><p>这是DefaultSqlSession（SqlSession接口实现类，MyBatis默认使用这个类）的selectList源码（我们例子上使用的是selectOne方法，调用selectOne方法最终会执行selectList方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到SqlSession最终会调用Executor接口的方法。</p><p>接下来我们看下DefaultSqlSession中的executor接口属性具体是哪个实现类。</p><p>DefaultSqlSession的构造过程（DefaultSqlSessionFactory内部）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType, autoCommit);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到DefaultSqlSessionFactory构造DefaultSqlSession的时候，Executor接口的实现类是由Configuration构造的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor根据ExecutorType的不同而创建，最常用的是SimpleExecutor，本文的例子也是创建这个实现类。 最后我们发现如果cacheEnabled这个属性为true的话，那么executor会被包一层装饰器，这个装饰器是CachingExecutor。其中cacheEnabled这个属性是mybatis总配置文件中settings节点中cacheEnabled子节点的值，默认就是true，也就是说我们在mybatis总配置文件中不配cacheEnabled的话，它也是默认为打开的。</p><p>现在，问题就剩下一个了，<strong>CachingExecutor执行sql的时候到底做了什么？</strong></p><p>带着这个问题，我们继续走下去（CachingExecutor的query方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123; </span><br><span class="line">        ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">        <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">          cache.getReadWriteLock().readLock().lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            List&lt;E&gt; cachedList = (List&lt;E&gt;) cache.getObject(key);</span><br><span class="line">            <span class="keyword">if</span> (cachedList != <span class="keyword">null</span>) <span class="keyword">return</span> cachedList;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cache.getReadWriteLock().readLock().unlock();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;E&gt; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578. Query must be not synchronized to prevent deadlocks</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Cache cache = ms.getCache();这句代码中，这个cache实际上就是个二级缓存，由于我们没有开启二级缓存(二级缓存的内容下面会分析)，因此这里执行了最后一句话。这里的delegate也就是SimpleExecutor,SimpleExecutor没有Override父类的query方法，因此最终执行了SimpleExecutor的父类BaseExecutor的query方法。</p><p><strong>所以一级缓存最重要的代码就是BaseExecutor的query方法!</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/o_mybatis_cache01.jpg" alt="">    </p><p><strong>BaseExecutor的属性localCache是个PerpetualCache类型的实例，PerpetualCache类是实现了MyBatis的Cache缓存接口的实现类之一，内部有个Map&lt;Object, Object&gt;类型的属性用来存储缓存数据。 这个localCache的类型在BaseExecutor内部是写死的。 这个localCache就是一级缓存！</strong></p><p>接下来我们看下<strong>为何执行新增或更新或删除操作，一级缓存就会被清除</strong>这个问题。</p><p>首先MyBatis处理新增或删除的时候，最终都是调用update方法，也就是说<strong>新增或者删除操作在MyBatis眼里都是一个更新操作。</strong></p><p>我们看下DefaultSqlSession的update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      dirty = <span class="keyword">true</span>;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.update(ms, wrapCollection(parameter));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error updating database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这里调用了CachingExecutor的update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的flushCacheIfRequired方法清除的是二级缓存，我们之后会分析。 CachingExecutor委托给了(之前已经分析过)SimpleExecutor的update方法，SimpleExecutor没有Override父类BaseExecutor的update方法，因此我们看BaseExecutor的update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了关键的一句代码： clearLocalCache();  进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">      localCache.clear();</span><br><span class="line">      localOutputParameterCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就是这条，<strong>sqlsession没有关闭的话，进行新增、删除、修改操作的话就是清除一级缓存，也就是SqlSession的缓存。</strong></p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存的作用域是全局，换句话说，二级缓存已经脱离SqlSession的控制了。</p><p>在测试二级缓存之前，我先把结论说一下：</p><p><strong>二级缓存的作用域是全局的，二级缓存在SqlSession关闭或提交之后才会生效。</strong></p><p>在分析MyBatis的二级缓存之前，我们先简单看下MyBatis中一个关于二级缓存的类(其他相关的类和接口之前已经分析过)：</p><p>org.apache.ibatis.mapping.MappedStatement：</p><p>MappedStatement类在Mybatis框架中用于表示XML文件中一个sql语句节点，即一个&lt;select /&gt;、&lt;update /&gt;或者&lt;insert /&gt;标签。Mybatis框架在初始化阶段会对XML配置文件进行读取，将其中的sql语句节点对象化为一个个MappedStatement对象。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>二级缓存跟一级缓存不同，一级缓存不需要配置任何东西，且默认打开。 二级缓存就需要配置一些东西。</p><p>本文就说下最简单的配置，在mapper文件上加上这句配置即可：</p><pre><code>&lt;cache/&gt;</code></pre><p>其实二级缓存跟3个配置有关：</p><ol><li>mybatis全局配置文件中的setting中的cacheEnabled需要为true(默认为true，不设置也行)</li><li>mapper配置文件中需要加入&lt;cache&gt;节点</li><li>mapper配置文件中的select节点需要加上属性useCache需要为true(默认为true，不设置也行)</li></ol><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>不同SqlSession，查询相同语句，第一次查询之后commit SqlSession：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>;</span><br><span class="line">        User user = (User)sqlSession.selectOne(sql, <span class="number">1</span>);</span><br><span class="line">        log.debug(user);</span><br><span class="line">        <span class="comment">// 注意，这里一定要提交。 不提交还是会查询两次数据库</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        User user2 = (User)sqlSession2.selectOne(sql, <span class="number">1</span>);</span><br><span class="line">        log.debug(user2);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis仅进行了一次数据库查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * from USERS WHERE ID = ? </span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'format'</span>, age=<span class="number">23</span>, birthday=Sun Oct <span class="number">12</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">13</span> CST <span class="number">2014</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'format'</span>, age=<span class="number">23</span>, birthday=Sun Oct <span class="number">12</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">13</span> CST <span class="number">2014</span>&#125;</span><br></pre></td></tr></table></figure><p>不同SqlSession，查询相同语句，第一次查询之后close SqlSession：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>;</span><br><span class="line">        User user = (User)sqlSession.selectOne(sql, <span class="number">1</span>);</span><br><span class="line">        log.debug(user);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        User user2 = (User)sqlSession2.selectOne(sql, <span class="number">1</span>);</span><br><span class="line">        log.debug(user2);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis仅进行了一次数据库查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * from USERS WHERE ID = ? </span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'format'</span>, age=<span class="number">23</span>, birthday=Sun Oct <span class="number">12</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">13</span> CST <span class="number">2014</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'format'</span>, age=<span class="number">23</span>, birthday=Sun Oct <span class="number">12</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">13</span> CST <span class="number">2014</span>&#125;</span><br></pre></td></tr></table></figure><p>不同SqlSesson，查询相同语句。 第一次查询之后SqlSession不提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">"org.format.mybatis.cache.UserMapper.getById"</span>;</span><br><span class="line">        User user = (User)sqlSession.selectOne(sql, <span class="number">1</span>);</span><br><span class="line">        log.debug(user);</span><br><span class="line">        User user2 = (User)sqlSession2.selectOne(sql, <span class="number">1</span>);</span><br><span class="line">        log.debug(user2);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis执行了两次数据库查询：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br><span class="line">==&gt;  Preparing: select * <span class="keyword">from</span><span class="built_in"> USERS </span>WHERE ID = ? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">'format'</span>, <span class="attribute">age</span>=23, <span class="attribute">birthday</span>=Sun Oct 12 23:20:13 CST 2014&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>我们从在mapper文件中加入的&lt;cache/&gt;中开始分析源码，关于MyBatis的SQL解析请参考另外一篇博客<a href="/2018/10/08/MyBatis动态SQL底层原理分析">Mybatis解析动态sql原理分析</a>。接下来我们看下这个cache的解析：</p><p>XMLMappedBuilder（解析每个mapper配置文件的解析类，每一个mapper配置都会实例化一个XMLMapperBuilder类）的解析方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">      <span class="keyword">if</span> (namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">      cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">      cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">      parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">      resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">      sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了解析cache的那段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String type = context.getStringAttribute(<span class="string">"type"</span>, <span class="string">"PERPETUAL"</span>);</span><br><span class="line">      Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">      String eviction = context.getStringAttribute(<span class="string">"eviction"</span>, <span class="string">"LRU"</span>);</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">      Long flushInterval = context.getLongAttribute(<span class="string">"flushInterval"</span>);</span><br><span class="line">      Integer size = context.getIntAttribute(<span class="string">"size"</span>);</span><br><span class="line">      <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">"readOnly"</span>, <span class="keyword">false</span>);</span><br><span class="line">      Properties props = context.getChildrenAsProperties();</span><br><span class="line">      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析完cache标签之后会使用builderAssistant的userNewCache方法，这里的builderAssistant是一个MapperBuilderAssistant类型的帮助类，每个XMLMappedBuilder构造的时候都会实例化这个属性，MapperBuilderAssistant类内部有个Cache类型的currentCache属性，这个属性也就是mapper配置文件中cache节点所代表的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="function"><span class="params">     Long flushInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">     Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">     Properties props)</span> </span>&#123;</span><br><span class="line">       typeClass = valueOrDefault(typeClass, PerpetualCache.class);</span><br><span class="line">       evictionClass = valueOrDefault(evictionClass, LruCache.class);</span><br><span class="line">       Cache cache = <span class="keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">           .implementation(typeClass)</span><br><span class="line">           .addDecorator(evictionClass)</span><br><span class="line">           .clearInterval(flushInterval)</span><br><span class="line">           .size(size)</span><br><span class="line">           .readWrite(readWrite)</span><br><span class="line">           .properties(props)</span><br><span class="line">           .build();</span><br><span class="line">       configuration.addCache(cache);</span><br><span class="line">       currentCache = cache;</span><br><span class="line">       <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ok，现在mapper配置文件中的cache节点被解析到了XMLMapperBuilder实例中的builderAssistant属性中的currentCache值里。</p><p>接下来XMLMapperBuilder会解析select节点，解析select节点的时候使用XMLStatementBuilder进行解析(也包括其他insert，update，delete节点)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? <span class="keyword">new</span> Jdbc3KeyGenerator() : <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码前面都是解析一些标签的属性，我们看到了最后一行使用builderAssistant添加MappedStatement，其中builderAssistant属性是构造XMLStatementBuilder的时候通过XMLMappedBuilder传入的，我们继续看builderAssistant的addMappedStatement方法：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/o_mybatis_cache02.jpg" alt="">    </p><p>进入setStatementCache：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setStatementCache</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isSelect,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="function"><span class="params">     Cache cache,</span></span></span><br><span class="line"><span class="function"><span class="params">     MappedStatement.Builder statementBuilder)</span> </span>&#123;</span><br><span class="line">    flushCache = valueOrDefault(flushCache, !isSelect);</span><br><span class="line">    useCache = valueOrDefault(useCache, isSelect);</span><br><span class="line">    statementBuilder.flushCacheRequired(flushCache);</span><br><span class="line">    statementBuilder.useCache(useCache);</span><br><span class="line">    statementBuilder.cache(cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终mapper配置文件中的&lt;cache/&gt;被设置到了XMLMapperBuilder的builderAssistant属性中，XMLMapperBuilder中使用XMLStatementBuilder遍历CRUD节点，遍历CRUD节点的时候将这个cache节点设置到这些CRUD节点中，这个cache就是所谓的二级缓存！</p><p>接下来我们回过头来看查询的源码，CachingExecutor的query方法：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/o_mybatis_cache03.jpg" alt="">    </p><p>进入TransactionalCacheManager的putObject方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">   getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">    <span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">      transactionalCaches.put(cache, txCache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> txCache;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>TransactionalCache的putObject方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    entriesToRemoveOnCommit.remove(key);</span><br><span class="line">    entriesToAddOnCommit.put(key, <span class="keyword">new</span> AddEntry(delegate, key, object));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们看到，数据被加入到了entriesToAddOnCommit中，这个entriesToAddOnCommit是什么东西呢，它是TransactionalCache的一个Map属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Object, AddEntry&gt; entriesToAddOnCommit;</span><br></pre></td></tr></table></figure></p><p>AddEntry是TransactionalCache内部的一个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line">    <span class="keyword">private</span> Object key;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddEntry</span><span class="params">(Cache cache, Object key, Object value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.cache = cache;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      cache.putObject(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，现在我们发现使用二级缓存之后：查询数据的话，先从二级缓存中拿数据，如果没有的话，去一级缓存中拿，一级缓存也没有的话再查询数据库。有了数据之后在丢到TransactionalCache这个对象的entriesToAddOnCommit属性中。</p><p><strong>接下来我们来验证为什么SqlSession commit或close之后，二级缓存才会生效这个问题。</strong></p><p>DefaultSqlSession的commit方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br><span class="line">      dirty = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error committing transaction.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>CachingExecutor的commit方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">    dirty = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>tcm.commit即 TransactionalCacheManager的commit方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>TransactionalCache的commit方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegate.getReadWriteLock().writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (RemoveEntry entry : entriesToRemoveOnCommit.values()) &#123;</span><br><span class="line">          entry.commit();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (AddEntry entry : entriesToAddOnCommit.values()) &#123;</span><br><span class="line">        entry.commit();</span><br><span class="line">      &#125;</span><br><span class="line">      reset();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      delegate.getReadWriteLock().writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>发现调用了AddEntry的commit方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     cache.putObject(key, value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>发现了！ AddEntry的commit方法会把数据丢到cache中，也就是丢到二级缓存中！</p><p>关于为何调用close方法后，二级缓存才会生效，因为close方法内部会调用commit方法。本文就不具体说了。 读者有兴趣的话看一看源码就知道为什么了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Cache接口简介"><a href="#Cache接口简介" class="headerlink" title="Cache接口简介"></a>Cache接口简介</h3><p>org.apache.ibatis.cache.Cache是MyBatis的缓存接口，想要实现自定义的缓存需要实现这个接口。</p><p>MyBatis中关于Cache接口的实现类也使用了装饰者设计模式。</p><p>我们看下它的一些实现类：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/o_mybatis_cache04.jpg" alt="">    </p><p>简单说明：</p><p>LRU – 最近最少使用的:移除最长时间不被使用的对象。</p><p>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以通过cache节点的eviction属性设置，也可以设置其他的属性。</p><h3 id="cache-ref节点"><a href="#cache-ref节点" class="headerlink" title="cache-ref节点"></a>cache-ref节点</h3><p>mapper配置文件中还可以加入cache-ref节点，它有个属性namespace。</p><p>如果每个mapper文件都是用cache-ref，且namespace都一样，那么就代表着真正意义上的全局缓存。</p><p>如果只用了cache节点，那仅代表这个这个mapper内部的查询被缓存了，其他mapper文件的不起作用，这并不是所谓的全局缓存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，MyBatis的源码看起来还是比较轻松的，本文从实践和源码方面深入分析了MyBatis的缓存原理，希望对读者有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>架构设计之「服务限流」</title>
      <link href="/2018/09/30/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E3%80%8C%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E3%80%8D/"/>
      <url>/2018/09/30/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E3%80%8C%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><blockquote class="blockquote-center"><p>&emsp;&emsp;限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p></blockquote><p>&emsp;&emsp;在介绍限流概念之前，我们先来聊聊身边有哪些限流，如果有在帝都的码农估计对限流是最深有感触的，帝都但凡开个XXX会议，各大地铁站都会限流。</p><p>&emsp;&emsp;每年的双11都是剁手族的天堂，11月11号0点0几秒的时候，下面这些场景或许你曾经遇到过。</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/8ujnrf7yh3wed6tg3we.png" alt=""></p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/jhgfd3422fewdvshwgefa.png" alt=""></p><p>当然，这几年双11各大电商对并发的支持做的越来越好，这里只是借鉴双11刚推出之际，常常需要应对的一些问题。</p><p>通过这两个场景，基本上服务限流的作用也就明白：</p><p>「服务限流」其实是指当系统资源不够，不足以应对大量请求，即系统资源与访问量出现矛盾的时候，我们为了保证有限的资源能够正常服务，因此对系统按照预设的规则进行流量限制或功能限制的一种方法。</p><h4 id="一、为什么要做服务限流设计？"><a href="#一、为什么要做服务限流设计？" class="headerlink" title="一、为什么要做服务限流设计？"></a>一、为什么要做服务限流设计？</h4><p>再举一个我们生活中的例子：一些热门的旅游景点，往往会对每日的旅游参观人数有严格的限制，比如厦门的鼓浪屿、北京的故宫等，每天只会卖出固定数目的门票，如果你去的晚了，可能当天的票就已经卖完了，当天就无法进去游玩了。</p><p>为什么旅游景点要做这样的限制呢？多卖一些门票多赚一些钱岂不是更好？</p><p>其实对于旅游景点而言，她们也很无奈，因为景点的服务资源有限嘛，每日能服务的人数是有限的，一旦放开限制了，景点的工作人员就会不够用，卫生情况也得不到保障，安全也有隐患，超密集的人群也会严重的影响游客的体验。<br>但由于景区名气大，来游玩的旅客络绎不绝，远超出了景区的承载能力，因此景区只好做出限制每日人员流量的举措。</p><p>同理，在IT软件行业中，系统服务也是这样的。</p><p>如果你的系统理论是时间单位内可服务100W用户，但是今天却突然来了300W用户，由于用户流量的随机性，如果不加以限流，很有可能这300W用户一下子就压垮了系统，导致所有人都得不到服务。</p><p>因此为了保证系统至少还能为100W用户提供正常服务，我们需要对系统进行限流设计。</p><p>有的人可能会想，既然会有300W用户来访问，那为啥系统不干脆设计成能足以支撑这么大量用户的集群呢？</p><p>这是个好问题。如果系统是长期有300W的用户来访问，肯定是要做上述升级的，但是常常面临的情况是，系统的日常访问量就是100W，只不过偶尔有一些不可预知的特定原因导致的短时间的流量激增，这个时候，公司往往出于节约成本的考虑，不会为了一个不常见的尖峰来把我们的系统扩容到最大的尺寸。</p><h4 id="二、服务限流应该怎么做？"><a href="#二、服务限流应该怎么做？" class="headerlink" title="二、服务限流应该怎么做？"></a>二、服务限流应该怎么做？</h4><p>对系统服务进行限流，一般有如下几个模式：</p><ol><li><p><strong>熔断</strong>：<br>这个模式是需要系统在设计之初，就要把熔断措施考虑进去。当系统出现问题时，如果短时间内无法修复，系统要自动做出判断，开启熔断开关，拒绝流量访问，避免大流量对后端的过载请求。系统也应该能够动态监测后端程序的修复情况，当程序已恢复稳定时，可以关闭熔断开关，恢复正常服务。</p></li><li><p><strong>服务降级</strong>：<br>将系统的所有功能服务进行一个分级，当系统出现问题，需要紧急限流时，可将不是那么重要的功能进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。<br>例如在电商平台中，如果突发流量激增，可临时将商品评论、积分等非核心功能进行降级，停止这些服务，释放出机器和CPU等资源来保障用户正常下单，而这些降级的功能服务可以等整个系统恢复正常后，再来启动，进行补单/补偿处理。<br>除了功能降级以外，还可以采用不直接操作数据库，而全部读缓存、写缓存的方式作为临时降级方案。</p></li><li><p><strong>延迟处理</strong>：<br>这个模式需要在系统的前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现。这就相当于用异步的方式去减少了后端的处理压力，但是当流量较大时，后端的处理能力有限，缓冲池里的请求可能处理不及时，会有一定程度延迟。</p></li><li><p><strong>特权处理</strong>：<br>这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。</p></li></ol><p>那在实际项目中，对访问流量的限制，可采用如下几种技术方法：</p><ul><li><p><strong>熔断技术</strong><br>熔断的技术可以重点参考Netflix的开源组件hystrix的做法，主要有三个模块：熔断请求判断算法、熔断恢复机制、熔断报警。  </p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/12asfdcasf234231f.png" alt=""></p></li><li><p><strong>计数器方法</strong><br>系统维护一个计数器，来一个请求就加1，请求处理完成就减1，当计数器大于指定的阈值，就拒绝新的请求。<br>基于这个简单的方法，可以再延伸出一些高级功能，比如阈值可以不是固定值，是动态调整的。另外，还可以有多组计数器分别管理不同的服务，以保证互不影响等。</p></li><li><p><strong>队列方法</strong><br>就是基于FIFO队列，所有请求都进入队列，后端程序从队列中取出待处理的请求依次处理。<br>基于队列的方法，也可以延伸出更多的玩法来，比如可以设置多个队列以配置不同的优先级。</p></li><li><p><strong>令牌桶方法</strong><br>首先还是要基于一个队列，请求放到队列里面。但除了队列以外，还要设置一个令牌桶，另外有一个脚本以持续恒定的速度往令牌桶里面放令牌，后端处理程序每处理一个请求就必须从桶里拿出一个令牌，如果令牌拿完了，那就不能处理请求了。我们可以控制脚本放令牌的速度来达到控制后端处理的速度，以实现动态流控。</p></li></ul><h4 id="三、服务限流的注意事项"><a href="#三、服务限流的注意事项" class="headerlink" title="三、服务限流的注意事项"></a>三、服务限流的注意事项</h4><p>我们在做服务限流的时候，还是有一些原则和事项需要注意的：</p><ul><li><p>实时监控：系统必须要做好全链路的实时监控，才能保证限流的及时检测和处理。</p></li><li><p>手动开关：除系统自动限流以外，还需要有能手动控制的开关，以保证随时都可以人工介入。</p></li><li><p>限流的性能：限流的功能理论上是会在一定程度影响到业务正常性能的，因此需要做到限流的性能优化和控制。</p></li></ul><p>系统故障常常都是不可预测且难以避免的，因此作为系统设计师的我们，必须要提前预设各种措施，以应对随时可能的系统风险。</p><div class="note info"><p>作者：奎哥  &emsp;&emsp;公众号：不止思考</p></div>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单点登录原理与简单实现</title>
      <link href="/2018/09/30/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/30/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="一、单系统登录机制"><a href="#一、单系统登录机制" class="headerlink" title="一、单系统登录机制"></a>一、单系统登录机制</h2><hr><h3 id="1、http无状态协议"><a href="#1、http无状态协议" class="headerlink" title="1、http无状态协议"></a>1、http无状态协议</h3><p>&emsp;&emsp;web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155231912-1627010726.png" alt="3c91a3bf-25d8-4b1f-8e4a-68535c51aaa8" title="sd单点登录原理"></p><p>&emsp;&emsp;但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制</p><h3 id="2、会话机制"><a href="#2、会话机制" class="headerlink" title="2、会话机制"></a>2、会话机制</h3><p>&emsp;&emsp;浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155233115-1744636093.png" alt="8a9fb230-d506-4b19-b821-4001c68c4588" title="sd单点登录原理"></p><p>&emsp;&emsp;服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式</p><ol><li>请求参数</li><li>cookie</li></ol><p>&emsp;&emsp;将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息</p><p>&emsp;&emsp;tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155234443-99011212.png" alt="518293d9-64b2-459c-9d45-9f353c757d1f" title="sd单点登录原理"></p><h3 id="3、登录状态"><a href="#3、登录状态" class="headerlink" title="3、登录状态"></a>3、登录状态</h3><p>&emsp;&emsp;有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="string">"isLogin"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用户再次访问时，tomcat在会话对象中查看登录状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.getAttribute(<span class="string">"isLogin"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实现了登录状态的浏览器请求服务器模型如下图描述</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155235693-1708276896.png" alt="70e396fa-1bf2-42f8-a504-ce20306e31fa" title="sd单点登录原理"></p><p>&emsp;&emsp;每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。</p><h2 id="二、多系统的复杂性"><a href="#二、多系统的复杂性" class="headerlink" title="二、多系统的复杂性"></a>二、多系统的复杂性</h2><hr><p>&emsp;&emsp;web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155236615-855014039.png" alt="6dfbb0b1-46c0-4945-a3bf-5f060fa80710" title="uc单点登录原理"></p><p>&emsp;&emsp;web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155237802-1969340065.png" alt="9fe14ab3-4254-447b-b850-0436e628c254" title="uc单点登录原理"></p><p>&emsp;&emsp;虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p><p>&emsp;&emsp;单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155238881-1171826792.png" alt="4d58ccfa-0114-486d-bec2-c28f2f9eb513" title="sd单点登录原理"></p><p>&emsp;&emsp;既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p><p>&emsp;&emsp;然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p><p>&emsp;&emsp;因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录</p><h2 id="三、单点登录"><a href="#三、单点登录" class="headerlink" title="三、单点登录"></a>三、单点登录</h2><hr><p>&emsp;&emsp;什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分</p><h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a>1、登录</h3><p>&emsp;&emsp;相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161203152650974-276822362.png" alt="" title="sd单点登录原理"></p><p>下面对上图简要描述</p><ol><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名密码提交登录申请</li><li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统1</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li><li>用户访问系统2的受保护资源</li><li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li><li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统2</li><li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li></ol><p>&emsp;&emsp;用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</p><ol><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ol><p>&emsp;&emsp;你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数</p><h3 id="2、注销"><a href="#2、注销" class="headerlink" title="2、注销"></a>2、注销</h3><p>&emsp;&emsp;单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155243068-1378377736.png" alt="3b139d2e-0b83-4a69-b4f2-316adb8997ce" title="sd单点登录原理"><br>&emsp;&emsp;sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p><p>下面对上图简要说明</p><ol><li>用户向系统1发起注销请求</li><li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li><li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li><li>sso认证中心向所有注册系统发起注销请求</li><li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li><li>sso认证中心引导用户至登录页面</li></ol><h2 id="四、部署图"><a href="#四、部署图" class="headerlink" title="四、部署图"></a>四、部署图</h2><p>&emsp;&emsp;单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155244646-2067469767.png" alt="fb29685c-487c-42b9-9ceb-6c7ee29e98c9" title="deployment单点登录原理"></p><p>&emsp;&emsp;sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以</p><h2 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h2><p>&emsp;&emsp;只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）</p><p>sso-client</p><ol><li>拦截子系统未登录用户请求，跳转至sso认证中心</li><li>接收并存储sso认证中心发送的令牌</li><li>与sso-server通信，校验令牌的有效性</li><li>建立局部会话</li><li>拦截用户注销请求，向sso认证中心发送注销请求</li><li>接收sso认证中心发出的注销请求，销毁局部会话</li></ol><p>sso-server</p><ol><li>验证用户的登录信息</li><li>创建全局会话</li><li>创建授权令牌</li><li>与sso-client通信发送令牌</li><li>校验sso-client令牌有效性</li><li>系统注册</li><li>接收sso-client注销请求，注销所有会话</li></ol><p>&emsp;&emsp;接下来，我们按照原理来一步步实现sso吧！</p><h3 id="1、sso-client拦截未登录请求"><a href="#1、sso-client拦截未登录请求" class="headerlink" title="1、sso-client拦截未登录请求"></a>1、sso-client拦截未登录请求</h3><p>&emsp;&emsp;java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">    HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(<span class="string">"isLogin"</span>)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳转至sso认证中心</span></span><br><span class="line">    res.sendRedirect(<span class="string">"sso-server-url-with-system-url"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、sso-server拦截未登录请求"><a href="#2、sso-server拦截未登录请求" class="headerlink" title="2、sso-server拦截未登录请求"></a>2、sso-server拦截未登录请求</h3><p>&emsp;&emsp;拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样</p><h3 id="3、sso-server验证用户登录信息"><a href="#3、sso-server验证用户登录信息" class="headerlink" title="3、sso-server验证用户登录信息"></a>3、sso-server验证用户登录信息</h3><p>&emsp;&emsp;用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkLoginInfo(username, password);</span><br><span class="line">    req.getSession().setAttribute(<span class="string">"isLogin"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、sso-server创建授权令牌"><a href="#4、sso-server创建授权令牌" class="headerlink" title="4、sso-server创建授权令牌"></a>4、sso-server创建授权令牌</h3><p>&emsp;&emsp;授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String token = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><h3 id="5、sso-client取得令牌并校验"><a href="#5、sso-client取得令牌并校验" class="headerlink" title="5、sso-client取得令牌并校验"></a>5、sso-client取得令牌并校验</h3><p>&emsp;&emsp;sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求附带token参数</span></span><br><span class="line">String token = req.getParameter(<span class="string">"token"</span>);</span><br><span class="line"><span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 去sso认证中心校验token</span></span><br><span class="line">    <span class="keyword">boolean</span> verifyResult = <span class="keyword">this</span>.verify(<span class="string">"sso-server-verify-url"</span>, token);</span><br><span class="line">    <span class="keyword">if</span> (!verifyResult) &#123;</span><br><span class="line">        res.sendRedirect(<span class="string">"sso-server-url"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">"sso-server-verify-url-with-token"</span>);</span><br><span class="line">HttpResponse httpResponse = httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure><h3 id="6、sso-server接收并处理校验令牌请求"><a href="#6、sso-server接收并处理校验令牌请求" class="headerlink" title="6、sso-server接收并处理校验令牌请求"></a>6、sso-server接收并处理校验令牌请求</h3><p>&emsp;&emsp;用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）</p><p>&emsp;&emsp;令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p><p>&emsp;&emsp;令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话</p><p><img src="http://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/797930-20161129155245506-1069288802.png" alt="3b221593-f9c4-45af-a567-4937786993e8" title="class单点登录原理"></p><h3 id="7、sso-client校验令牌成功创建局部会话"><a href="#7、sso-client校验令牌成功创建局部会话" class="headerlink" title="7、sso-client校验令牌成功创建局部会话"></a>7、sso-client校验令牌成功创建局部会话</h3><p>&emsp;&emsp;令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (verifyResult) &#123;</span><br><span class="line">    session.setAttribute(<span class="string">"isLogin"</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求</p><h3 id="8、注销过程"><a href="#8、注销过程" class="headerlink" title="8、注销过程"></a>8、注销过程</h3><p>&emsp;&emsp;用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String logout = req.getParameter(<span class="string">"logout"</span>);</span><br><span class="line"><span class="keyword">if</span> (logout != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">        session.invalidate();<span class="comment">//触发LogoutListener</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过httpClient向所有注册系统发送注销请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>作者：凌承一  &emsp;&emsp;出处：<a href="http://www.cnblogs.com/ywlaker/" target="_blank" rel="noopener">http://www.cnblogs.com/ywlaker/ </a></p></div>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 单点登录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK1.8 HashMap源码分析</title>
      <link href="/2018/09/29/JDK1.8-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/29/JDK1.8-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="一、HashMap概述"><a href="#一、HashMap概述" class="headerlink" title="一、HashMap概述"></a>一、HashMap概述</h2><blockquote class="blockquote-center"><p>在JDK1.8之前，HashMap采用<code>数组+链表</code>实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用<code>数组+链表+红黑树</code>实现，当链表长度超过阈值(<code>8</code>)时，将链表转换为<code>红黑树</code>，这样大大减少了查找时间。</p></blockquote><p>&emsp;&emsp;下图中代表jdk1.8之前的hashmap结构，左边部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/249993-20170725101800296-127995101.png" alt=""></p><center>jdk1.8之前hashmap结构图</center><br><hr><br>&emsp;&emsp;jdk1.8之前的hashmap都采用上图的结构，都是基于一个数组和多个单链表，hash值冲突的时候，就将对应节点以链表的形式存储。如果在一个链表中查找其中一个节点时，将会花费O（n）的查找时间，会有很大的性能损失。到了jdk1.8，<code>当同一个hash值的节点数不小于8时，不再采用单链表形式存储，而是采用红黑树</code>，如下图所示。<br><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/249993-20170725102326906-1051203702.png" alt=""><br><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/249993-20170725102510515-1481424113.png" alt=""><br><center>jdk1.8 hashmap结构图</center><div class="note info"><p>上图很形象的展示了HashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树的引入是为了提高效率。</p></div><h2 id="二、涉及到的数据结构：处理hash冲突的链表和红黑树以及位桶"><a href="#二、涉及到的数据结构：处理hash冲突的链表和红黑树以及位桶" class="headerlink" title="二、涉及到的数据结构：处理hash冲突的链表和红黑树以及位桶"></a>二、涉及到的数据结构：处理hash冲突的链表和红黑树以及位桶</h2><h3 id="1、链表的实现"><a href="#1、链表的实现" class="headerlink" title="1、链表的实现"></a>1、链表的实现</h3><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/249993-20170725130741693-207764447.png" alt=""></p><p>&emsp;&emsp;Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。来看具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node是单向链表，它实现了Map.Entry接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;k,v&gt; next;</span><br><span class="line">    <span class="comment">//构造函数Hash值 键 值 下一个节点</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;k,v&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + = + value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，node中包含一个next变量，这个就是链表的关键点，hash结果相同的元素就是通过这个next进行关联的。</p><h3 id="2、红黑树"><a href="#2、红黑树" class="headerlink" title="2、红黑树"></a>2、红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;k,v&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;k,v&gt; left; <span class="comment">//左子树</span></span><br><span class="line">    TreeNode&lt;k,v&gt; right;<span class="comment">//右子树</span></span><br><span class="line">    TreeNode&lt;k,v&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;    <span class="comment">//颜色属性</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;k,v&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回当前节点的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;k,v&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;k,v&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;红黑树比链表多了四个变量，parent父节点、left左节点、right右节点、prev上一个同级节点，红黑树内容较多，不在赘述。</p><h3 id="3、位桶"><a href="#3、位桶" class="headerlink" title="3、位桶"></a>3、位桶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;k,v&gt;[] table;<span class="comment">//存储（位桶）的数组</span></span><br></pre></td></tr></table></figure><p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</p><p>&emsp;&emsp;有了以上3个数据结构，只要有一点数据结构基础的人，都可以大致联想到HashMap的实现了。首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</p><h2 id="三、HashMap源码分析"><a href="#三、HashMap源码分析" class="headerlink" title="三、HashMap源码分析"></a>三、HashMap源码分析</h2><h3 id="1、类的继承关系"><a href="#1、类的继承关系" class="headerlink" title="1、类的继承关系"></a>1、类的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到HashMap继承自父类（AbstractMap），实现了Map、Cloneable、Serializable接口。其中，Map接口定义了一组通用的操作；Cloneable接口则表示可以进行拷贝，在HashMap中，实现的是浅层次拷贝，即对拷贝对象的改变会影响被拷贝的对象；Serializable接口表示HashMap实现了序列化，即可以将HashMap对象保存至本地，之后可以恢复状态。</p><h3 id="2、类的属性"><a href="#2、类的属性" class="headerlink" title="2、类的属性"></a>2、类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;    </span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 填充因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>类的数据成员很重要，以上也解释得很详细了。</p></div><h3 id="3、类的构造函数"><a href="#3、类的构造函数" class="headerlink" title="3、类的构造函数"></a>3、类的构造函数</h3><h4 id="（1）HashMap-int-float-型构造函数"><a href="#（1）HashMap-int-float-型构造函数" class="headerlink" title="（1）HashMap(int, float)型构造函数"></a>（1）HashMap(int, float)型构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始容量不能小于0，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量不能大于最大值，否则为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 填充因子不能小于或等于0，不能为非数字</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="comment">// 初始化填充因子                                        </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 初始化threshold大小</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>&gt;&gt;&gt; 操作符表示无符号右移，高位取0。</p></div><h4 id="（2）HashMap-int-型构造函数。"><a href="#（2）HashMap-int-型构造函数。" class="headerlink" title="（2）HashMap(int)型构造函数。"></a>（2）HashMap(int)型构造函数。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap(int, float)型构造函数</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）HashMap-型构造函数。"><a href="#（3）HashMap-型构造函数。" class="headerlink" title="（3）HashMap()型构造函数。"></a>（3）HashMap()型构造函数。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化填充因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）HashMap-Map-lt-extends-K-gt-型构造函数。"><a href="#（4）HashMap-Map-lt-extends-K-gt-型构造函数。" class="headerlink" title="（4）HashMap(Map&lt;? extends K&gt;)型构造函数。"></a>（4）HashMap(Map&lt;? extends K&gt;)型构造函数。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化填充因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)函数将m的所有元素存入本HashMap实例中。　</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、hash算法"><a href="#4、hash算法" class="headerlink" title="4、hash算法"></a>4、hash算法</h3><p>在JDK 1.8中，hash方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）首先获取对象的hashCode()值，然后将hashCode值右移16位，然后将右移后的值与原来的hashCode做<strong>异或</strong>运算，返回结果。（其中h&gt;&gt;&gt;16，在JDK1.8中，优化了高位运算的算法，使用了零扩展，无论正数还是负数，都在高位插入0）。</p><p>（2）在putVal源码中，我们通过(n-1)&amp;hash获取该对象的键在hashmap中的位置。（其中hash的值就是（1）中获得的值）其中n表示的是hash桶数组的长度，并且该长度为2的n次方，这样(n-1)&amp;hash就等价于hash%n。因为&amp;运算的效率高于%运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//获取位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;tab即是table，n是map集合的容量大小，hash是上面方法的返回值。因为通常声明map集合时不会指定大小，或者初始化的时候就创建一个容量很大的map对象，所以这个通过容量大小与key值进行hash的算法在开始的时候只会对低位进行计算，虽然容量的2进制高位一开始都是0，但是key的2进制高位通常是有值的，因此先在hash方法中将key的hashCode右移16位在与自身异或，使得高位也可以参与hash，更大程度上减少了碰撞率。</p><p>下面举例说明下，n为table的长度。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/249993-20170725154200021-869603681.png" alt=""></p><h3 id="5、重要方法分析"><a href="#5、重要方法分析" class="headerlink" title="5、重要方法分析"></a>5、重要方法分析</h3><h4 id="（1）putVal方法"><a href="#（1）putVal方法" class="headerlink" title="（1）putVal方法"></a>（1）putVal方法</h4><p>&emsp;&emsp;首先说明，HashMap并没有直接提供putVal接口给用户调用，而是提供的put方法，而put方法就是通过putVal来插入元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash </span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal方法执行过程可以通过下图来理解：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/249993-20170725160254943-1515467235.png" alt=""></p><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><figure class="highlight java"><figcaption><span>具体源码如下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建 </span></span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理  </span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树 </span></span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表 </span></span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容 </span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap的数据存储实现原理"><a href="#HashMap的数据存储实现原理" class="headerlink" title="HashMap的数据存储实现原理"></a>HashMap的数据存储实现原理</h2><h3 id="（1）流程："><a href="#（1）流程：" class="headerlink" title="（1）流程："></a>（1）流程：</h3><p>1.根据key计算得到key.hash = (h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)；</p><p>2.根据key.hash计算得到桶数组的索引index = key.hash &amp; (table.length - 1)，这样就找到该key的存放位置了：</p><p>① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；</p><p>② 如果该位置有数据是一个红黑树，那么执行相应的插入 / 更新操作；</p><p>③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：</p><p>如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；如果该链表已经有这个节点了，那么找到该节点并更新新数据，返回老数据。</p><p>注意：</p><p>HashMap的put会返回key的上一次保存的数据，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();  </span><br><span class="line">System.out.println(map.put(<span class="string">"a"</span>, <span class="string">"A"</span>)); <span class="comment">// 打印null  </span></span><br><span class="line">System.out.println(map.put(<span class="string">"a"</span>, <span class="string">"AA"</span>)); <span class="comment">// 打印A  </span></span><br><span class="line">System.out.println(map.put(<span class="string">"a"</span>, <span class="string">"AB"</span>)); <span class="comment">// 打印AA</span></span><br></pre></td></tr></table></figure></p><h3 id="（2）getNode方法"><a href="#（2）getNode方法" class="headerlink" title="（2）getNode方法"></a>（2）getNode方法</h3><p>说明：HashMap同样并没有直接提供getNode接口给用户调用，而是提供的get方法，而get方法就是通过getNode来取得元素的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;k,v&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// table已经初始化，长度大于0，根据hash寻找table中的项也不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 桶中第一项(数组元素)相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为红黑树结点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 在红黑树中查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则，在链表中查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）resize方法"><a href="#（3）resize方法" class="headerlink" title="（3）resize方法"></a>（3）resize方法</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab指向hash桶数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//返回</span></span><br><span class="line">        &#125;<span class="comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 双倍扩容阀值threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//新建hash桶数组</span></span><br><span class="line">    table = newTab;<span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//进行扩容操作，复制Node对象值到新的hash桶数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//如果旧的hash桶数组在j结点处不为空，复制给e</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;<span class="comment">//将旧的hash桶数组在j结点处设置为空，方便gc</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果e后面没有Node结点</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//直接对e的hash值对新的数组长度求模获得存储位置</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是红黑树的类型，那么添加到红黑树中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;<span class="comment">//将Node结点的next赋值给next</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//如果结点e的hash值与原hash桶数组的长度作与运算为0</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">//如果loTail为null</span></span><br><span class="line">                                loHead = e;<span class="comment">//将e结点赋值给loHead</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;<span class="comment">//否则将e赋值给loTail.next</span></span><br><span class="line">                            loTail = e;<span class="comment">//然后将e复制给loTail</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">//如果结点e的hash值与原hash桶数组的长度作与运算不为0</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)<span class="comment">//如果hiTail为null</span></span><br><span class="line">                                hiHead = e;<span class="comment">//将e赋值给hiHead</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;<span class="comment">//如果hiTail不为空，将e复制给hiTail.next</span></span><br><span class="line">                            hiTail = e;<span class="comment">//将e复制个hiTail</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//直到e为空</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//如果loTail不为空</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;<span class="comment">//将loTail.next设置为空</span></span><br><span class="line">                        newTab[j] = loHead;<span class="comment">//将loHead赋值给新的hash桶数组[j]处</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;<span class="comment">//如果hiTail不为空</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;<span class="comment">//将hiTail.next赋值为空</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;<span class="comment">//将hiHead赋值给新的hash桶数组[j+旧hash桶数组长度]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><center>转自<a href="https://www.cnblogs.com/xiaoxi/" target="_blank" rel="noopener">平凡希</a><center></center></center></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk1.8 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈高性能数据库集群——读写分离</title>
      <link href="/2018/09/20/%E6%B5%85%E8%B0%88%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2018/09/20/%E6%B5%85%E8%B0%88%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h1 id="1-读写分离概述"><a href="#1-读写分离概述" class="headerlink" title="1 读写分离概述"></a>1 读写分离概述</h1><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-e43f3412c6387b0a.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">读写分离概述</center><p>基本架构图：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-06f5e8df8aeb7eac.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">基本架构图</center><h1 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2 适用场景"></a>2 适用场景</h1><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-4163278bb12eced4.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">适用场景</center><p><strong>读写分离不是银弹，并不是一有性能问题就上读写分离，</strong>而是应该先优化，例如优化慢查询，调整不合理的业务逻辑，引入缓存查询等只有确定系统没有优化空间后才考虑读写分离集群</p><h1 id="3-引入的系统复杂度问题"><a href="#3-引入的系统复杂度问题" class="headerlink" title="3 引入的系统复杂度问题"></a>3 引入的系统复杂度问题</h1><h2 id="问题一-主从复制延迟"><a href="#问题一-主从复制延迟" class="headerlink" title="问题一 主从复制延迟"></a>问题一 主从复制延迟</h2><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-a20f9c336fe62c3b.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">主从复制延迟</center><h2 id="问题二-分配机制"><a href="#问题二-分配机制" class="headerlink" title="问题二 分配机制"></a>问题二 分配机制</h2><p>如何将读写操作区分开来，然后访问不同的数据库服务器？</p><h3 id="解决方案1-客户端程序代码封装实现"><a href="#解决方案1-客户端程序代码封装实现" class="headerlink" title="解决方案1 客户端程序代码封装实现"></a>解决方案1 客户端程序代码封装实现</h3><p><strong>基本架构图</strong>  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-ea2f0f7e5d05f248.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">程序代码封装实现分配基本架构图</center><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-2201ff0331bac1e9.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">程序代码封装</center><p><strong>业界开源实现</strong></p><ul><li>Sharding-JDBC<br>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-2e54b4f173dcdefc.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">Sharding-JDBC基本架构图</center><ul><li>淘宝TDDL<br>淘宝根据自身业务需求研发了 TDDL （ Taobao Distributed Data Layer ）框架，主要用于解决 分库分表场景下的访问路由（持久层与数据访问层的配合）以及异构数据库之间的数据同步 ，它是一个基于集中式配置的 JDBC DataSource 实现，具有分库分表、 Master/Salve 、动态数据源配置等功能。</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-1c6e396883493510.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">淘宝TDDL基本架构图</center><h3 id="解决方案2-服务端中间件封装"><a href="#解决方案2-服务端中间件封装" class="headerlink" title="解决方案2 服务端中间件封装"></a>解决方案2 服务端中间件封装</h3><p><strong>基本架构图</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-14d0897f3ff15bcb.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">服务端中间件封装实现分配基本架构图</center><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-9174a86fd6e5f23b.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">服务端中间件封装</center><p><strong>业界开源实现</strong></p><ul><li>MySQL官方推荐的MySQL Router</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-31ebcb40b8079f31.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">MySQL Router架构图</center><p>MySQL Router是轻量级的中间件，可在应用程序和任何后端MySQL服务器之间提供透明路由。它可以用于各种各样的用例，例如通过有效地将数据库流量路由到适当的后端MySQL服务器来提供高可用性和可伸缩性。可插拔架构还使开发人员能够扩展MySQL Router以用于自定义用例。</p><p>基于MySQL Router可以实现读写分离，故障自动切换，负载均衡，连接池等功能。</p><ul><li><p>MySQL官方提供的MySQL Proxy<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-c3960a36b36ae8d4.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%"> MySQL Proxy</center></li><li><p>360开源的Atlas<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-c34706b5d7f379bd.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">Atlas架构图形象表示</center></li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-d7b51511d8fdbefe.webp" alt=""></p><p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">Atlas总体架构</center><br>Atlas是由平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy的基础上，对其进行了优化，增加了一些新的功能特性。</p><h3 id="常见的开源数据库中间件对比"><a href="#常见的开源数据库中间件对比" class="headerlink" title="常见的开源数据库中间件对比"></a>常见的开源数据库中间件对比</h3><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">Sharding-JDBC</th><th style="text-align:center">TDDL</th><th style="text-align:center">Amoeba</th><th style="text-align:center">Cobar</th><th style="text-align:center">MyCat</th></tr></thead><tbody><tr><td style="text-align:center">基于客户端还是服务端</td><td style="text-align:center">客户端</td><td style="text-align:center">客户端</td><td style="text-align:center">服务端</td><td style="text-align:center">服务端</td><td style="text-align:center">服务端</td></tr><tr><td style="text-align:center">分库分表</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">MySQL交互协议</td><td style="text-align:center">JDBC Driver</td><td style="text-align:center">JDBC Driver</td><td style="text-align:center">前端用NIO,后端用JDBC Driver</td><td style="text-align:center">前端用NIO,后端用BIO</td><td style="text-align:center">前后端均用NIO</td></tr><tr><td style="text-align:center">支持的数据库</td><td style="text-align:center">任意</td><td style="text-align:center">任意</td><td style="text-align:center">任意</td><td style="text-align:center">MySQL</td><td style="text-align:center">任意</td></tr></tbody></table><p>参考</p><p><a href="https://blog.csdn.net/u011983531/article/details/78948680" target="_blank" rel="noopener">Mycat原理解析-Mycat架构分析</a></p><pre><code>作者 陈彩华文章转载交流请联系 caison@aliyun.com</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分库分表 </tag>
            
            <tag> 高性能 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈高性能数据库集群——分库分表</title>
      <link href="/2018/09/20/%E6%B5%85%E8%B0%88%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2018/09/20/%E6%B5%85%E8%B0%88%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h1 id="分库分表概述"><a href="#分库分表概述" class="headerlink" title="分库分表概述"></a>分库分表概述</h1><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-3255d9e9ddc2ec2b.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">分库分表概述</center><p>读写分离分散数据库读写操作压力，分库分表<strong>分散存储压力</strong></p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-4f3534f5bd04994c.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">适用场景</center><blockquote><p><strong>类似读写分离，分库分表也是确定没有其他优化空间之后才采取的优化方案</strong>。那如果业务真的发展很快岂不是很快要进行分库分表了？那为何不一开始就设计好呢？</p></blockquote><blockquote><p>按照架构设计的“三原则”（<strong>简单原则，合适原则，演化原则</strong>），简单分析一下：</p></blockquote><blockquote><p>首先，这里的“如果”事实上发生的概率比较低，做10个业务有一个业务能活下去就很不错了，更何况快速发展，和中彩票的概率差不多。<strong>如果我们每个业务上来就按照淘宝、微信的规模去做架构设计，不但会累死自己，还会害死业务</strong>。</p></blockquote><blockquote><p>其次，<strong>如果业务真的发展很快，后面进行分库分表也不迟</strong>。因为业务发展好，相应的资源投入就会加大，可以投入更多的人和更多的钱，那业务分库带来的代码和业务复杂问题就可以通过加人来解决，成本问题也可以通过增加资金来解决。</p></blockquote><h1 id="业务分库"><a href="#业务分库" class="headerlink" title="业务分库"></a>业务分库</h1><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-02241d45a2ffbb04.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">业务分库</center><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-fa3e86227db9877d.webp" alt=""><br><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">示例</center><h1 id="业务分表"><a href="#业务分表" class="headerlink" title="业务分表"></a>业务分表</h1><h2 id="业务分表概述"><a href="#业务分表概述" class="headerlink" title="业务分表概述"></a>业务分表概述</h2><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-a120249dcd6a9343.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">业务分表</center><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-09eba8d05a18f9aa.webp" alt=""><br><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">拆分方式</center><h2 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>增加表操作的次数</p><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><ul><li><p>路由问题<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-ee84446b35676125.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">路由问题</center></li><li><p>数据库操作问题<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-36a209c1dea789a7.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">数据库操作问题</center></li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p><img src="/https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5618238-65d8b7e266b9d0dd.webp" alt=""></p><center style="border-bottom: 1px solid #d9d9d9;min-width: 20%;max-width: 80%;margin: 0 auto;width:20%">实现方法</center><p>类似<a href="https://yfzhou.coding.me/2018/09/20/%E6%B5%85%E8%B0%88%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">读写分离</a>，具体实现也是“程序代码封装”和“中间件封装”，但具体实现复杂一些，因为还有要判断SQL中具体操作的表，具体操作(例如count、order by、group by等)，根据具体操作做不同的处理。</p><div class="note success"><p>参考</p></div><ul><li><a href="https://time.geekbang.org/column/intro/81?code=OK4eM0TBPTKGPRCzcZdzIeXjPACLfY3KCzATXOSWzXE%3D" target="_blank" rel="noopener">从0开始学架构 —— 李运华</a></li><li><a href="https://juejin.im/post/5b3753b66fb9a00e65267a55" target="_blank" rel="noopener">《浅谈高性能数据库集群——读写分离》—— 陈彩华</a></li><li><a href="https://juejin.im/post/5b2c6669e51d4558c91ba776" target="_blank" rel="noopener">《架构设计方法初探》 —— 陈彩华</a></li><li><a href="http://kuaibao.qq.com/s/20180506G0J38H00?refer=spider" target="_blank" rel="noopener">《分库分表、主从、读写分离》</a></li></ul><pre><code>作者 陈彩华文章转载交流请联系 caison@aliyun.com</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分库分表 </tag>
            
            <tag> 高性能 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL不为人知的主键与唯一索引约束</title>
      <link href="/2018/09/19/MySQL%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E4%B8%BB%E9%94%AE%E4%B8%8E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%BA%A6%E6%9D%9F/"/>
      <url>/2018/09/19/MySQL%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E4%B8%BB%E9%94%AE%E4%B8%8E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p><center>此文摘自微信公众号【架构师之路】<br>微信扫一扫<br>关注该公众号<br></center><br><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961431&amp;idx=1&amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;send_time=" alt=""></p><p>今天和大家简单聊聊MySQL的约束<strong>主键与唯一索引约束</strong>：</p><p>PRIMARY KEY and UNIQUE Index Constraints</p><p>文章不长，保证有收获。</p><p>触发约束检测的时机：</p><ul><li>insert</li><li>update</li></ul><p>当检测到违反约束时，不同存储引擎的处理动作是不一样的。</p><p><strong>如果存储引擎支持事务，SQL会自动<span style="color: rgb(255, 76, 0);"><strong><span style="font-size: 14px;letter-spacing: 1px;">回滚</span></strong></span>。</strong></p><p>例子：<br>create table t1 (<br>id int(10) <span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">primary key</span><br>)engine=<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">innodb</span>;<br>insert into t1 values(1);<br>insert into t1 values(1);<br>其中第二条insert会因为违反约束，而导致回滚。</p><p>通常可以使用：<br>show warnings;<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180919175612.webp" alt=""></p><p>来查看违反约束后的错误提示。</p><p><strong>如果存储引擎不支持事务，SQL的执行会<span style="color: rgb(255, 76, 0);"><strong><span style="font-size: 14px;letter-spacing: 1px;">中断</span></strong></span>，此时可能会导致后续有符合条件的行不被操作，出现不符合预期的结果。</strong></p><p>例子：<br>create table t2 (<br>id int(10) <span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">unique</span><br>)engine=<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">MyISAM</span>;<br>insert into t2 values(<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">1</span>);<br>insert into t2 values(<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">5</span>);<br>insert into t2 values(<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">6</span>);<br>insert into t2 values(<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">10</span>);<br>update t2 <span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">set id=id+1</span>;</p><p><strong>update执行后，猜猜会得到什么结果集？</strong><br>猜想一：2, 6, 7, 11<br>猜想二：1, 5, 6, 10<br>.<br>.<br>.<br>都不对，正确答案是：<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">2</span>, 5, 6, 10</p><p>第一行id=1，加1后，没有违反unique约束，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">执行成功</span>；<br>第二行id=5，加1后，由于id=6的记录存在，违反uinique约束，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">SQL终止</span>，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">修改失败</span>；<br>第三行id=6，第四行id=10便<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">不再执行</span>；<br><span style="color: rgb(0, 82, 255);"><em><span style="font-size: 14px;letter-spacing: 1px;">画外音：这太操蛋了，一个update语句，部分执行成功，部分执行失败。</span></em></span></p><p><strong>为了避免这种情况出现，请使用InnoDB存储引擎</strong>，InnoDB在遇到违反约束时，会自动回滚update语句，一行都不会修改成功。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-size: 14px;letter-spacing: 1px;">画外音：大家把存储引擎换成InnoDB，把上面的例子再跑一遍，印象更加深刻。</span></em></span></p><p>另外，对于<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">insert的约束冲突</span>，可以使用：<br><span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">insert … on duplicate key</span><br>指出<strong>在违反主键或唯一索引约束时，需要进行的额外操作</strong>。</p><p>例子：<br>create table t3 (<br>id int(10) <span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">unique</span>,<br>flag char(10) <span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">default ‘true’</span><br>)engine=<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">MyISAM</span>;<br>insert into t3(id) values(1);<br>insert into t3(id) values(5);<br>insert into t3(id) values(6);<br>insert into t3(id) values(<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">10</span>);<br>insert into t3(id) values(<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">10</span>) on duplicate key update flag=’false’;</p><p><strong>insert执行后，猜猜会发生什么？</strong><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180919175500.webp" alt=""></p><p>插入id=10的记录，会违反unique约束，此时执行update flag=’false’，于是有一行记录被update了。  </p><p>这<strong>相当于执行</strong>：<br>update t3 set flag=’false’ where id=10;</p><p>仔细看，insert的结果返回，提示：<br>Query OK, <span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);">2</span> rows affected<br>有意思么？<br><span style="color: rgb(0, 82, 255);"><em><span style="font-size: 14px;letter-spacing: 1px;">画外音：本文所有实验，基于MySQL5.6。</span></em></span></p><p><strong>总结</strong>，对于<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">主键与唯一索引约束</span>：</p><ul><li>执行insert和update时，会触发约束检查 </li><li><strong>InnoDB</strong>违反约束时，会<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">回滚对应SQL</span></li><li><strong>MyISAM</strong>违反约束时，会<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">中断对应的SQL</span>，可能造成不符合预期的结果集</li><li>可以使用<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);"> insert … on duplicate key </span>来指定触发约束时的动作</li><li>通常使用<span style="letter-spacing: 1px;font-size: 12px;color: rgb(255, 76, 0);"> show warnings; </span>来查看与调试违反约束的ERROR</li></ul><p>互联网大数据量高并发量业务，<strong>为了大家的身心健康，请使用InnoDB</strong>。</p><p>相关推荐：<br>《<a href="https://yfzhou.coding.me/2018/09/10/%E4%B8%9A%E7%95%8C%E9%9A%BE%E9%A2%98%20-%20%E3%80%8E%E8%B7%A8%E5%BA%93%E5%88%86%E9%A1%B5%E3%80%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88/">业界难题 - 『跨库分页』的四种方案</a>》<br>《<a href="https://yfzhou.coding.me/2018/08/14/InnoDB%E5%B9%B6%E5%8F%91%E5%A6%82%E6%AD%A4%E9%AB%98%EF%BC%8C%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E5%9C%A8%E8%BF%99%EF%BC%9F/">InnoDB，为什么并发如此之高？</a>》<br>《<a href="https://yfzhou.coding.me/2018/09/05/InnoDB%EF%BC%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%8C%E5%9C%A8RR%E5%92%8CRC%E4%B8%8B%E6%9C%89%E4%BD%95%E5%B7%AE%E5%BC%82%EF%BC%9F/">InnoDB，快照读，在RR和RC下有何差异？</a>》</p><p>了解了几个坑，也是好的，求转。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> InnoDB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（Hexo博客备份）</title>
      <link href="/2018/09/17/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%EF%BC%89/"/>
      <url>/2018/09/17/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h3 id="一、需求："><a href="#一、需求：" class="headerlink" title="一、需求："></a>一、需求：</h3><p>在Windows和Mac下需要对Hexo进行管理和更新，或者进行重新部署环境。</p><h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>创建分支，一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。</p><h3 id="三、搭建的流程"><a href="#三、搭建的流程" class="headerlink" title="三、搭建的流程"></a>三、搭建的流程</h3><p>博客搭建请看我之前的文章</p><ol><li>将themes/next/(我用的是NexT主题)中的.git/删除，否则无法将主题文件夹push；</li><li>在本地blog文件夹下创建文件.gitignore(一般都自带一个)，打开后写入</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><div class="note info"><p>备注：<br>刚开始好多备份的教程都没有说明.gitignore文件，在恢复之后，进行hexo d之后老是报错，发在邮箱里的错误内容</p></div><p><img src="http://oe53dpmqz.bkt.clouddn.com/20160929001.png" alt="20160929001"><br>github给邮箱发送的内容，说：<span class="label danger">有模块没有初始化，在这里所指的就是.deploy_git这个模块</span></p><ol start="3"><li><p>在本地blog文件夹下执行命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git初始化</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment">#创建hexo分支，用来存放源码</span></span><br><span class="line">git checkout -b hexo</span><br><span class="line"><span class="comment">#git 文件添加</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash"><span class="comment">#git 提交</span></span></span><br><span class="line"><span class="bash">git commit -m <span class="string">"init"</span></span></span><br><span class="line"><span class="bash"><span class="comment">#添加远程仓库</span></span></span><br><span class="line"><span class="bash">git remote add origin git@github.com:542869246/542869246.github.io.git</span></span><br><span class="line"><span class="bash"><span class="comment">#push到hexo分支</span></span></span><br><span class="line"><span class="bash">git push origin hexo</span></span><br></pre></td></tr></table></figure></li><li><p>执行hexo d -g生成网站并部署到GitHub上</p></li></ol><p>这样一来，在GitHub上的<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:542869246/542869246.github.io.git仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。</p><h3 id="四、恢复"><a href="#四、恢复" class="headerlink" title="四、恢复"></a>四、恢复</h3><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><ul><li>1、先安装hexo<br>$ npm install -g hexo-cli</li><li>2、存在github上的git clone下来<br>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:542869246/542869246.github.io.git</li><li>3、项目文件夹下npm<br>cd项目名/ npm install –no-bin-links<br>$ npm install hexo-deployer-git</li><li>4、重新配置github和coding的公钥</li></ul><h3 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h3><p>每次写作之后,可以使用下列步骤：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo d<span class="comment">#生成网站并部署到GitHub上</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">'update'</span></span></span><br><span class="line"><span class="bash">git push origin hexo</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>业界难题 - 『跨库分页』的四种方案</title>
      <link href="/2018/09/10/%E4%B8%9A%E7%95%8C%E9%9A%BE%E9%A2%98%20-%20%E3%80%8E%E8%B7%A8%E5%BA%93%E5%88%86%E9%A1%B5%E3%80%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2018/09/10/%E4%B8%9A%E7%95%8C%E9%9A%BE%E9%A2%98%20-%20%E3%80%8E%E8%B7%A8%E5%BA%93%E5%88%86%E9%A1%B5%E3%80%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="一、需求缘起"><a href="#一、需求缘起" class="headerlink" title="一、需求缘起"></a>一、需求缘起</h2><p><strong>分页需求</strong></p><p>互联网很多业务都有<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">分页拉取数据</span>的需求，例如：</p><p>（1）微信消息过多时，拉取第N页消息</p><p>（2）京东下单过多时，拉取第N页订单</p><p>（3）浏览58同城，查看第N页帖子</p><p>这些业务场景对应的消息表，订单表，帖子表分页拉取需求有这样一些特点：</p><p>（1）<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">有一个业务主键</span>id</span>, 例如msg_id, order_id, tiezi_id</p><p>（2）分页排序是<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">按照非业务主键</span>id<span style="font-size: 14px; font-family: 宋体;">来排序</span></span>的，业务中经常按照时间time来排序order by</p><p>在数据量不大时，<strong>可以通过在排序字段time上建立索引，利用SQL提供的offset/limit功能就能满足分页查询需求</strong>：</p><p>select * from t_msg order by time offset 200 limit 100</p><p>select * from t_order order by time offset 200 limit 100</p><p>select * from t_tiezi order by time offset 200 limit 100</p><p>此处假设一页数据为100条，均拉取第3页数据。</p><p><strong>分库需求</strong></p><p>高并发大流量的互联网架构，一般通过服务层来访问数据库，<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">随着数据量的增大，数据库需要进行水平切分</span>，分库后将数据分布到不同的数据库实例（甚至物理机器）上，以达到降低数据量，增加实例数的扩容目的。</p><p>一旦涉及分库，逃不开<strong>“分库依据”patition key</strong>的概念，使用哪一个字段来水平切分数据库呢：大部分的业务场景，会使用<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">业务主键</span>id</span>。</p><p>确定了分库依据patition key后，接下来要确定的是<strong>分库算法</strong>：大部分的业务场景，会使用业务<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">主键</span>id<span style="font-size: 14px; font-family: 宋体;">取模的算法</span></span>来分库，这样即能够保证每个库的数据分布是均匀的，又能够保证每个库的请求分布是均匀的，实在是简单实现负载均衡的好方法，此法在互联网架构中应用颇多。</p><p>举一个更具体的例子：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/1.webp" alt=""></p><p>用户库user，水平切分后变为两个库，分库依据patition key是uid，分库算法是uid取模：uid%2余0的数据会落到db0，uid%2余1的数据会落到db1。</p><p><strong>问题的提出</strong></p><p>仍然是上述用户库的例子，如果业务要查询“最近注册的第3页用户”，该如何实现呢？单库上，可以</p><p>select * from t_user order by time offset 200 limit 100</p><p>变成两个库后，分库依据是uid，排序依据是time，数据库层失去了time排序的全局视野，数据分布在两个库上，此时该怎么办呢？</p><p><span style="font-size: 14px; line-height: 1.6; font-family: 宋体; color: rgb(255, 104, 39);">如何满足“跨越多个水平切分数据库，且分库依据与排序依据为不同属性，并需要进行分页”的查询需求</span>，实现 select * from T order by time offset X limit Y的跨库分页SQL，是<span style="font-size: 14px; line-height: 1.6; font-family: 宋体; color: rgb(255, 104, 39);">本文将要讨论的技术问题</span>。</p><h2 id="二、全局视野法"><a href="#二、全局视野法" class="headerlink" title="二、全局视野法"></a>二、全局视野法</h2><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/2.webp" alt=""></p><p>如上图所述，服务层通过uid取模将数据分布到两个库上去之后，每个数据库都失去了全局视野，数据按照time局部排序之后，不管哪个分库的第3页数据，都不一定是全局排序的第3页数据。</p><p>那到底哪些数据才是全局排序的第3页数据呢，暂且分三种情况讨论。</p><p>（1）<strong>极端情况</strong>，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">两个库的数据完全一样</span></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/3.webp" alt=""></p><p>如果两个库的数据完全相同，只需要每个库offset一半，再取半页，就是最终想要的数据（如上图中粉色部分数据）。</p><p>（2）<strong>极端情况</strong>，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">结果数据来自一个库</span></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/4.webp" alt=""></p><p>也可能两个库的数据分布及其不均衡，例如db0的所有数据的time都大于db1的所有数据的time，则可能出现：一个库的第3页数据，就是全局排序后的第3页数据（如上图中粉色部分数据）。</p><p>（3）<strong>一般情况</strong>，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">每个库数据各包含一部分</span></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/5.webp" alt=""></p><p>正常情况下，全局排序的第3页数据，每个库都会包含一部分（如上图中粉色部分数据）。</p><p>由于不清楚到底是哪种情况，所以<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">必须每个库都返回</span>3<span style="font-size: 14px; font-family: 宋体;">页数据，所得到的</span>6<span style="font-size: 14px; font-family: 宋体;">页数据在服务层进行内存排序，得到数据全局视野，再取第</span>3<span style="font-size: 14px; font-family: 宋体;">页数据</span></span>，便能够得到想要的全局分页数据。</p><p>再总结一下这个方案的步骤：</p><p>（1）将order by time offset X limit Y，改写成order by time offset 0 limit X+Y</p><p>（2）服务层将改写后的SQL语句发往各个分库：即例子中的各取3页数据</p><p>（3）假设共分为N个库，服务层将得到N*(X+Y)条数据：即例子中的6页数据</p><p>（4）服务层对得到的N*(X+Y)条数据进行内存排序，内存排序后再取偏移量X后的Y条记录，就是全局视野所需的一页数据</p><p><strong>方案优点</strong>：通过服务层修改SQL语句，扩大数据召回量，能够得到全局视野，业务无损，精准返回所需数据。</p><p><strong>方案缺点</strong>（显而易见）：</p><p>（1）每个分库需要返回更多的数据，增大了网络传输量（<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">耗网络</span>）；</p><p>（2）除了数据库按照time进行排序，服务层还需要进行二次排序，增大了服务层的计算量（<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">耗</span>CPU</span>）；</p><p>（3）最致命的，这个算法<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">随着页码的增大，性能会急剧下降</span>，这是因为SQL改写后每个分库要返回X+Y行数据：返回第3页，offset中的X=200；假如要返回第100页，offset中的X=9900，即每个分库要返回100页数据，数据量和排序量都将大增，性能平方级下降。</p><h2 id="三、业务折衷法"><a href="#三、业务折衷法" class="headerlink" title="三、业务折衷法"></a>三、业务折衷法</h2><p>“全局视野法”虽然性能较差，但其业务无损，数据精准，不失为一种方案，有没有性能更优的方案呢？</p><p>“<strong>任何脱离业务的架构设计都是耍流氓</strong>”，技术方案需要折衷，在技术难度较大的情况下，<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">业务需求的折衷能够极大的简化技术方案</span>。</p><p><strong>业务折衷一：禁止跳页查询</strong></p><p>在数据量很大，翻页数很多的时候，很多产品并<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">不提供“直接跳到指定页面”的功能，而只提供“下一页”的功能</span>，这一个小小的业务折衷，就能极大的降低技术方案的复杂度。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/6.webp" alt=""></p><p>如上图，不够跳页，那么第一次只能够查第一页：</p><p>（1）将查询order by time offset 0 limit 100，改写成order by time where time&gt;0 limit 100</p><p>（2）上述改写和offset 0 limit 100的效果相同，都是每个分库返回了一页数据（上图中粉色部分）；</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/7.webp" alt=""></p><p>（3）服务层得到2页数据，内存排序，取出前100条数据，作为最终的第一页数据，这个全局的第一页数据，一般来说每个分库都包含一部分数据（如上图粉色部分）；</p><p>咦，这个方案也需要服务器内存排序，岂不是和“全局视野法”一样么？<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">第一页数据的拉取确实一样，但每一次“下一页”拉取的方案就不一样了</span>。</p><p>点击“下一页”时，需要拉取第二页数据，在第一页数据的基础之上，能够找到第一页数据time的最大值：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/8.webp" alt=""></p><p>这个<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">上一页记录的</span>time_max<span style="font-size: 14px; font-family: 宋体;">，会作为第二页数据拉取的查询条件</span></span>：</p><p>（1）将查询order by time offset 100 limit 100，改写成order by time where time&gt;$time_max limit 100</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/9.webp" alt=""></p><p>（2）这下不是返回2页数据了（“全局视野法，会改写成offset 0 limit 200”），每个分库还是返回一页数据（如上图中粉色部分）；</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/10.webp" alt=""></p><p>（3）服务层得到2页数据，内存排序，取出前100条数据，作为最终的第2页数据，这个全局的第2页数据，一般来说也是每个分库都包含一部分数据（如上图粉色部分）；</p><p>如此往复，查询全局视野第100页数据时，不是将查询条件改写为offset 0 limit 9900+100（<strong>返回100页数据</strong>），而是改写为time&gt;$time_max99 limit 100（<strong>仍返回一页数据</strong>），以保证<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">数据的传输量和排序的数据量不会随着不断翻页而导致性能下降</span>。</p><h2 id="业务折衷二：允许数据精度损失"><a href="#业务折衷二：允许数据精度损失" class="headerlink" title="业务折衷二：允许数据精度损失"></a>业务折衷二：允许数据精度损失</h2><p>“全局视野法”能够返回业务无损的精确数据，在查询页数较大，例如第100页时，会有性能问题，此时<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">业务上是否能够接受，返回的</span>100<span style="font-size: 14px; font-family: 宋体;">页不是精准的数据</span></span>，而允许有一些数据偏差呢？</p><p><strong>数据库分库-**</strong>数据均衡原理**</p><p>使用patition key进行分库，在数据量较大，数据分布足够随机的情况下，<span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">各分库所有非</span>patition key<span style="font-size: 14px; font-family: 宋体;">属性，在各个分库上的数据分布，统计概率情况是一致的</span></span>。</p><p>例如，在uid随机的情况下，使用uid取模分两库，db0和db1：</p><p>（1）<strong>性别</strong>属性，如果db0库上的男性用户占比70%，则db1上男性用户占比也应为70%</p><p>（2）<strong>年龄</strong>属性，如果db0库上18-28岁少女用户比例占比15%，则db1上少女用户比例也应为15%</p><p>（3）<strong>时间</strong>属性，如果db0库上每天10:00之前登录的用户占比为20%，则db1上应该是相同的统计规律</p><p>…</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/11.webp" alt=""></p><p>利用这一原理，要查询全局100页数据，offset 9900 limit 100改写为offset 4950 limit 50，每个分库偏移4950（一半），获取50条数据（半页），得到的数据集的并集，基本能够认为，是全局数据的offset 9900 limit 100的数据，当然，这一页数据的精度，并不是精准的。</p><p>根据实际业务经验，用户都要查询第100页网页、帖子、邮件的数据了，这一页数据的精准性损失，业务上往往是可以接受的，但此时<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">技术方案的复杂度便大大降低</span>了，既不需要返回更多的数据，也不需要进行服务内存排序了。</p><h2 id="四、终极武器-二次查询法"><a href="#四、终极武器-二次查询法" class="headerlink" title="四、终极武器-二次查询法"></a>四、终极武器<strong><strong>-</strong></strong>二次查询法</h2><p>有没有一种技术方案，<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">即能够满足业务的精确需要，无需业务折衷，又高性能的方法</span>呢？这就是接下来要介绍的终极武器：“二次查询法”。</p><p>为了方便举例，假设一页只有5条数据，查询第200页的SQL语句为select * from T order by time offset 1000 limit 5;</p><p><strong>步骤一：查询改写</strong></p><p>将select * from T order by time offset 1000 limit 5</p><p>改写为select * from T order by time offset 500 limit 5</p><p>并投递给所有的分库，注意，这个offset的500，来自于全局offset的总偏移量1000，除以水平切分数据库个数2。</p><p>如果是3个分库，则可以改写为select * from T order by time offset 333 limit 5</p><p>假设这三个分库返回的数据(time, uid)如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/12.webp" alt=""></p><p>可以看到，每个分库都是返回的按照time排序的一页数据。</p><p><strong>步骤二：找到所返回3页全部数据的最小值</strong></p><p>第一个库，5条数据的time最小值是1487501123</p><p>第二个库，5条数据的time最小值是1487501133</p><p>第三个库，5条数据的time最小值是1487501143</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/13.webp" alt=""></p><p>故，三页数据中，time最小值来自第一个库，time_min=1487501123，这个过程只需要比较各个分库第一条数据，时间复杂度很低</p><p><strong>步骤三：查询二次改写</strong></p><p>第一次改写的SQL语句是select * from T order by time offset 333 limit 5</p><p><span style="font-size: 14px; color: rgb(255, 104, 39);"><span style="font-size: 14px; font-family: 宋体;">第二次要改写成一个</span>between<span style="font-size: 14px; font-family: 宋体;">语句</span></span>，between的起点是time_min，between的终点是原来每个分库各自返回数据的最大值：</p><p>第一个分库，第一次返回数据的最大值是1487501523</p><p>所以查询改写为select * from T order by time where time between time_min and 1487501523</p><p>第二个分库，第一次返回数据的最大值是1487501323</p><p>所以查询改写为select * from T order by time where time between time_min and 1487501323</p><p>第三个分库，第一次返回数据的最大值是1487501553</p><p>所以查询改写为select * from T order by time where time between time_min and 1487501553</p><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">相对第一次查询，第二次查询条件放宽了，故第二次查询会返回比第一次查询结果集更多的数据</span>，假设这三个分库返回的数据(time, uid)如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/14.webp" alt=""></p><p>可以看到：</p><p>由于time_min来自原来的分库一，所以分库一的返回结果集和第一次查询相同（所以其实这次访问是可以省略的）；</p><p>分库二的结果集，比第一次多返回了1条数据，头部的1条记录（time最小的记录）是新的（上图中粉色记录）；</p><p>分库三的结果集，比第一次多返回了2条数据，头部的2条记录（time最小的2条记录）是新的（上图中粉色记录）；</p><p><strong>步骤四：在每个结果集中虚拟一个time_min记录，找到time_min在全局的offset</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/15.webp" alt=""></p><p>在第一个库中，time_min在第一个库的offset是333</p><p>在第二个库中，(1487501133, uid_aa)的offset是333（根据第一次查询条件得出的），故虚拟time_min在第二个库的offset是331</p><p>在第三个库中，(1487501143, uid_aaa)的offset是333（根据第一次查询条件得出的），故虚拟time_min在第三个库的offset是330</p><p>综上，time_min在全局的offset是333+331+330=994</p><p><strong>步骤五：既然得到了time_min在全局的offset，就相当于有了全局视野，根据第二次的结果集，就能够得到全局offset 1000 limit 5的记录</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/16.webp" alt=""></p><p>第二次查询在各个分库返回的结果集是有序的，又知道了time_min在全局的offset是994，一路排下来，容易知道全局offset 1000 limit 5的一页记录（上图中黄色记录）。</p><p>是不是非常巧妙？这种方法的<strong>优点</strong>是：可以<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">精确的返回业务所需数据，每次返回的数据量都非常小，不会随着翻页增加数据的返回量</span>。</p><p><strong>不足是</strong>：需要进行<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">两次数据库查询</span>。</p><p><strong>五、总结</strong></p><p>今天介绍了解决“跨N库分页”这一难题的四种方法：</p><p><strong>方法一：全局视野法</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset 0 limit X+Y</p><p>（2）服务层对得到的N*(X+Y)条数据进行内存排序，内存排序后再取偏移量X后的Y条记录</p><p>这种方法<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">随着翻页的进行，性能越来越低</span>。</p><p><strong>方法二：业务折衷法-禁止跳页查询</strong></p><p>（1）用正常的方法取得第一页数据，并得到第一页记录的time_max</p><p>（2）每次翻页，将order by time offset X limit Y，改写成order by time where time&gt;$time_max limit Y</p><p>以保证<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">每次只返回一页数据，性能为常量</span>。</p><p><strong>方法三：业务折衷法-允许模糊数据</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset X/N limit Y/N</p><p><strong>方法四：二次查询法</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset X/N limit Y</p><p>（2）找到最小值time_min</p><p>（3）between二次查询，order by time between $time_min and $time_i_max</p><p>（4）设置虚拟time_min，找到time_min在各个分库的offset，从而得到time_min在全局的offset</p><p>（5）得到了time_min在全局的offset，自然得到了全局的offset X limit Y</p><p>原创： 58沈剑</p><p>转载来源：<a href="https://mp.weixin.qq.com/s/B9FHHM-NCZvtn7xnawYl1w" target="_blank" rel="noopener">业界难题-“跨库分页”的四种方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python优雅写法，让你工作效率翻2倍</title>
      <link href="/2018/09/06/Python%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%BF%BB2%E5%80%8D/"/>
      <url>/2018/09/06/Python%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%BF%BB2%E5%80%8D/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h4 id="为多个变量赋值"><a href="#为多个变量赋值" class="headerlink" title="为多个变量赋值"></a>为多个变量赋值</h4><p>有时，有多个变量需要赋值，这时你会怎么赋值呢？</p><h6 id="常规方法："><a href="#常规方法：" class="headerlink" title="常规方法："></a>常规方法：</h6><p>常规方法是给变量逐个赋值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">c = <span class="number">2</span></span><br></pre></td></tr></table></figure><h6 id="优雅方法："><a href="#优雅方法：" class="headerlink" title="优雅方法："></a>优雅方法：</h6><p>直接按顺序对应一一赋值。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h4 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h4><p>需要取出列表中的元素。</p><h6 id="常规方法：-1"><a href="#常规方法：-1" class="headerlink" title="常规方法："></a>常规方法：</h6><p>一般我们知道可以通过下标获取具体元素。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">info = [<span class="string">'brucepk'</span>, <span class="string">'man'</span>, <span class="string">'python'</span>]</span><br><span class="line">name = info[<span class="number">0</span>]</span><br><span class="line">sex = info[<span class="number">1</span>]</span><br><span class="line">tech = info[<span class="number">2</span>]</span><br><span class="line">print(name,sex,tech)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">brucepk man python</span><br></pre></td></tr></table></figure></p><h6 id="优雅方法：-1"><a href="#优雅方法：-1" class="headerlink" title="优雅方法："></a>优雅方法：</h6><p>给出对应变量接收所有元素。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">info = [<span class="string">'brucepk'</span>, <span class="string">'man'</span>, <span class="string">'python'</span>]</span><br><span class="line">name,sex,tech = info</span><br><span class="line">print(name,sex,tech)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">brucepk man python</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 优雅你的判断语句</span></span><br><span class="line"></span><br><span class="line">我们用判断语句来定义一个绝对值函数。</span><br><span class="line"></span><br><span class="line"><span class="comment">###### 常规方法：</span></span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">x = <span class="number">-6</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    y = -x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = x</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h6 id="优雅方法：-2"><a href="#优雅方法：-2" class="headerlink" title="优雅方法："></a>优雅方法：</h6><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-6</span></span><br><span class="line">y = -x <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> x</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="区间判断"><a href="#区间判断" class="headerlink" title="区间判断"></a>区间判断</h4><p>使用 and 连续两次判断的语句，条件都符合时才执行语句。</p><h6 id="常规方法：-2"><a href="#常规方法：-2" class="headerlink" title="常规方法："></a>常规方法：</h6><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">82</span>  </span><br><span class="line"><span class="keyword">if</span> score &gt;=<span class="number">80</span> <span class="keyword">and</span> score &lt; <span class="number">90</span>:  </span><br><span class="line">    level = <span class="string">'B'</span>  </span><br><span class="line">print(level)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果  </span></span><br><span class="line">B</span><br></pre></td></tr></table></figure><h6 id="优雅方法：-3"><a href="#优雅方法：-3" class="headerlink" title="优雅方法："></a>优雅方法：</h6><p>使用链式判断。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">82</span>  </span><br><span class="line"><span class="keyword">if</span>  <span class="number">80</span> &lt;= score &lt; <span class="number">90</span>:  </span><br><span class="line">    level = <span class="string">'B'</span>  </span><br><span class="line">print(level)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果  </span></span><br><span class="line">B</span><br></pre></td></tr></table></figure></p><h4 id="多个值符合条件判断"><a href="#多个值符合条件判断" class="headerlink" title="多个值符合条件判断"></a>多个值符合条件判断</h4><p>多个值任意一个值符合条件即为 True 的情况。</p><h6 id="常规方法：-3"><a href="#常规方法：-3" class="headerlink" title="常规方法："></a>常规方法：</h6><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">if</span> num == <span class="number">1</span> <span class="keyword">or</span> num == <span class="number">3</span> <span class="keyword">or</span> num == <span class="number">5</span>:  </span><br><span class="line">    type = <span class="string">'奇数'</span>  </span><br><span class="line">print(type)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果  </span></span><br><span class="line">奇数</span><br></pre></td></tr></table></figure><h6 id="优雅方法：-4"><a href="#优雅方法：-4" class="headerlink" title="优雅方法："></a>优雅方法：</h6><p>使用关键字 in，让你的语句更优雅。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>):  </span><br><span class="line">    type = <span class="string">'奇数'</span>  </span><br><span class="line">print(type)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果  </span></span><br><span class="line">奇数</span><br></pre></td></tr></table></figure></p><h4 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h4><p>判断元素是空还是非空。</p><h6 id="常规方法：-4"><a href="#常规方法：-4" class="headerlink" title="常规方法："></a>常规方法：</h6><p>一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A,B,C =[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],&#123;&#125;,<span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> len(A) &gt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'A 为非空'</span>)</span><br><span class="line"><span class="keyword">if</span> len(B) &gt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'B 为非空'</span>)</span><br><span class="line"><span class="keyword">if</span> len(C) &gt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'C 为非空'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">A 为非空</span><br></pre></td></tr></table></figure><h6 id="优雅方法：-5"><a href="#优雅方法：-5" class="headerlink" title="优雅方法："></a>优雅方法：</h6><p>if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A,B,C =[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],&#123;&#125;,<span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> A:</span><br><span class="line">    print(<span class="string">'A 为非空'</span>)</span><br><span class="line"><span class="keyword">if</span> B:</span><br><span class="line">    print(<span class="string">'B 为非空'</span>)</span><br><span class="line"><span class="keyword">if</span> C:</span><br><span class="line">    print(<span class="string">'C 为非空'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">A 为非空</span><br></pre></td></tr></table></figure><h4 id="多条件内容判断至少一个成立"><a href="#多条件内容判断至少一个成立" class="headerlink" title="多条件内容判断至少一个成立"></a>多条件内容判断至少一个成立</h4><h6 id="常规方法：-5"><a href="#常规方法：-5" class="headerlink" title="常规方法："></a>常规方法：</h6><p>用 or 连接多个条件。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =<span class="number">90</span>,<span class="number">80</span>,<span class="number">88</span>  </span><br><span class="line"><span class="keyword">if</span> math&lt;<span class="number">60</span> <span class="keyword">or</span> English&lt;<span class="number">60</span> <span class="keyword">or</span> computer&lt;<span class="number">60</span>:  </span><br><span class="line">    print(<span class="string">'not pass'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果  </span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h6 id="优雅方法：-6"><a href="#优雅方法：-6" class="headerlink" title="优雅方法："></a>优雅方法：</h6><p>使用 any 语句。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">math</span>,English,computer =<span class="number">90</span>,<span class="number">59</span>,<span class="number">88</span>  </span><br><span class="line"><span class="keyword">if</span> any([<span class="built_in">math</span>&lt;<span class="number">60</span>,English&lt;<span class="number">60</span>,computer&lt;<span class="number">60</span>]):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'not pass'</span>)  </span><br><span class="line">  </span><br><span class="line"># 结果  </span><br><span class="line"><span class="keyword">not</span> pass</span><br></pre></td></tr></table></figure></p><h4 id="多条件内容判断全部成立"><a href="#多条件内容判断全部成立" class="headerlink" title="多条件内容判断全部成立"></a>多条件内容判断全部成立</h4><h6 id="常规方法：-6"><a href="#常规方法：-6" class="headerlink" title="常规方法："></a>常规方法：</h6><p>使用 and 连接条件做判断。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =<span class="number">90</span>,<span class="number">80</span>,<span class="number">88</span>  </span><br><span class="line"><span class="keyword">if</span> math&gt;<span class="number">60</span> <span class="keyword">and</span> English&gt;<span class="number">60</span> <span class="keyword">and</span> computer&gt;<span class="number">60</span>:  </span><br><span class="line">    print(<span class="string">'pass'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果  </span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h6 id="优雅方法：-7"><a href="#优雅方法：-7" class="headerlink" title="优雅方法："></a>优雅方法：</h6><p>使用 all 方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =<span class="number">90</span>,<span class="number">80</span>,<span class="number">88</span></span><br><span class="line"><span class="keyword">if</span> all([math&gt;<span class="number">60</span>,English&gt;<span class="number">60</span>,computer&gt;<span class="number">60</span>]):</span><br><span class="line">    print(<span class="string">'pass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="遍历序列的元素和元素下标"><a href="#遍历序列的元素和元素下标" class="headerlink" title="遍历序列的元素和元素下标"></a>遍历序列的元素和元素下标</h4><h6 id="常规方法：-7"><a href="#常规方法：-7" class="headerlink" title="常规方法："></a>常规方法：</h6><p>使用 for 循环进行遍历元素和下标。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">L =[<span class="string">'math'</span>, <span class="string">'English'</span>, <span class="string">'computer'</span>, <span class="string">'Physics'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(L)):</span><br><span class="line">    print(i, <span class="string">':'</span>, L[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0</span> : math</span><br><span class="line"><span class="number">1</span> : English</span><br><span class="line"><span class="number">2</span> : computer</span><br><span class="line"><span class="number">3</span> : Physics</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">###### 优雅方法：</span></span><br><span class="line"></span><br><span class="line">使用 enumerate 函数。</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">L =[<span class="string">'math'</span>, <span class="string">'English'</span>, <span class="string">'computer'</span>, <span class="string">'Physics'</span>]</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(L):</span><br><span class="line">    print(k, <span class="string">':'</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0</span> : math</span><br><span class="line"><span class="number">1</span> : English</span><br><span class="line"><span class="number">2</span> : computer</span><br><span class="line"><span class="number">3</span> : Physics</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 循环语句优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 常规方法：</span></span><br><span class="line"></span><br><span class="line">使用简单的 <span class="keyword">for</span> 循环可以达到目的。</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    L.append(i*i)</span><br><span class="line">print(L) </span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">###### 优雅方法：</span></span><br><span class="line"></span><br><span class="line">使用列表生成式，一行代码搞定。</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">print([x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)]) </span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>Python 这些优雅的写法学会了吗？自己赶紧动手试试吧。</p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p><a href="https://yfzhou.coding.me/2018/09/06/Python%E9%AA%9A%E6%93%8D%E4%BD%9C-%E8%BF%98%E5%8E%9F%E5%B7%B2%E6%92%A4%E5%9B%9E%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF/">Python骚操作 | 还原已撤回的微信消息</a></p><p><a href="https://yfzhou.coding.me/2018/08/20/Python%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BE%AE%E4%BF%A1%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/">Python骚操作：微信远程控制电脑</a></p><p><a href="https://yfzhou.coding.me/2018/09/04/%E5%BE%AE%E4%BF%A1%E6%9C%80%E5%BC%BA%E8%8A%B1%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-wxpy/">微信最强花式操作，带你玩转-wxpy</a>  </p><p><a href="https://yfzhou.coding.me/2018/09/05/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Python-%E6%9D%A5%E6%9C%97%E8%AF%BB%E7%BD%91%E9%A1%B5/">手把手教你用 Python 来朗读网页</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python骚操作 | 还原已撤回的微信消息</title>
      <link href="/2018/09/06/Python%E9%AA%9A%E6%93%8D%E4%BD%9C-%E8%BF%98%E5%8E%9F%E5%B7%B2%E6%92%A4%E5%9B%9E%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF/"/>
      <url>/2018/09/06/Python%E9%AA%9A%E6%93%8D%E4%BD%9C-%E8%BF%98%E5%8E%9F%E5%B7%B2%E6%92%A4%E5%9B%9E%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>一大早醒来，发现女神昨晚发来三条消息，但是显示都已撤回，OMG，我错过了什么？群里有一个漂亮妹纸的爆照照片撤回了，想看又看不到！群里大佬分享的经典语录被撤回了，感觉错过一个亿！怎么办？用无所不能的 Python 就可以将这些撤回的消息发给你的微信，让你从此走上人生巅峰!</p><h4 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h4><p>语言：Python3<br>编辑器：Pycharm</p><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>itchat：控制微信的第三方库</p><p>这个库相信大家不陌生了，之前写的 <a href="https://yfzhou.coding.me/2018/09/04/%E5%BE%AE%E4%BF%A1%E6%9C%80%E5%BC%BA%E8%8A%B1%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-wxpy/">微信最强花式操作，带你玩转 wxpy</a> 文章里用的 wxpy 库就是在 itchat 库的基础上封装的。</p><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p>以下截图显示的撤回消息类型依次是文字消息、微信自带表情、图片、语音、定位地图、名片、公众号文章、音乐、视频。有群里撤回的，也有个人号撤回的。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/613709486458704724_看图王.png?x-oss-process=style/w200" alt=""></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/706731996162609493.png?x-oss-process=style/w200" alt=""></p><h4 id="程序思路"><a href="#程序思路" class="headerlink" title="程序思路"></a>程序思路</h4><p><strong>主要由两部分组成：</strong><br><span style="color: rgb(165, 200, 255);">handler_receive_msg()</span>：处理接收到的消息，将消息临时放在字典中。</p><p><span style="color: rgb(165, 200, 255);">send_msg_helper()</span>：将撤回的消息自动发给文件传输助手。</p><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>首先，我们定义一个字典来储存消息，定义消息储存的临时路径。  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 说明：可以撤回的有文本文字、微信自带&amp;收藏的表情、图片、语音、位置、名片、分享、附件、视频</span></span><br><span class="line">msg_dict = &#123;&#125;    <span class="comment"># 定义字典储存消息</span></span><br><span class="line">rev_tmp_dir = <span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>   <span class="comment"># 定义文件存储临时目录</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(rev_tmp_dir):</span><br><span class="line">    os.mkdir(rev_tmp_dir)</span><br><span class="line">face_bug = <span class="keyword">None</span>    <span class="comment"># 处理表情解决方法</span></span><br></pre></td></tr></table></figure><h4 id="接收信息处理"><a href="#接收信息处理" class="headerlink" title="接收信息处理"></a>接收信息处理</h4><p>先将我们需要处理的消息用 msg_register 装饰器进行注册，格式化本地时间，定义消息 ID 和消息时间。如果是群成员而且是自己微信好友撤回消息，则显示撤回消息的名称是你备注的名字，如果没有备注名字，则显示名称为微信昵称。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@itchat.msg_register([TEXT, PICTURE, MAP, CARD, SHARING, RECORDING, ATTACHMENT, VIDEO, FRIENDS],</span></span><br><span class="line">                     isFriendChat=<span class="keyword">True</span>, isGroupChat=<span class="keyword">True</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler_receive_msg</span><span class="params">(msg)</span>:</span>    <span class="comment"># 将接收到的消息存放在字典中，不接受不具有撤回功能的信息</span></span><br><span class="line">    <span class="keyword">global</span> face_bug     <span class="comment"># 全局变量</span></span><br><span class="line">    msg_time_rec = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())   <span class="comment"># 格式化本地时间戳 e: 2018-09-04 22:02:08</span></span><br><span class="line">    msg_id = msg[<span class="string">'MsgId'</span>]   <span class="comment"># 消息ID</span></span><br><span class="line">    msg_time = msg[<span class="string">'CreateTime'</span>]    <span class="comment"># 消息时间</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'ActualNickName'</span> <span class="keyword">in</span> msg:     <span class="comment"># 判断是否为群消息</span></span><br><span class="line">        from_user = msg[<span class="string">'ActualUserName'</span>]    <span class="comment"># 群消息的发送者,用户的唯一标识</span></span><br><span class="line">        msg_from = msg[<span class="string">'ActualNickName'</span>]</span><br><span class="line">        friends = itchat.get_friends(update=<span class="keyword">True</span>)    <span class="comment"># 获取所有好友</span></span><br><span class="line">        <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">            <span class="keyword">if</span> from_user == friend[<span class="string">'UserName'</span>]:      <span class="comment"># 判断群里撤回消息的是否为自己好友</span></span><br><span class="line">                <span class="keyword">if</span> friend[<span class="string">'RemarkName'</span>]:             <span class="comment"># 优先使用好友的备注名称，没有则使用昵称</span></span><br><span class="line">                    msg_from = friend[<span class="string">'RemarkName'</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    msg_from = friend[<span class="string">'NickName'</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>获取你的所有群的消息，判断出撤回的消息来自哪个群，显示出群名称。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groups = itchat.get_chatrooms(update=<span class="keyword">True</span>)        <span class="comment"># 获取所有的群</span></span><br><span class="line"><span class="keyword">for</span> group <span class="keyword">in</span> groups:</span><br><span class="line">    <span class="keyword">if</span> msg[<span class="string">'FromUserName'</span>] == group[<span class="string">'UserName'</span>]:  <span class="comment"># 根据群消息的FromUserName匹配是哪个群</span></span><br><span class="line">        group_name = group[<span class="string">'NickName'</span>]</span><br><span class="line">        group_members = group[<span class="string">'MemberCount'</span>]</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">group_name = group_name + <span class="string">'('</span> + str(group_members) + <span class="string">')'</span></span><br></pre></td></tr></table></figure></p><h4 id="个人消息处理"><a href="#个人消息处理" class="headerlink" title="个人消息处理"></a>个人消息处理</h4><p>如果为个人聊天信息，也是优先显示备注名称，没有备注名就显示昵称。  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:    <span class="comment"># 否则输入个人消息</span></span><br><span class="line">    <span class="keyword">if</span> itchat.search_friends(userName=msg[<span class="string">'FromUserName'</span>])[<span class="string">'RemarkName'</span>]:   <span class="comment"># 优先使用备注名称</span></span><br><span class="line">        msg_from = itchat.search_friends(userName=msg[<span class="string">'FromUserName'</span>])[<span class="string">'RemarkName'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg_from = itchat.search_friends(userName=msg[<span class="string">'FromUserName'</span>])[<span class="string">'NickName'</span>]</span><br><span class="line">    group_name = <span class="string">''</span></span><br></pre></td></tr></table></figure><h4 id="各类型消息处理"><a href="#各类型消息处理" class="headerlink" title="各类型消息处理"></a>各类型消息处理</h4><p>用判断语句对各种类型的消息进行处理，包括文字消息、微信自带的表情和收藏的表情、图片、语音、位置、名片、分享、附件、视频。多条件时这里用了 in 的用法，还记得之前讲  <a href="https://yfzhou.coding.me/2018/09/06/Python%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%BF%BB2%E5%80%8D/#more">Python 优雅的写法</a>  文章里把用 or 连接条件改成用 in，代码更简洁，这样我们通过项目不断的巩固之前学到的知识点，这样才能不断进步。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> msg[<span class="string">'Type'</span>] <span class="keyword">in</span> (<span class="string">'Text'</span>, <span class="string">'Friends'</span>):</span><br><span class="line">    msg_content = msg[<span class="string">'Text'</span>]    <span class="comment"># 如果发送的消息是文本或者好友推荐</span></span><br><span class="line"><span class="keyword">elif</span> msg[<span class="string">'Type'</span>] <span class="keyword">in</span> (<span class="string">'Recording'</span>, <span class="string">'Attachment'</span>, <span class="string">'Video'</span>, <span class="string">'Picture'</span>):</span><br><span class="line">    msg_content = <span class="string">r""</span> + msg[<span class="string">'FileName'</span>]     <span class="comment"># 如果发送的消息是附件、视频、图片、语音</span></span><br><span class="line">    msg[<span class="string">'Text'</span>](rev_tmp_dir + msg[<span class="string">'FileName'</span>])   <span class="comment"># 保存文件</span></span><br><span class="line"><span class="keyword">elif</span> msg[<span class="string">'Type'</span>] == <span class="string">'Card'</span>:</span><br><span class="line">    msg_content = msg[<span class="string">'RecommendInfo'</span>][<span class="string">'NickName'</span>] + <span class="string">r" 的名片"</span></span><br><span class="line"><span class="keyword">elif</span> msg[<span class="string">'Type'</span>] == <span class="string">'Map'</span>:</span><br><span class="line">    x, y, location = re.search(</span><br><span class="line">        <span class="string">"&lt;location x=\"(.*?)\" y=\"(.*?)\".*label=\"(.*?)\".*"</span>, msg[<span class="string">'OriContent'</span>]).group(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> location <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        msg_content = <span class="string">r"纬度-&gt;"</span> + x.__str__() + <span class="string">" 经度-&gt;"</span> + y.__str__()      <span class="comment"># 内容为详细的地址</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg_content = <span class="string">r""</span> + location</span><br><span class="line"><span class="keyword">elif</span> msg[<span class="string">'Type'</span>] == <span class="string">'Sharing'</span>:      <span class="comment"># 如果消息为分享的音乐或者文章，详细的内容为文章的标题或者是分享的名字</span></span><br><span class="line">    msg_content = msg[<span class="string">'Text'</span>]</span><br><span class="line">    msg_share_url = msg[<span class="string">'Url'</span>]      <span class="comment"># 分享链接</span></span><br><span class="line">face_bug = msg_content</span><br></pre></td></tr></table></figure></p><p>更新信息字典</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新字典</span></span><br><span class="line">msg_dict.update(&#123;msg_id: &#123;<span class="string">"msg_from"</span>: msg_from,</span><br><span class="line">                          <span class="string">"msg_time"</span>: msg_time,</span><br><span class="line">                          <span class="string">"msg_time_rec"</span>: msg_time_rec,</span><br><span class="line">                          <span class="string">"msg_type"</span>: msg[<span class="string">"Type"</span>],</span><br><span class="line">                          <span class="string">"msg_content"</span>: msg_content,</span><br><span class="line">                          <span class="string">"msg_share_url"</span>: msg_share_url,</span><br><span class="line">                          <span class="string">"group_name"</span>: group_name&#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="处理撤回消息"><a href="#处理撤回消息" class="headerlink" title="处理撤回消息"></a>处理撤回消息</h4><p>先判断是否是撤回消息，将撤回消息发送到你的文件传输助手里，把上面函数储存的消息的发送人、发送类型、发送时间、撤回的内容发出来。以下是部分代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@itchat.msg_register(NOTE, isFriendChat=True, isGroupChat=True, isMpChat=True)</span></span><br><span class="line"><span class="comment"># 收到note通知类消息，判断是不是撤回并进行相应操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg_helper</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> face_bug</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r"\&lt;\!\[CDATA\[.*撤回了一条消息\]\]\&gt;"</span>, msg[<span class="string">'Content'</span>]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># 获取消息的id</span></span><br><span class="line">        old_msg_id = re.search(</span><br><span class="line">            <span class="string">"\&lt;msgid\&gt;(.*?)\&lt;\/msgid\&gt;"</span>,</span><br><span class="line">            msg[<span class="string">'Content'</span>]).group(<span class="number">1</span>)  <span class="comment"># 在返回的content查找撤回的消息的id</span></span><br><span class="line">        old_msg = msg_dict.get(old_msg_id, &#123;&#125;)</span><br><span class="line">        <span class="keyword">if</span> len(old_msg_id) &lt; <span class="number">11</span>:</span><br><span class="line">            itchat.send_file(rev_tmp_dir + face_bug, toUserName=<span class="string">'filehelper'</span>)</span><br><span class="line">            os.remove(rev_tmp_dir + face_bug)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_body = <span class="string">"快来看啊，有人撤回消息啦！"</span> + <span class="string">"\n"</span> \</span><br><span class="line">                       + old_msg.get(<span class="string">'msg_from'</span>) + <span class="string">" 撤回了 "</span> + old_msg.get(<span class="string">"msg_type"</span>) + <span class="string">" 消息"</span> + <span class="string">"\n"</span> \</span><br><span class="line">                       + old_msg.get(<span class="string">'msg_time_rec'</span>) + <span class="string">"\n"</span> \</span><br><span class="line">                       + <span class="string">"撤回了什么 ⇣"</span> + <span class="string">"\n"</span> \</span><br><span class="line">                       + <span class="string">r""</span> + old_msg.get(<span class="string">'msg_content'</span>)</span><br></pre></td></tr></table></figure><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p>最后用主函数执行微信的登录和运行。第一次需要扫码登录微信，登录时加上 hotReload 参数，为 True 时，短时间内再次运行会保存上次微信的登录态，不需要再次扫码登录。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    itchat.auto_login(hotReload=<span class="keyword">True</span>)</span><br><span class="line">    itchat.run()</span><br></pre></td></tr></table></figure><p>如果你电脑中有安装 Python 环境，在编辑器中直接运行源码或者在 cmd 中运行 py 文件即可。源码获取方式在文末给出。有需要的话以后可以做成界面化工具，挂在服务器上，支持做成界面化工具。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>今天的分享就到这里了，需要优化的地方：长时间运行时会报 ConnectionError 提示的错误，但是不影响发送撤回消息的功能，后期加个异常捕捉机制优化下。</p><p>赶紧动手试试吧，把你朋友撤回的消息发给 TA 看看，看看他是什么反应，有趣的撤回消息发到朋友圈去提高逼格，奈斯！</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/9/6 16:09</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    :</span></span><br><span class="line"><span class="comment"># @File    : withdraw.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：可以撤回的有文本文字、微信自带&amp;收藏的表情、图片、语音、位置、名片、分享、附件、视频</span></span><br><span class="line">msg_dict = &#123;&#125;  <span class="comment"># 定义字典储存消息</span></span><br><span class="line">rev_tmp_dir = <span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>  <span class="comment"># 定义文件存储临时目录</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(rev_tmp_dir):</span><br><span class="line">    os.mkdir(rev_tmp_dir)</span><br><span class="line">face_bug = <span class="keyword">None</span>  <span class="comment"># 处理表情解决方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register([TEXT, PICTURE, MAP, CARD, SHARING, RECORDING, ATTACHMENT, VIDEO, FRIENDS],</span></span><br><span class="line">                     isFriendChat=<span class="keyword">True</span>, isGroupChat=<span class="keyword">True</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler_receive_msg</span><span class="params">(msg)</span>:</span>  <span class="comment"># 将接收到的消息存放在字典中，不接受不具有撤回功能的信息</span></span><br><span class="line">    <span class="keyword">global</span> face_bug  <span class="comment"># 全局变量</span></span><br><span class="line">    msg_time_rec = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())  <span class="comment"># 格式化本地时间戳 e: 2018-09-04 22:02:08</span></span><br><span class="line">    msg_id = msg[<span class="string">'MsgId'</span>]  <span class="comment"># 消息ID</span></span><br><span class="line">    msg_time = msg[<span class="string">'CreateTime'</span>]  <span class="comment"># 消息时间</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'ActualNickName'</span> <span class="keyword">in</span> msg:  <span class="comment"># 判断是否为群消息</span></span><br><span class="line">        from_user = msg[<span class="string">'ActualUserName'</span>]  <span class="comment"># 群消息的发送者,用户的唯一标识</span></span><br><span class="line">        msg_from = msg[<span class="string">'ActualNickName'</span>]</span><br><span class="line">        friends = itchat.get_friends(update=<span class="keyword">True</span>)  <span class="comment"># 获取所有好友</span></span><br><span class="line">        <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">            <span class="keyword">if</span> from_user == friend[<span class="string">'UserName'</span>]:  <span class="comment"># 判断群里撤回消息的是否为自己好友</span></span><br><span class="line">                <span class="keyword">if</span> friend[<span class="string">'RemarkName'</span>]:  <span class="comment"># 优先使用好友的备注名称，没有则使用昵称</span></span><br><span class="line">                    msg_from = friend[<span class="string">'RemarkName'</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    msg_from = friend[<span class="string">'NickName'</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        groups = itchat.get_chatrooms(update=<span class="keyword">True</span>)  <span class="comment"># 获取所有的群</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> groups:</span><br><span class="line">            <span class="keyword">if</span> msg[<span class="string">'FromUserName'</span>] == group[<span class="string">'UserName'</span>]:  <span class="comment"># 根据群消息的FromUserName匹配是哪个群</span></span><br><span class="line">                group_name = group[<span class="string">'NickName'</span>]</span><br><span class="line">                group_members = group[<span class="string">'MemberCount'</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        group_name = group_name + <span class="string">'('</span> + str(group_members) + <span class="string">')'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 否则输入个人消息</span></span><br><span class="line">        <span class="keyword">if</span> itchat.search_friends(userName=msg[<span class="string">'FromUserName'</span>])[<span class="string">'RemarkName'</span>]:  <span class="comment"># 优先使用备注名称</span></span><br><span class="line">            msg_from = itchat.search_friends(userName=msg[<span class="string">'FromUserName'</span>])[<span class="string">'RemarkName'</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_from = itchat.search_friends(userName=msg[<span class="string">'FromUserName'</span>])[<span class="string">'NickName'</span>]</span><br><span class="line">        group_name = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    msg_content = <span class="keyword">None</span>  <span class="comment"># 消息内容</span></span><br><span class="line">    msg_share_url = <span class="keyword">None</span>  <span class="comment"># 分享的链接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> msg[<span class="string">'Type'</span>] <span class="keyword">in</span> (<span class="string">'Text'</span>, <span class="string">'Friends'</span>):</span><br><span class="line">        msg_content = msg[<span class="string">'Text'</span>]  <span class="comment"># 如果发送的消息是文本或者好友推荐</span></span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">'Type'</span>] <span class="keyword">in</span> (<span class="string">'Recording'</span>, <span class="string">'Attachment'</span>, <span class="string">'Video'</span>, <span class="string">'Picture'</span>):</span><br><span class="line">        msg_content = <span class="string">r""</span> + msg[<span class="string">'FileName'</span>]  <span class="comment"># 如果发送的消息是附件、视频、图片、语音</span></span><br><span class="line">        msg[<span class="string">'Text'</span>](rev_tmp_dir + msg[<span class="string">'FileName'</span>])  <span class="comment"># 保存文件</span></span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">'Type'</span>] == <span class="string">'Card'</span>:</span><br><span class="line">        msg_content = msg[<span class="string">'RecommendInfo'</span>][<span class="string">'NickName'</span>] + <span class="string">r" 的名片"</span></span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">'Type'</span>] == <span class="string">'Map'</span>:</span><br><span class="line">        x, y, location = re.search(</span><br><span class="line">            <span class="string">"&lt;location x=\"(.*?)\" y=\"(.*?)\".*label=\"(.*?)\".*"</span>, msg[<span class="string">'OriContent'</span>]).group(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> location <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            msg_content = <span class="string">r"纬度-&gt;"</span> + x.__str__() + <span class="string">" 经度-&gt;"</span> + y.__str__()  <span class="comment"># 内容为详细的地址</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_content = <span class="string">r""</span> + location</span><br><span class="line">    <span class="keyword">elif</span> msg[<span class="string">'Type'</span>] == <span class="string">'Sharing'</span>:  <span class="comment"># 如果消息为分享的音乐或者文章，详细的内容为文章的标题或者是分享的名字</span></span><br><span class="line">        msg_content = msg[<span class="string">'Text'</span>]</span><br><span class="line">        msg_share_url = msg[<span class="string">'Url'</span>]  <span class="comment"># 分享链接</span></span><br><span class="line">    face_bug = msg_content</span><br><span class="line">    <span class="comment"># 更新字典</span></span><br><span class="line">    msg_dict.update(&#123;msg_id: &#123;<span class="string">"msg_from"</span>: msg_from,</span><br><span class="line">                              <span class="string">"msg_time"</span>: msg_time,</span><br><span class="line">                              <span class="string">"msg_time_rec"</span>: msg_time_rec,</span><br><span class="line">                              <span class="string">"msg_type"</span>: msg[<span class="string">"Type"</span>],</span><br><span class="line">                              <span class="string">"msg_content"</span>: msg_content,</span><br><span class="line">                              <span class="string">"msg_share_url"</span>: msg_share_url,</span><br><span class="line">                              <span class="string">"group_name"</span>: group_name&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(NOTE, isFriendChat=True, isGroupChat=True, isMpChat=True)</span></span><br><span class="line"><span class="comment"># 收到note通知类消息，判断是不是撤回并进行相应操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg_helper</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> face_bug</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r"\&lt;\!\[CDATA\[.*撤回了一条消息\]\]\&gt;"</span>, msg[<span class="string">'Content'</span>]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># 获取消息的id</span></span><br><span class="line">        old_msg_id = re.search(</span><br><span class="line">            <span class="string">"\&lt;msgid\&gt;(.*?)\&lt;\/msgid\&gt;"</span>,</span><br><span class="line">            msg[<span class="string">'Content'</span>]).group(<span class="number">1</span>)  <span class="comment"># 在返回的content查找撤回的消息的id</span></span><br><span class="line">        old_msg = msg_dict.get(old_msg_id, &#123;&#125;)</span><br><span class="line">        <span class="keyword">if</span> len(old_msg_id) &lt; <span class="number">11</span>:</span><br><span class="line">            itchat.send_file(rev_tmp_dir + face_bug, toUserName=<span class="string">'filehelper'</span>)</span><br><span class="line">            os.remove(rev_tmp_dir + face_bug)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg_body = <span class="string">"快来看啊，有人撤回消息啦！"</span> + <span class="string">"\n"</span> \</span><br><span class="line">                       + old_msg.get(<span class="string">'msg_from'</span>) + <span class="string">" 撤回了 "</span> + old_msg.get(<span class="string">"msg_type"</span>) + <span class="string">" 消息"</span> + <span class="string">"\n"</span> \</span><br><span class="line">                       + old_msg.get(<span class="string">'msg_time_rec'</span>) + <span class="string">"\n"</span> \</span><br><span class="line">                       + <span class="string">"撤回了什么 ⇣"</span> + <span class="string">"\n"</span> \</span><br><span class="line">                       + <span class="string">r""</span> + old_msg.get(<span class="string">'msg_content'</span>)</span><br><span class="line">            <span class="comment"># 如果是分享存在链接</span></span><br><span class="line">            <span class="keyword">if</span> old_msg[<span class="string">'msg_type'</span>] == <span class="string">"Sharing"</span>:</span><br><span class="line">                msg_body += <span class="string">"\n就是这个链接➣ "</span> + old_msg.get(<span class="string">'msg_share_url'</span>)</span><br><span class="line">            itchat.send(msg_body, toUserName=<span class="string">'filehelper'</span>)  <span class="comment"># 将撤回消息发送到文件助手</span></span><br><span class="line">            <span class="keyword">if</span> old_msg[<span class="string">"msg_type"</span>] <span class="keyword">in</span> (</span><br><span class="line">                    <span class="string">"Picture"</span>, <span class="string">"Recording"</span>, <span class="string">"Video"</span>, <span class="string">"Attachment"</span>):</span><br><span class="line">                file = <span class="string">'@fil@%s'</span> % (rev_tmp_dir + old_msg[<span class="string">'msg_content'</span>])</span><br><span class="line">                itchat.send(msg=file, toUserName=<span class="string">'filehelper'</span>)</span><br><span class="line">                os.remove(rev_tmp_dir + old_msg[<span class="string">'msg_content'</span>])</span><br><span class="line">            msg_dict.pop(old_msg_id)  <span class="comment"># 删除字典旧消息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    itchat.auto_login(hotReload=<span class="keyword">True</span>)</span><br><span class="line">    itchat.run()</span><br></pre></td></tr></table></figure><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p><a href="https://yfzhou.coding.me/2018/08/20/Python%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BE%AE%E4%BF%A1%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/">Python骚操作：微信远程控制电脑</a></p><p><a href="https://yfzhou.coding.me/2018/09/04/%E5%BE%AE%E4%BF%A1%E6%9C%80%E5%BC%BA%E8%8A%B1%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-wxpy/">微信最强花式操作，带你玩转-wxpy</a>  </p><p><a href="https://yfzhou.coding.me/2018/09/05/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Python-%E6%9D%A5%E6%9C%97%E8%AF%BB%E7%BD%91%E9%A1%B5/">手把手教你用 Python 来朗读网页</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>InnoDB，快照读，在RR和RC下有何差异？</title>
      <link href="/2018/09/05/InnoDB%EF%BC%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%8C%E5%9C%A8RR%E5%92%8CRC%E4%B8%8B%E6%9C%89%E4%BD%95%E5%B7%AE%E5%BC%82%EF%BC%9F/"/>
      <url>/2018/09/05/InnoDB%EF%BC%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%8C%E5%9C%A8RR%E5%92%8CRC%E4%B8%8B%E6%9C%89%E4%BD%95%E5%B7%AE%E5%BC%82%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>为了保证文章知识体系的完整性，先简单解释下<strong>快照读</strong>，<strong>读提交</strong>，<strong>可重复读</strong>。</p><p><strong>快照读</strong>(Snapshot Read)</p><p>MySQL数据库，InnoDB存储引擎，为了提高并发，使用MVCC机制，在并发事务时，通过读取数据行的历史数据版本，不加锁，来提高并发的一种<span style="letter-spacing: 1px;font-size: 14px;color: rgb(255, 76, 0);">不加锁一致性读</span>(Consistent Nonlocking Read)。</p><p><strong>读提交</strong>(Read Committed)</p><ul><li><p>数据库领域，事务隔离级别的一种，简称RC</p></li><li><p>它解决“读脏”问题，保证读取到的数据行都是已提交事务写入的</p></li><li><p>它可能存在“读幻影行”问题，同一个事务里，连续相同的read可能读到不同的结果集</p></li></ul><p><strong>可重复读</strong>(Repeated Read)</p><ul><li><p>数据库领域，事务隔离级别的一种，简称RR</p></li><li><p>它不但解决“读脏”问题，还解决了“读幻影行”问题，同一个事务里，连续相同的read读到相同的结果集</p></li></ul><p>在<strong>读提交</strong>(<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;">RC</span>)，<strong>可重复读</strong>(<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;">RR</span>)两个不同的事务的隔离级别下，<strong>快照读</strong>有什么不同呢？  </p><p>先说<strong>结论</strong>：</p><ul><li><p>事务总能够读取到，自己写入(update /insert /delete)的行记录</p></li><li><p>RC下，快照读总是能读到最新的行数据快照，当然，必须是已提交事务写入的</p></li><li><p>RR下，某个事务首次read记录的时间为T，未来不会读取到T时间之后已提交事务写入的记录，以保证连续相同的read读到相同的结果集  </p></li></ul><p><span style="font-size: 14px;letter-spacing: 1px;color: rgb(0, 82, 255);"><br><em>画外音：可以看到</em></span></p><p><span style="font-size: 14px;letter-spacing: 1px;color: rgb(0, 82, 255);"><em>(1)和并发事务的开始时间没关系，和事务首次read的时间有关；</em></span></p><p><span style="font-size: 14px;letter-spacing: 1px;color: rgb(0, 82, 255);"><em>(2)由于不加锁，和互斥关系也不大；</em></span></p><p>InnoDB表：  </p><p>t(id PK, name);  </p><p>表中有三条记录：<br>1, shenjian<br>2, zhangsan<br>3, lisi</p><p><span style="color: rgb(255, 76, 0);font-size: 16px;"><em><strong><span style="letter-spacing: 1px;font-size: 16px;">case 1</span></strong></em></span>，两个并发事务A，B执行的时间序列如下（A先于B开始，B先于A结束）：</p><p>A1: start transaction;<br>         B1: start transaction;<br>A2: select <em> from t;<br>         B2: insert into t values (4, wangwu);<br>A3: select </em> from t;<br>         B3: commit;<br>A4: select * from t;</p><p><strong>提问1</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">可重复读RR</span>，事务A中的三次查询，A2, A3, A4分别读到什么结果集？</p><p><strong>回答</strong>：RR下</p><p>(1)A2读到的结果集肯定是{1, 2, 3}，这是事务A的第一个read，假设为时间T；</p><p>(2)A3读到的结果集也是{1, 2, 3}，因为B还没有提交；</p><p>(3)A4读到的结果集还是{1, 2, 3}，因为事务B是在时间T之后提交的，A4得读到和A2一样的记录；</p><p><strong>提问2</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">读提交RC</span>，A2, A3, A4又分别读到什么结果集呢？</p><p><strong>回答</strong>：RC下</p><p>(1)A2读到的结果集是{1, 2, 3}；</p><p>(2)A3读到的结果集也是{1, 2, 3}，因为B还没有提交；</p><p>(3)A4读到的结果集还是{1, 2, 3, 4}，因为事务B已经提交；</p><p><span style="color: rgb(255, 76, 0);font-size: 16px;"><em><strong><span style="letter-spacing: 1px;font-size: 16px;">case 2</span></strong></em></span>，仍然是上面的两个事务，只是A和B开始时间稍有不同（B先于A开始，B先于A结束）：  </p><pre><code>&lt;span style=&quot;margin: 0px;padding: 0px;color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; B1: start transaction;&lt;/span&gt;</code></pre><p><span style="margin: 0px;padding: 0px;color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;">A1: start transaction;</span></p><p>A2: select <em> from t;<br>         B2: insert into t values (4, wangwu);<br>A3: select </em> from t;<br>         B3: commit;<br>A4: select * from t;  </p><p><strong>提问3</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">可重复读RR</span>，事务A中的三次查询，A2, A3, A4分别读到什么结果集？  </p><p><strong>提问4</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">读提交RC</span>，A2, A3, A4的结果集又是什么呢？  </p><p><strong>回答</strong>：事务的开始时间不一样，不会影响“快照读”的结果，所以结果集和case 1一样。</p><p><span style="color: rgb(255, 76, 0);font-size: 16px;"><em><strong><span style="letter-spacing: 1px;font-size: 16px;">case 3</span></strong></em></span>，仍然是并发的事务A与B（A先于B开始，B先于A结束）：</p><p>A1: start transaction;<br>         B1: start transaction;<br>         B2: insert into t values (4, wangwu);<br>         B3: commit;<br>A2: select * from t;  </p><p><strong>提问5</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">可重复读RR</span>，事务A中的A2查询，结果集是什么？  </p><p><strong>提问6</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">读提交RC</span>，A2的结果集又是什么呢？  </p><p><strong>回答</strong>：在RR下，</p><p>A2是事务A的第一个read，假设为时间T，它能读取到T之前提交事务写入的数据行，故结果集为{1, 2, 3, 4}。在RC下，没有疑问，一定是{1, 2, 3, 4}。</p><p><span style="color: rgb(255, 76, 0);font-size: 16px;"><em><strong><span style="letter-spacing: 1px;font-size: 16px;">case 4</span></strong></em></span>，事务开始的时间再换一下（B先于A开始，B先于A结束）：</p><pre><code>&lt;span style=&quot;color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; B1: start transaction;&lt;/span&gt;</code></pre><p><span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 12px;display: inline !important;float: none;background-color: transparent;">A1: start transaction;</span></p><pre><code>B2: insert into t values (4, wangwu);  B3: commit;  </code></pre><p>A2: select * from t;</p><p><strong>提问7</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">可重复读RR</span>，事务A中的A2查询，结果集是什么？  </p><p><strong>提问8</strong>：假设事务的隔离级别是<span style="color: rgb(255, 76, 0);letter-spacing: 1px;font-size: 14px;">读提交RC</span>，A2的结果集又是什么呢？</p><p><strong>回答</strong>：事务的开始时间不一样，不会影响“快照读”的结果，所以结果集和case 3一样。</p><p>啰嗦说了这么多，用昨天一位网友“山峰”同学的话<strong>总结</strong>：</p><ul><li><p>RR下，事务在第一个Read操作时，会建立Read View</p></li><li><p>RC下，事务在每次Read操作时，都会建立Read View</p></li></ul><p>相关推荐：  </p><p>《<a href="https://yfzhou.coding.me/2018/08/14/InnoDB%E5%B9%B6%E5%8F%91%E5%A6%82%E6%AD%A4%E9%AB%98%EF%BC%8C%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E5%9C%A8%E8%BF%99%EF%BC%9F/">InnoDB，并发如此之高的原因</a>》</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> InnoDB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你用 Python 来朗读网页</title>
      <link href="/2018/09/05/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Python-%E6%9D%A5%E6%9C%97%E8%AF%BB%E7%BD%91%E9%A1%B5/"/>
      <url>/2018/09/05/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-Python-%E6%9D%A5%E6%9C%97%E8%AF%BB%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>是不是有的时候懒得自己看新闻？那么不妨试试用 Python 来朗读给你听吧。</p><p>网页转换成语音，步骤无外乎：</p><ol><li>网页正文识别，获取到正文的文本内容；</li><li>文本转语音，通过接口将文本转换成语音文件；</li><li>语音文件的发声，即将语音文件读出；</li></ol><h1 id="网页正文识别"><a href="#网页正文识别" class="headerlink" title="网页正文识别"></a><a href="#网页正文识别" title="网页正文识别"></a>网页正文识别</h1><p>我们之所以用 Python，就是因为 Python 有着丰富的库，网页正文识别也不在话下。这里我尝试了 <code>readability</code>、<code>goose-extractor</code>、<code>cx-extractor-python</code>，</p><h2 id="readability"><a href="#readability" class="headerlink" title="readability"></a><a href="#readability" title="readability"></a>readability</h2><p><a href="https://github.com/buriy/python-readability" target="_blank" rel="noopener">readability</a> 支持 Python3，使用 <code>pip install readability-lxml</code> 安装即可。</p><p>readability 使用起来也很方便：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> readability <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://hoxis.github.io/run-ansible-without-specifying-the-inventory-but-the-host-directly.html'</span>)</span><br><span class="line">doc = Document(response.text)</span><br><span class="line">print(doc.title())</span><br></pre></td></tr></table></figure><p>但是 readability 提取到的正文内容不是文本，里面仍包含 HTML 标签。</p><p>当然也可以结合其他组件再对 HTML 进行处理，如 <code>html2text</code>，我们这里就不再延伸，有兴趣的可以自行尝试。</p><h2 id="goose3"><a href="#goose3" class="headerlink" title="goose3"></a><a href="#goose3" title="goose3"></a>goose3</h2><p>Goose 本来是一个用 Java 编写的文章提取器，后来就有了 Python 实现版： <a href="https://github.com/goose3/goose3" target="_blank" rel="noopener">goose3</a> 。</p><p>使用起来也很方便，同时对中文支持也不错。使用 <code>pip install goose3</code> 即可安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from goose3 import Goose</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from goose3.text import StopWordsChinese</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; url  = <span class="string">'http://news.china.com/socialgd/10000169/20180616/32537640_all.html'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; g = Goose(&#123;<span class="string">'stopwords_class'</span>: StopWordsChinese&#125;)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; article = g.extract(url=url)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(article.cleaned_text[:150])</span></span><br><span class="line">北京时间6月15日23:00(圣彼得堡当地时间18:00)，2018年世界杯B组一场比赛在圣彼得堡球场展开角逐，伊朗1比0险胜摩洛哥，伊朗前锋阿兹蒙半场结束前错过单刀机会，鲍哈杜兹第95分钟自摆乌</span><br><span class="line">龙。这是伊朗20年来首度在世界杯决赛圈取胜。</span><br><span class="line"></span><br><span class="line">本届世界杯，既相继出现替补便进球，贴补梅开二度以及东道主</span><br></pre></td></tr></table></figure><p>可以看出网页正文提取效果还不错，基本满足我们的要求，可以使用！</p><div class="note info"><p>注意：goose 还有另外一个 Python2 的版本：<code>Python-Goose</code>，使用方法和 goose3 基本一样。</p></div><h1 id="文本转语音"><a href="#文本转语音" class="headerlink" title="文本转语音"></a><a href="#文本转语音" title="文本转语音"></a>文本转语音</h1><p>文本转语音，<a href="http://ai.baidu.com/docs#/TTS-API/top" target="_blank" rel="noopener">百度</a>、<a href="https://helpcdn.aliyun.com/document_detail/52793.html?spm=a2c4g.11186623.6.577.CyUtzC" target="_blank" rel="noopener">阿里</a>、<a href="https://cloud.tencent.com/document/product/441/8217" target="_blank" rel="noopener">腾讯</a>、<a href="http://doc.xfyun.cn/rest_api/" target="_blank" rel="noopener">讯飞</a>等都有提供 REST API 接口，阿里和腾讯的申请相对时间较长，阿里的貌似还要收费，百度和讯飞的在线申请后即可使用，没办法，好的东西得来总是要曲折一些。其中百度的没有调用量的限制（其实默认是 200000 次/天），讯飞有每天 500 次的限制。</p><p>这里我们使用百度的 REST API 接口中的语言合成接口，一方面原因是百度的调用次数没有限制，另一方面，我大致看了下讯飞的接口文档，接口限制还是比较多的。还有就是百度提供了 REST API 的 Python 封装，使用也更方便。</p><h2 id="baidu-aip-的使用"><a href="#baidu-aip-的使用" class="headerlink" title="baidu-aip 的使用"></a><a href="#baidu-aip-的使用" title="baidu-aip 的使用"></a>baidu-aip 的使用</h2><p>百度提供了 Python SDK，使用 <code>pip install baidu-aip</code> 可以直接安装。接口的使用可以参考接口文档：<a href="http://ai.baidu.com/docs#/TTS-Online-Python-SDK/top" target="_blank" rel="noopener">http://ai.baidu.com/docs#/TTS-Online-Python-SDK/top</a>。</p><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipSpeech</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">你的 APPID AK SK </span></span><br><span class="line"><span class="string">均可在服务控制台中的应用列表中查看。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">APP_ID = <span class="string">'你的 App ID'</span></span><br><span class="line">API_KEY = <span class="string">'你的 Api Key'</span></span><br><span class="line">SECRET_KEY = <span class="string">'你的 Secret Key'</span></span><br><span class="line"></span><br><span class="line">client = AipSpeech(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result  = client.synthesis(<span class="string">'你好，你在做什么'</span>, <span class="string">'zh'</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    <span class="string">'vol'</span>: <span class="number">5</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别正确返回语音二进制 错误则返回dict 参照下面错误码</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(result, dict):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'auido.mp3'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(result)</span><br></pre></td></tr></table></figure><p>接口参数：</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th><th>是否必须</th></tr></thead><tbody><tr><td>tex</td><td>String</td><td>合成的文本，使用UTF-8编码，请注意文本长度必须小于1024字节</td><td>是</td></tr><tr><td>lang</td><td>String</td><td>语言选择,填写zh</td><td>是</td></tr><tr><td>ctp</td><td>String</td><td>客户端类型选择，web端填写1</td><td>是</td></tr><tr><td>cuid</td><td>String</td><td>用户唯一标识，用来区分用户，填写机器 MAC 地址或 IMEI 码，长度为60以内</td><td>否</td></tr><tr><td>spd</td><td>String</td><td>语速，取值0-9，默认为5中语速</td><td>否</td></tr><tr><td>pit</td><td>String</td><td>音调，取值0-9，默认为5中语调</td><td>否</td></tr><tr><td>vol</td><td>String</td><td>音量，取值0-15，默认为5中音量</td><td>否</td></tr><tr><td>per</td><td>String</td><td>发音人选择,0为女声，1为男声，3为情感合成-度逍遥，4为情感合成-度丫丫，默认为普通女</td><td>否</td></tr></tbody></table><p>接口对单次传入的文本进行了限制，合成文本长度必须小于1024字节，如果文本长度过长，就需要进行切割处理，采用多次请求的方式，分别转换成语音文件，最后再将多个语音文件合并成一个。</p><h2 id="文本切割"><a href="#文本切割" class="headerlink" title="文本切割"></a><a href="#文本切割" title="文本切割"></a>文本切割</h2><p>可以使用如下代码将文本分割成多个长度为 500 的文本列表</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文本按 500 的长度分割成多个文本</span></span><br><span class="line">text_list = [text[i:i+<span class="number">500</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(text), <span class="number">500</span>)]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">[](<span class="comment">#语言文件合并 "语言文件合并")语言文件合并</span></span><br><span class="line">--------------------------</span><br><span class="line"></span><br><span class="line">我们使用 [pydub](https://github.com/jiaaro/pydub) 来处理生成的音频文件。使用 `pip install pydub` 即可安装。</span><br><span class="line"></span><br><span class="line">另外还 Ubuntu 环境需要安装依赖 `sudo apt-get install libav-tools`，Windows 环境需要到 [https://ffmpeg.zeranoe.com/builds/](https://ffmpeg.zeranoe.com/builds/) 下载 `FFmpeg`，并将其配置到环境变量中。</span><br><span class="line"></span><br><span class="line">若还有问题，可以参考官网配置：[https://github.com/jiaaro/pydub](https://github.com/jiaaro/pydub)。</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line"><span class="comment"># 合并音频文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_voice</span><span class="params">(file_list)</span>:</span></span><br><span class="line">    voice_dict = &#123;&#125;</span><br><span class="line">    song = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> i,f <span class="keyword">in</span> enumerate(file_list):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            song = AudioSegment.from_file(f,<span class="string">"mp3"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 拼接音频文件</span></span><br><span class="line">            song += AudioSegment.from_file(f,<span class="string">"mp3"</span>)</span><br><span class="line">        <span class="comment"># 删除临时音频</span></span><br><span class="line">        os.unlink(f)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 导出合并后的音频文件，格式为MP3格式</span></span><br><span class="line">    file_name = str(uuid.uuid1()) + <span class="string">".mp3"</span></span><br><span class="line">    song.export(file_name, format=<span class="string">"mp3"</span>)</span><br><span class="line">    <span class="keyword">return</span> file_name</span><br></pre></td></tr></table></figure><p>通过百度的接口，我们可以将文字转化成音频文件，下面的问题就是如何播放音频文件。</p><h1 id="音频文件播放"><a href="#音频文件播放" class="headerlink" title="音频文件播放"></a><a href="#音频文件播放" title="音频文件播放"></a>音频文件播放</h1><p>网上获取到 Python 播放 wav 文件的方式由好几种，包括 pyaudio、pygame、winsound、playsound。不过测试下来，只有 <a href="https://github.com/TaylorSMarks/playsound" target="_blank" rel="noopener">playsound</a> 成功。其他方式有兴趣的可以试下，有问题可以留言交流。</p><p>使用 <code>pip install playsound</code> 安装后即可使用。</p><p>使用也很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> from playsound import playsound</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; playsound(<span class="string">'/path/to/a/sound/file/you/want/to/play.mp3'</span>)</span></span><br></pre></td></tr></table></figure><div class="note info"><p>说明：音频的播放需要在图形化页面下运行，因为命令行模式下，没有播放声音的出口。</p></div><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><a href="#实现代码" title="实现代码"></a>实现代码</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> pydub <span class="keyword">import</span> AudioSegment</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipSpeech</span><br><span class="line"><span class="keyword">from</span> playsound <span class="keyword">import</span> playsound</span><br><span class="line"><span class="keyword">from</span> goose3 <span class="keyword">import</span> Goose</span><br><span class="line"><span class="keyword">from</span> goose3.text <span class="keyword">import</span> StopWordsChinese</span><br><span class="line"></span><br><span class="line"><span class="string">""" 你的 百度 APPID AK SK """</span></span><br><span class="line">APP_ID = <span class="string">'11407664'</span></span><br><span class="line">API_KEY = <span class="string">'GT69E8M6sgOcSnIGElrgXo1e'</span></span><br><span class="line">SECRET_KEY = <span class="string">'fOCr1mwnyGOEjZg93GoonaGqzqp0paIB'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行输入参数处理</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'-u'</span>, <span class="string">'--url'</span>, type=str, help=<span class="string">"input the target url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">URL = args.url</span><br><span class="line"></span><br><span class="line">client = AipSpeech(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_to_voice</span><span class="params">(text)</span>:</span></span><br><span class="line">    file_name = str(uuid.uuid1()) + <span class="string">'.mp3'</span></span><br><span class="line">    result = client.synthesis(text, <span class="string">'zh'</span>, <span class="number">3</span>, &#123;</span><br><span class="line">        <span class="string">'vol'</span>: <span class="number">5</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 识别正确返回语音二进制 错误则返回 dict 参照下面错误码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(result, dict):</span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(result)</span><br><span class="line">    <span class="keyword">return</span> file_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_text</span><span class="params">(url)</span>:</span></span><br><span class="line">    g = Goose(&#123;<span class="string">'stopwords_class'</span>: StopWordsChinese&#125;)</span><br><span class="line">    article = g.extract(url=url)</span><br><span class="line">    <span class="keyword">return</span> article.cleaned_text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并音频文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_voice</span><span class="params">(file_list)</span>:</span></span><br><span class="line">    voice_dict = &#123;&#125;</span><br><span class="line">    song = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> i,f <span class="keyword">in</span> enumerate(file_list):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            song = AudioSegment.from_file(f,<span class="string">"mp3"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 拼接音频文件</span></span><br><span class="line">            song += AudioSegment.from_file(f,<span class="string">"mp3"</span>)</span><br><span class="line">        <span class="comment"># 删除临时音频</span></span><br><span class="line">        os.unlink(f)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 导出合并后的音频文件，格式为MP3格式</span></span><br><span class="line">    file_name = str(uuid.uuid1()) + <span class="string">".mp3"</span></span><br><span class="line">    song.export(file_name, format=<span class="string">"mp3"</span>)</span><br><span class="line">    <span class="keyword">return</span> file_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># url = "http://news.china.com/socialgd/10000169/20180616/32537640_all.html"</span></span><br><span class="line">    text = get_text(URL)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将文本按 500 的长度分割成多个文本</span></span><br><span class="line">    text_list = [text[i:i+<span class="number">500</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(text), <span class="number">500</span>)]</span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> text_list:</span><br><span class="line">        file_list.append(text_to_voice(t))</span><br><span class="line">    <span class="comment"># print(file_list)</span></span><br><span class="line">    final_voice = merge_voice(file_list)</span><br><span class="line">    print(final_voice)</span><br><span class="line">    <span class="comment"># 播放音频</span></span><br><span class="line">    playsound(final_voice)</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a><a href="#运行" title="运行"></a>运行</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python page2voice<span class="selector-class">.py</span> -u <span class="string">"https://so.gushiwen.org/shiwenv_c244fc77f6fb.aspx"</span></span><br></pre></td></tr></table></figure><p>运行后，代码就会自动解析网页并进行朗读啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#总结" title="总结"></a>总结</h1><p>至此，网页到音频的转换就结束了，当然程序没有这么完美，比如中英文混合的网页解析和转换的结果就不怎么理想，但是纯中文的新闻页面效果还是不错的。</p><p>源码已上传至 <a href="https://github.com/hoxis/to_voice/blob/master/page2voice.py" target="_blank" rel="noopener">GitHub</a>，欢迎取阅。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python(wordcloud+jieba)生成中文词云图</title>
      <link href="/2018/09/04/Python-wordcloud-jieba-%E7%94%9F%E6%88%90%E4%B8%AD%E6%96%87%E8%AF%8D%E4%BA%91%E5%9B%BE/"/>
      <url>/2018/09/04/Python-wordcloud-jieba-%E7%94%9F%E6%88%90%E4%B8%AD%E6%96%87%E8%AF%8D%E4%BA%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>基于Python的词云生成类库,很好用,而且功能强大.博主个人比较推荐</p><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> wordcloud</span><br><span class="line">pip <span class="keyword">install</span> jieba</span><br></pre></td></tr></table></figure><p>话不多说，直接上代码</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/9/4 13:52</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : demo10.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 词云生成工具</span></span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, ImageColorGenerator</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前的项目文件加的路径</span></span><br><span class="line">d = path.dirname(__file__)</span><br><span class="line"><span class="comment"># 读取一个txt文件</span></span><br><span class="line">text = open(<span class="string">r'C:\Users\Administrator\Desktop\阿里传：这是阿里巴巴的世界美特里斯曼.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line"><span class="comment"># 读入背景图片</span></span><br><span class="line">bg_pic = plt.imread(<span class="string">r'C:\Users\Administrator\Pictures\Other\155061877268618276.jpg'</span>)</span><br><span class="line">wordlist_after_jieba = jieba.cut(text, cut_all=<span class="keyword">True</span>)</span><br><span class="line">wl_space_split = <span class="string">" "</span>.join(wordlist_after_jieba)</span><br><span class="line"><span class="comment"># 生成词云</span></span><br><span class="line">font = d + <span class="string">r'static/simkai.ttf'</span></span><br><span class="line">wc = WordCloud(</span><br><span class="line">    mask=bg_pic,</span><br><span class="line">    background_color=<span class="string">'white'</span>,</span><br><span class="line">    font_path=font,</span><br><span class="line">    scale=<span class="number">1.5</span>,</span><br><span class="line">    max_words=<span class="number">1500</span></span><br><span class="line">).generate(wl_space_split)</span><br><span class="line">image_colors = ImageColorGenerator(bg_pic)</span><br><span class="line"><span class="comment"># 图片背景</span></span><br><span class="line">bg_color = ImageColorGenerator(bg_pic)</span><br><span class="line"><span class="comment"># 开始画图</span></span><br><span class="line">plt.imshow(wc.recolor(color_func=bg_color))</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">wc.to_file(d + <span class="string">r"/image/render_09.png"</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>text文本是《阿里传》<br>font为字体路径<br></p></div><h2 id="Wordcloud各参数含义"><a href="#Wordcloud各参数含义" class="headerlink" title="Wordcloud各参数含义"></a>Wordcloud各参数含义</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">font_path : <span class="built_in">string</span>  <span class="meta">#字体路径，需要展现什么字体就把该字体路径+后缀名写上，如：font_path = <span class="string">'黑体.ttf'</span></span></span><br><span class="line"></span><br><span class="line">width : <span class="built_in">int</span> (<span class="keyword">default</span>=<span class="number">400</span>) <span class="meta">#输出的画布宽度，默认为400像素</span></span><br><span class="line"></span><br><span class="line">height : <span class="built_in">int</span> (<span class="keyword">default</span>=<span class="number">200</span>) <span class="meta">#输出的画布高度，默认为200像素</span></span><br><span class="line"></span><br><span class="line">prefer_horizontal : float (<span class="keyword">default</span>=<span class="number">0.90</span>) <span class="meta">#词语水平方向排版出现的频率，默认 0.9 （所以词语垂直方向排版出现频率为 0.1 ）</span></span><br><span class="line"></span><br><span class="line">mask : nd-array <span class="literal">or</span> None (<span class="keyword">default</span>=None) <span class="meta">#如果参数为空，则使用二维遮罩绘制词云。如果 mask 非空，设置的宽高值将被忽略，遮罩形状被 mask 取代。除全白（#FFFFFF）的部分将不会绘制，其余部分会用于绘制词云。如：bg_pic = imread(<span class="string">'读取一张图片.png'</span>)，背景图片的画布一定要设置为白色（#FFFFFF），然后显示的形状为不是白色的其他颜色。可以用ps工具将自己要显示的形状复制到一个纯白色的画布上再保存，就ok了。</span></span><br><span class="line"></span><br><span class="line">scale : float (<span class="keyword">default</span>=<span class="number">1</span>) <span class="meta">#按照比例进行放大画布，如设置为1.5，则长和宽都是原来画布的1.5倍</span></span><br><span class="line"></span><br><span class="line">min_font_size : <span class="built_in">int</span> (<span class="keyword">default</span>=<span class="number">4</span>) <span class="meta">#显示的最小的字体大小</span></span><br><span class="line"></span><br><span class="line">font_step : <span class="built_in">int</span> (<span class="keyword">default</span>=<span class="number">1</span>) <span class="meta">#字体步长，如果步长大于1，会加快运算但是可能导致结果出现较大的误差</span></span><br><span class="line"></span><br><span class="line">max_words : <span class="built_in">number</span> (<span class="keyword">default</span>=<span class="number">200</span>) <span class="meta">#要显示的词的最大个数</span></span><br><span class="line"></span><br><span class="line">stopwords : set of strings <span class="literal">or</span> None <span class="meta">#设置需要屏蔽的词，如果为空，则使用内置的STOPWORDS</span></span><br><span class="line"></span><br><span class="line">background_color : color value (<span class="keyword">default</span>=”black”) <span class="meta">#背景颜色，如background_color=<span class="string">'white'</span>,背景颜色为白色</span></span><br><span class="line"></span><br><span class="line">max_font_size : <span class="built_in">int</span> <span class="literal">or</span> None (<span class="keyword">default</span>=None) <span class="meta">#显示的最大的字体大小</span></span><br><span class="line"></span><br><span class="line">mode : <span class="built_in">string</span> (<span class="keyword">default</span>=”RGB”) <span class="meta">#当参数为“RGBA”并且background_color不为空时，背景为透明</span></span><br><span class="line"></span><br><span class="line">relative_scaling : float (<span class="keyword">default</span>=<span class="number">.5</span>) <span class="meta">#词频和字体大小的关联性</span></span><br><span class="line"></span><br><span class="line">color_func : callable, <span class="keyword">default</span>=None <span class="meta">#生成新颜色的函数，如果为空，则使用 self.color_func</span></span><br><span class="line"></span><br><span class="line">regexp : <span class="built_in">string</span> <span class="literal">or</span> None (optional) <span class="meta">#使用正则表达式分隔输入的文本</span></span><br><span class="line"></span><br><span class="line">collocations : bool, <span class="keyword">default</span>=<span class="literal">True</span> <span class="meta">#是否包括两个词的搭配</span></span><br><span class="line"></span><br><span class="line">colormap : <span class="built_in">string</span> <span class="literal">or</span> matplotlib colormap, <span class="keyword">default</span>=”viridis” <span class="meta">#给每个单词随机分配颜色，若指定color_func，则忽略该方法</span></span><br><span class="line"></span><br><span class="line">random_state : <span class="built_in">int</span> <span class="literal">or</span> None  <span class="meta">#为每个单词返回一个PIL颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fit_words(frequencies)  <span class="meta">#根据词频生成词云</span></span><br><span class="line">generate(text)  <span class="meta">#根据文本生成词云</span></span><br><span class="line">generate_from_frequencies(frequencies[, ...])   <span class="meta">#根据词频生成词云</span></span><br><span class="line">generate_from_text(text)    <span class="meta">#根据文本生成词云</span></span><br><span class="line">process_text(text)  <span class="meta">#将长文本分词并去除屏蔽词（此处指英语，中文分词还是需要自己用别的库先行实现，使用上面的 fit_words(frequencies) ）</span></span><br><span class="line">recolor([random_state, color_func, colormap])   <span class="meta">#对现有输出重新着色。重新上色会比重新生成整个词云快很多</span></span><br><span class="line">to_array()  <span class="meta">#转化为 numpy array</span></span><br><span class="line">to_file(filename)   <span class="meta">#输出到文件</span></span><br></pre></td></tr></table></figure><p>背景图<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/155061877268618276.jpg" alt=""></p><p>效果图<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/render_09.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信最强花式操作，带你玩转 wxpy</title>
      <link href="/2018/09/04/%E5%BE%AE%E4%BF%A1%E6%9C%80%E5%BC%BA%E8%8A%B1%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-wxpy/"/>
      <url>/2018/09/04/%E5%BE%AE%E4%BF%A1%E6%9C%80%E5%BC%BA%E8%8A%B1%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-wxpy/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><h2 id="一、wxpy基本介绍与安装"><a href="#一、wxpy基本介绍与安装" class="headerlink" title="一、wxpy基本介绍与安装"></a>一、wxpy基本介绍与安装</h2><h3 id="1-wxpy基本介绍"><a href="#1-wxpy基本介绍" class="headerlink" title="1.wxpy基本介绍"></a>1.wxpy基本介绍</h3><div class="note info"><p>wxpy基于itchat，使用了 Web 微信的通讯协议，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展。实现了微信登录、收发消息、搜索好友、数据统计、微信公众号、微信好友、微信群基本信息获取等功能。<br>可用来实现各种微信个人号的自动化操作。<br></p></div><h3 id="2-wxpy安装"><a href="#2-wxpy安装" class="headerlink" title="2.wxpy安装"></a>2.wxpy安装</h3><p>方法一：直接安装<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> wxpy</span><br></pre></td></tr></table></figure></p><p>方法二：豆瓣源安装（推荐）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -<span class="selector-tag">i</span> https:<span class="comment">//pypi.douban.com/simple/  wxpy</span></span><br></pre></td></tr></table></figure></p><h2 id="二、实践出真知"><a href="#二、实践出真知" class="headerlink" title="二、实践出真知"></a>二、实践出真知</h2><h3 id="1-给自己的文件传输助手发消息"><a href="#1-给自己的文件传输助手发消息" class="headerlink" title="1.给自己的文件传输助手发消息"></a>1.给自己的文件传输助手发消息</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/9/4 10:46</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : demo1.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给自己的文件传输助手发消息</span></span><br><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 初始化一个机器人对象</span></span><br><span class="line">bot = Bot(cache_path=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向文件传输助手发送消息</span></span><br><span class="line">bot.file_helper.send(<span class="string">"hello,I'm Felix!"</span>)</span><br></pre></td></tr></table></figure><p><code>Bot</code>类基本参数介绍：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cache_path –  </span><br><span class="line">    设置当前会话的缓存路径，并开启缓存功能；为 <span class="literal">None</span> (默认) 则不开启缓存功能。  </span><br><span class="line">    开启缓存后可在短时间内避免重复扫码，缓存失效时会重新要求登陆。  </span><br><span class="line">    设为 <span class="literal">True</span> 时，使用默认的缓存路径 ‘wxpy.pkl’。  </span><br><span class="line">qr_path – 保存二维码的路径  </span><br><span class="line">console_qr – 在终端中显示登陆二维码</span><br></pre></td></tr></table></figure></p><p>运行后弹出一个二维码图片，用微信扫码登录即可，再回来看手机消息。  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/IMG_9380_看图王.png" alt=""></p><div class="note warning"><p>特别提醒：_使用的微信账号不能为新注册的账号，不然会报错<code>KeyError: &#39;pass_ticket&#39;</code>。<br></p></div><h3 id="2-给指定朋友发送消息"><a href="#2-给指定朋友发送消息" class="headerlink" title="2.给指定朋友发送消息"></a>2.给指定朋友发送消息</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/9/4 10:54</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : demo2.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 初始化一个机器人对象</span></span><br><span class="line"><span class="comment"># cache_path缓存路径，给定值为第一次登录生成的缓存文件路径</span></span><br><span class="line">bot = Bot(cache_path=<span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>)</span><br><span class="line"><span class="comment"># 查找朋友"极简XksA"</span></span><br><span class="line">my_friend = bot.friends().search(<span class="string">'张大饼'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">my_friend.send(<span class="string">'Felix TURING RoBot test'</span>) </span><br><span class="line"><span class="string">'''  </span></span><br><span class="line"><span class="string">除此之外还有可以发送一下内容，自己动手尝试吧  </span></span><br><span class="line"><span class="string">发送图片  </span></span><br><span class="line"><span class="string">my\_friend.send\_image('hello.png')  </span></span><br><span class="line"><span class="string">发送视频  </span></span><br><span class="line"><span class="string">my\_friend.send\_video('hello.mp4')  </span></span><br><span class="line"><span class="string">发送文件  </span></span><br><span class="line"><span class="string">my\_friend.send\_file('hello.rar')  </span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>运行结果：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/IMG_9381_看图王.png" alt=""></p><h3 id="3-群发消息"><a href="#3-群发消息" class="headerlink" title="3.群发消息"></a>3.群发消息</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 初始化一个机器人对象</span></span><br><span class="line"><span class="comment"># cache_path为登录状态缓存路径，给定值为第一次登录生成的缓存文件路径</span></span><br><span class="line">bot = Bot(cache_path=<span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 群发消息（谨慎使用，哈哈哈）</span></span><br><span class="line">my_friends = bot.friends(update=<span class="keyword">False</span>)</span><br><span class="line">my_friends.pop(<span class="number">0</span>)   <span class="comment"># 去除列表第一个元素（自己）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">120</span>): <span class="comment"># 时间限制2分钟内最多发120次（具体看wxpy官方文档异常处理）</span></span><br><span class="line">    friend = my_friends[i]</span><br><span class="line">    friend.send(<span class="string">'Good morning,the early bird catches the worm!(早上好，早起的鸟儿有虫吃！)'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    friend.send(<span class="string">'不用回复，生活中一起加油！'</span>)</span><br></pre></td></tr></table></figure><h3 id="4-获取自己的微信好友数、活跃微信群数、关注微信公众号数"><a href="#4-获取自己的微信好友数、活跃微信群数、关注微信公众号数" class="headerlink" title="4.获取自己的微信好友数、活跃微信群数、关注微信公众号数"></a>4.获取自己的微信好友数、活跃微信群数、关注微信公众号数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有好友[返回列表包含Chats对象(你的所有好友，包括自己)]</span></span><br><span class="line">t0 = bot.friends(update=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 查看自己好友数(除开自己)</span></span><br><span class="line">print(<span class="string">"我的好友数："</span>+str(len(t0)<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有微信群[返回列表包含Groups对象]</span></span><br><span class="line">t1 = bot.groups(update=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 查看微信群数(活跃的)</span></span><br><span class="line">print(<span class="string">"我的微信群聊数："</span>+str(len(t1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有关注的微信公众号[返回列表包含Chats对象]</span></span><br><span class="line">t2 = bot.mps(update=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 查看关注的微信公众号数</span></span><br><span class="line">print(<span class="string">"我关注的微信公众号数："</span>+str(len(t2)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 注：如果直接把t0、t1、t2打印出就是对应得名称(不同类型，自己可以试一下)</span><br><span class="line">我的好友数：<span class="number">102</span></span><br><span class="line">我的微信群聊数：<span class="number">5</span></span><br><span class="line">我关注的微信公众号数：<span class="number">64</span></span><br></pre></td></tr></table></figure><h3 id="5-个人聊天机器人搭建（基于自己的）"><a href="#5-个人聊天机器人搭建（基于自己的）" class="headerlink" title="5.个人聊天机器人搭建（基于自己的）"></a>5.个人聊天机器人搭建（基于自己的）</h3><h4 id="（1）自己的聊天机器人"><a href="#（1）自己的聊天机器人" class="headerlink" title="（1）自己的聊天机器人"></a>（1）自己的聊天机器人</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找聊天对象</span></span><br><span class="line">my_friend = bot.friends().search(<span class="string">'张大饼'</span>)[<span class="number">0</span>]</span><br><span class="line">my_friend.send(<span class="string">'Felix TURING RoBot test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动回复</span></span><br><span class="line"><span class="comment"># 如果想对所有好友实现机器人回复把参数 my_friend 改成 chats = [Friend]</span></span><br><span class="line"><span class="meta">@bot.register(my_friend)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_friednd_message</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'[接收]'</span> + str(msg))</span><br><span class="line">    <span class="keyword">if</span> msg.type != <span class="string">'Text'</span>:   <span class="comment"># 除文字外其他消息回复内容</span></span><br><span class="line">        ret = <span class="string">'你给我看了什么！[拜托]'</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">"你来自哪里"</span> <span class="keyword">in</span> str(msg):   <span class="comment"># 特定问题回答</span></span><br><span class="line">        ret = <span class="string">"我来自China"</span></span><br><span class="line">    <span class="keyword">else</span>:         <span class="comment"># 文字消息自动回答</span></span><br><span class="line">        ret = <span class="string">'我爱你'</span></span><br><span class="line">    print(<span class="string">'[发送]'</span> + str(ret))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment"># 进入交互式的 Python 命令行界面，并堵塞当前线程</span></span><br><span class="line">embed()</span><br></pre></td></tr></table></figure><h3 id="6-个人聊天机器人搭建（基于图灵机器人的）"><a href="#6-个人聊天机器人搭建（基于图灵机器人的）" class="headerlink" title="6.个人聊天机器人搭建（基于图灵机器人的）"></a>6.个人聊天机器人搭建（基于图灵机器人的）</h3><h4 id="（1）事前准备"><a href="#（1）事前准备" class="headerlink" title="（1）事前准备"></a>（1）事前准备</h4><p>百度图灵机器人，注册图灵机器人账号,然后创建一个机器人，即可获得属于你的图灵机器人api。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180904170507.png" alt=""></p><h4 id="（2）-创建属于自己的聊天机器人"><a href="#（2）-创建属于自己的聊天机器人" class="headerlink" title="（2） 创建属于自己的聊天机器人"></a>（2） 创建属于自己的聊天机器人</h4><ul><li>方法一：使用<code>Tuling</code>类，简单实现</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/9/4 11:09</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : demo6.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录缓存路径,第一次设置为True</span></span><br><span class="line"><span class="comment"># 生成缓存文件wxpy.pkl后，为该文件路径</span></span><br><span class="line">bot = Bot(cache_path=<span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>)</span><br><span class="line">tuling = Tuling(api_key=<span class="string">'b28b82730280474394c52d217d8de222'</span>)</span><br><span class="line">print(<span class="string">'Felix机器人已经启动'</span>)</span><br><span class="line"><span class="comment"># 我的小号，测试需谨慎</span></span><br><span class="line">my_friend = bot.friends().search(<span class="string">'张大饼'</span>)[<span class="number">0</span>]</span><br><span class="line">my_friend.send(<span class="string">'Felix图灵机器人已启动，可以开始和劳资bb啦~~'</span>)</span><br><span class="line"><span class="comment"># 如果想对所有好友实现机器人回复把参数my_friend改成chats = [Friend]</span></span><br><span class="line"><span class="comment"># 使用图灵机器人自动与指定好友聊天</span></span><br><span class="line"><span class="meta">@bot.register(my_friend)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reply_my_friend</span><span class="params">(msg)</span>:</span></span><br><span class="line">    tuling.do_reply(msg)</span><br><span class="line"><span class="comment"># 进入交互式的 Python 命令行界面，并堵塞当前线程</span></span><br><span class="line">embed()</span><br></pre></td></tr></table></figure><ul><li>方法二：自己手动发送<code>post</code>请求，有点麻烦哈哈哈~</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auto_ai</span><span class="params">(text)</span>:</span></span><br><span class="line">    url = <span class="string">"http://www.tuling123.com/openapi/api"</span></span><br><span class="line">    api_key = <span class="string">"你的图灵接口api"</span></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">"key"</span>: api_key,</span><br><span class="line">        <span class="string">"info"</span>: text,</span><br><span class="line">        <span class="string">"userid"</span>: <span class="string">"userid"</span></span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.post(url, data=json.dumps(payload))</span><br><span class="line">    result = json.loads(r.content)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"[Felix图灵机器人]  "</span> + result[<span class="string">"text"</span>]</span><br><span class="line"></span><br><span class="line">bot = Bot(cache_path=<span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>)  </span><br><span class="line">print(<span class="string">'Felix图灵机器人已经启动'</span>)</span><br><span class="line"><span class="comment"># 我的小号，测试需谨慎</span></span><br><span class="line">my_friednd = bot.friends().search(<span class="string">'张大饼'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 如果想对所有好友实现机器人回复把参数my_friend改成chats = [Friend]</span></span><br><span class="line"><span class="meta">@bot.register(my_friednd)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_friednd_message</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'[接收]'</span> + str(msg))</span><br><span class="line">    <span class="keyword">if</span> msg.type != <span class="string">'Text'</span>:</span><br><span class="line">        ret = <span class="string">'你给我看了什么！[拜托]'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret = auto_ai(msg.text)</span><br><span class="line">    print(<span class="string">'[发送]'</span> + str(ret))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment"># 进入交互式的 Python 命令行界面，并堵塞当前线程</span></span><br><span class="line">embed()</span><br></pre></td></tr></table></figure><h4 id="（3）聊天效果图"><a href="#（3）聊天效果图" class="headerlink" title="（3）聊天效果图"></a>（3）聊天效果图</h4><p>基本测试，图灵机器人可以实现查询天气、车票、翻译、基本聊天等功能，比我们自己写的，，，哈哈哈。  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/IMG_9382_看图王.png" alt=""></p><h3 id="7-来点有趣的"><a href="#7-来点有趣的" class="headerlink" title="7.来点有趣的"></a>7.来点有趣的</h3><h4 id="获取微信好友性别、位置分布数据"><a href="#获取微信好友性别、位置分布数据" class="headerlink" title="获取微信好友性别、位置分布数据"></a>获取微信好友性别、位置分布数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个机器人对象</span></span><br><span class="line"><span class="comment"># cache_path缓存路径，给定值为第一次登录生成的缓存文件路径</span></span><br><span class="line">bot = Bot(cache_path=<span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>)</span><br><span class="line"><span class="comment">#获取好友列表(包括自己)</span></span><br><span class="line">my_friends = bot.friends(update=<span class="keyword">False</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">stats_text 函数：帮助我们简单统计微信好友基本信息</span></span><br><span class="line"><span class="string">简单的统计结果的文本</span></span><br><span class="line"><span class="string">    :param total: 总体数量</span></span><br><span class="line"><span class="string">    :param sex: 性别分布</span></span><br><span class="line"><span class="string">    :param top_provinces: 省份分布</span></span><br><span class="line"><span class="string">    :param top_cities: 城市分布</span></span><br><span class="line"><span class="string">    :return: 统计结果文本</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(my_friends.stats_text())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">雨碎 共有<span class="number"> 103 </span>位微信好友</span><br><span class="line"></span><br><span class="line">男性:<span class="number"> 68 </span>(66.0%)</span><br><span class="line">女性:<span class="number"> 27 </span>(26.2%)</span><br><span class="line"></span><br><span class="line">TOP<span class="number"> 10 </span>省份</span><br><span class="line">江苏:<span class="number"> 61 </span>(59.22%)</span><br><span class="line">上海:<span class="number"> 5 </span>(4.85%)</span><br><span class="line">安徽:<span class="number"> 2 </span>(1.94%)</span><br><span class="line">广东:<span class="number"> 2 </span>(1.94%)</span><br><span class="line">北京:<span class="number"> 2 </span>(1.94%)</span><br><span class="line">Carinthia:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">内蒙古:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">Barcelona:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">江西:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">Auckland:<span class="number"> 1 </span>(0.97%)</span><br><span class="line"></span><br><span class="line">TOP<span class="number"> 10 </span>城市</span><br><span class="line">常州:<span class="number"> 34 </span>(33.01%)</span><br><span class="line">南京:<span class="number"> 23 </span>(22.33%)</span><br><span class="line">广州:<span class="number"> 2 </span>(1.94%)</span><br><span class="line">浦东新区:<span class="number"> 2 </span>(1.94%)</span><br><span class="line">苏州:<span class="number"> 2 </span>(1.94%)</span><br><span class="line">阜阳:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">房山:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">九江:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">徐州:<span class="number"> 1 </span>(0.97%)</span><br><span class="line">无锡:<span class="number"> 1 </span>(0.97%)</span><br></pre></td></tr></table></figure><h4 id="获取好友微信昵称和个性签名，词云分析"><a href="#获取好友微信昵称和个性签名，词云分析" class="headerlink" title="获取好友微信昵称和个性签名，词云分析"></a>获取好友微信昵称和个性签名，词云分析</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bot = Bot(cache_path=<span class="string">"D:\PycharmProjects\pythonProcedure\com\zyf\weixin\wxpy.pkl"</span>)</span><br><span class="line"><span class="comment">#获取好友列表(包括自己)</span></span><br><span class="line">my_friends = bot.friends(update=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 微信昵称</span></span><br><span class="line">nick_name = <span class="string">''</span></span><br><span class="line"><span class="comment"># 微信个性签名</span></span><br><span class="line">wx_signature = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> friend <span class="keyword">in</span> my_friends:</span><br><span class="line">    <span class="comment"># 微信昵称：NickName</span></span><br><span class="line">    nick_name = nick_name + friend.raw[<span class="string">'NickName'</span>]</span><br><span class="line">    <span class="comment"># 个性签名：Signature</span></span><br><span class="line">    wx_signature = wx_signature + friend.raw[<span class="string">'Signature'</span>]</span><br><span class="line"></span><br><span class="line">nick_name = jiebaclearText(nick_name)</span><br><span class="line">wx_signature = jiebaclearText(wx_signature)</span><br><span class="line">make_wordcloud(nick_name,<span class="number">1</span>)</span><br><span class="line">make_wordcloud(wx_signature,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>效果图：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/render_01.png" alt=""></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/render_02.png" alt=""></p><h5 id="5）获取关注微信公众号名称和基本简介，词云分析"><a href="#5）获取关注微信公众号名称和基本简介，词云分析" class="headerlink" title="5）获取关注微信公众号名称和基本简介，词云分析"></a>5）获取关注微信公众号名称和基本简介，词云分析</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取微信公众号名称</span></span><br><span class="line">wx_public_name = <span class="string">''</span></span><br><span class="line"><span class="comment"># 公众号简介</span></span><br><span class="line">wx_pn_signature = <span class="string">''</span></span><br><span class="line"><span class="comment"># 获取微信公众号列表</span></span><br><span class="line">my_wx_pn = bot.mps(update=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">for</span> wx_pn <span class="keyword">in</span> my_wx_pn:</span><br><span class="line">    wx_public_name = wx_public_name + wx_pn.raw[<span class="string">'NickName'</span>]</span><br><span class="line">    wx_pn_signature = wx_pn_signature + wx_pn.raw[<span class="string">'Signature'</span>]</span><br><span class="line"></span><br><span class="line">wx_public_name = jiebaclearText(wx_public_name)</span><br><span class="line">make_wordcloud(wx_public_name,<span class="number">3</span>)</span><br><span class="line">wx_pn_signature = jiebaclearText(wx_pn_signature)</span><br><span class="line">make_wordcloud(wx_pn_signature,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>效果图：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/render_03.png" alt=""></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/render_04.png" alt=""></p><p>本文参考文档：</p><p>1.wxpy官方介绍文档: <a href="https://wxpy.readthedocs.io/zh/latest/messages.html" target="_blank" rel="noopener">https://wxpy.readthedocs.io/zh/latest/messages.html</a></p><p>2.matplotlib官方介绍文档: <a href="https://matplotlib.org/" target="_blank" rel="noopener">https://matplotlib.org/</a></p><p>源代码：<a href="https://gitee.com/ShaErHu/wxpy_matplotlib_learning" target="_blank" rel="noopener">https://gitee.com/ShaErHu/wxpy_matplotlib_learning</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Python自动生成报表以邮件发送</title>
      <link href="/2018/09/03/%E4%BD%BF%E7%94%A8Python%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8A%A5%E8%A1%A8%E4%BB%A5%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
      <url>/2018/09/03/%E4%BD%BF%E7%94%A8Python%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8A%A5%E8%A1%A8%E4%BB%A5%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>数据分析师肯定每天都被各种各样的数据数据报表搞得焦头烂额，老板的，运营的、产品的等等。而且大部分报表都是重复性的工作，这篇文章就是帮助大家如何用Python来实现报表的自动发送，解放你的劳动力，可以让你有时间去做更有意思的事情。</p><p>首先来介绍下实现自动报表要使用到的Python库：</p><ul><li><p>pymysql 一个可以连接MySQL实例并且实现增删改查功能的库</p></li><li><p>datetime Python标准库中自带的关于时间的库</p></li><li><p>openpyxl 一个可以读写07版以后的Excel文档（.xlsx格式也支持）的库</p></li><li><p>smtplib SMTP即简单邮件传输协议，Python简单封装成了一个库</p></li><li><p>email 一个用来处理邮件消息的库</p></li></ul><p>为什么使用openpyxl库来处理Excel呢？因为它支持每个sheet的行数为100W+，也是支持xlsx格式的文件。如果你接受xls文件，并且每个sheet的行数小于6W，也是可以使用xlwt库，它对大文件的读取速度要大于openpyxl。</p><p>接下来我们就进入实战部分，来正式实现这个过程。我把整个实现过程分成几个函数的方式来实现，这样看着会比较有结构感。</p><h2 id="一、首先导入所有要用到的库"><a href="#一、首先导入所有要用到的库" class="headerlink" title="一、首先导入所有要用到的库"></a>一、首先导入所有要用到的库</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pymysql <span class="keyword">as</span> pms</span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br></pre></td></tr></table></figure><h2 id="二、-编写一个传入sql就返回数据的函数get-datas-sql"><a href="#二、-编写一个传入sql就返回数据的函数get-datas-sql" class="headerlink" title="二、 编写一个传入sql就返回数据的函数get_datas(sql)"></a>二、 编写一个传入sql就返回数据的函数get_datas(sql)</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_datas</span><span class="params">(sql)</span>:</span></span><br><span class="line">    <span class="comment"># 一个传入sql导出数据的函数</span></span><br><span class="line">    <span class="comment"># 跟数据库建立连接</span></span><br><span class="line">    conn = pms.connect(host=<span class="string">'实例地址'</span>, user=<span class="string">'用户'</span>,</span><br><span class="line">                       passwd=<span class="string">'密码'</span>, database=<span class="string">'库名'</span>, port=<span class="number">3306</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    <span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="comment"># 使用 execute() 方法执行 SQL</span></span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    <span class="comment"># 获取所需要的数据</span></span><br><span class="line">    datas = cur.fetchall()</span><br><span class="line">    <span class="comment">#关闭连接</span></span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="comment">#返回所需的数据</span></span><br><span class="line">    <span class="keyword">return</span> datas</span><br></pre></td></tr></table></figure><h2 id="三、-编写一个传入sql就返回数据的字段名称的函数get-datas-sql-，因为一个函数只能返回一个值，这边就用2个函数来分别返回数据和字段名称（也就是excel里的表头）"><a href="#三、-编写一个传入sql就返回数据的字段名称的函数get-datas-sql-，因为一个函数只能返回一个值，这边就用2个函数来分别返回数据和字段名称（也就是excel里的表头）" class="headerlink" title="三、 编写一个传入sql就返回数据的字段名称的函数get_datas(sql)，因为一个函数只能返回一个值，这边就用2个函数来分别返回数据和字段名称（也就是excel里的表头）"></a>三、 编写一个传入sql就返回数据的字段名称的函数get_datas(sql)，因为一个函数只能返回一个值，这边就用2个函数来分别返回数据和字段名称（也就是excel里的表头）</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fields</span><span class="params">(sql)</span>:</span></span><br><span class="line">    <span class="comment"># 一个传入sql导出字段的函数</span></span><br><span class="line">    conn = pms.connect(host=<span class="string">'rm-rj91p2yhl9dm2xmbixo.mysql.rds.aliyuncs.com'</span>, user=<span class="string">'bi-analyzer'</span>,</span><br><span class="line">                       passwd=<span class="string">'pcNzcKPnn'</span>, database=<span class="string">'kikuu'</span>, port=<span class="number">3306</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    <span class="comment"># 获取所需要的字段名称</span></span><br><span class="line">    fields = cur.description</span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="keyword">return</span> fields</span><br></pre></td></tr></table></figure><h2 id="四、-编写一个传入数据、字段名称、存储地址返回一个excel-的函数et-excel-data-field-file"><a href="#四、-编写一个传入数据、字段名称、存储地址返回一个excel-的函数et-excel-data-field-file" class="headerlink" title="四、 编写一个传入数据、字段名称、存储地址返回一个excel 的函数et_excel(data, field, file)"></a>四、 编写一个传入数据、字段名称、存储地址返回一个excel 的函数et_excel(data, field, file)</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_excel</span><span class="params">(data, field, file)</span>:</span></span><br><span class="line">    <span class="comment"># 将数据和字段名写入excel的函数</span></span><br><span class="line">    <span class="comment">#新建一个工作薄对象</span></span><br><span class="line">    new = openpyxl.Workbook()</span><br><span class="line">    <span class="comment">#激活一个新的sheet</span></span><br><span class="line">    sheet = new.active</span><br><span class="line">    <span class="comment">#给sheet命名</span></span><br><span class="line">    sheet.title = <span class="string">'数据展示'</span></span><br><span class="line">    <span class="comment">#将字段名称循环写入excel第一行，因为字段格式列表里包含列表，每个列表的第一元素才是字段名称</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> range(len(field)):</span><br><span class="line">        <span class="comment">#row代表行数，column代表列数，value代表单元格输入的值，行数和列数都是从1开始，这点于python不同要注意</span></span><br><span class="line">        _ = sheet.cell(row=<span class="number">1</span>, column=col+<span class="number">1</span>, value=<span class="string">u'%s'</span> % field[col][<span class="number">0</span>])</span><br><span class="line">     <span class="comment">#将数据循环写入excel的每个单元格中   </span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(len(field)):</span><br><span class="line">            <span class="comment">#因为第一行写了字段名称，所以要从第二行开始写入</span></span><br><span class="line">            _ = sheet.cell(row=row+<span class="number">2</span>, column=col + <span class="number">1</span>, value=<span class="string">u'%s'</span> % data[row][col])</span><br><span class="line">            <span class="comment">#将生成的excel保存，这步是必不可少的</span></span><br><span class="line">    newworkbook = new.save(file)</span><br><span class="line">    <span class="comment">#返回生成的excel</span></span><br><span class="line">    <span class="keyword">return</span> newworkbook</span><br></pre></td></tr></table></figure><h2 id="五、-编写一个自动获取昨天日期字符串格式的函数getYesterday"><a href="#五、-编写一个自动获取昨天日期字符串格式的函数getYesterday" class="headerlink" title="五、 编写一个自动获取昨天日期字符串格式的函数getYesterday()"></a>五、 编写一个自动获取昨天日期字符串格式的函数getYesterday()</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getYesterday</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取昨天日期的字符串格式的函数</span></span><br><span class="line">    <span class="comment">#获取今天的日期</span></span><br><span class="line">    today = datetime.date.today()</span><br><span class="line">    <span class="comment">#获取一天的日期格式数据</span></span><br><span class="line">    oneday = datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#昨天等于今天减去一天</span></span><br><span class="line">    yesterday = today - oneday</span><br><span class="line">    <span class="comment">#获取昨天日期的格式化字符串</span></span><br><span class="line">    yesterdaystr = yesterday.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">    <span class="comment">#返回昨天的字符串</span></span><br><span class="line">    <span class="keyword">return</span> yesterdaystr</span><br></pre></td></tr></table></figure><h2 id="六、编写一个生成邮件的函数create-email-email-from-email-to-email-Subject-email-text-annex-path-annex-name"><a href="#六、编写一个生成邮件的函数create-email-email-from-email-to-email-Subject-email-text-annex-path-annex-name" class="headerlink" title="六、编写一个生成邮件的函数create_email(email_from, email_to, email_Subject, email_text, annex_path, annex_name)"></a>六、编写一个生成邮件的函数create_email(email_from, email_to, email_Subject, email_text, annex_path, annex_name)</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_email</span><span class="params">(email_from, email_to, email_Subject, email_text, annex_path, annex_name)</span>:</span></span><br><span class="line">    <span class="comment"># 输入发件人昵称、收件人昵称、主题，正文，附件地址,附件名称生成一封邮件</span></span><br><span class="line">    <span class="comment">#生成一个空的带附件的邮件实例</span></span><br><span class="line">    message = MIMEMultipart()</span><br><span class="line">    <span class="comment">#将正文以text的形式插入邮件中</span></span><br><span class="line">    message.attach(MIMEText(email_text, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment">#生成发件人名称（这个跟发送的邮件没有关系）</span></span><br><span class="line">    message[<span class="string">'From'</span>] = Header(email_from, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#生成收件人名称（这个跟接收的邮件也没有关系）</span></span><br><span class="line">    message[<span class="string">'To'</span>] = Header(email_to, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#生成邮件主题</span></span><br><span class="line">    message[<span class="string">'Subject'</span>] = Header(email_Subject, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#读取附件的内容</span></span><br><span class="line">    att1 = MIMEText(open(annex_path, <span class="string">'rb'</span>).read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    att1[<span class="string">"Content-Type"</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line">    <span class="comment">#生成附件的名称</span></span><br><span class="line">    att1[<span class="string">"Content-Disposition"</span>] = <span class="string">'attachment; filename='</span> + annex_name</span><br><span class="line">    <span class="comment">#将附件内容插入邮件中</span></span><br><span class="line">    message.attach(att1)</span><br><span class="line">    <span class="comment">#返回邮件</span></span><br><span class="line">    <span class="keyword">return</span> message</span><br></pre></td></tr></table></figure><h2 id="七、-生成一个发送邮件的函数send-email-sender-password-receiver-msg"><a href="#七、-生成一个发送邮件的函数send-email-sender-password-receiver-msg" class="headerlink" title="七、 生成一个发送邮件的函数send_email(sender, password, receiver, msg)"></a>七、 生成一个发送邮件的函数send_email(sender, password, receiver, msg)</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(sender, password, receiver, msg)</span>:</span></span><br><span class="line">    <span class="comment"># 一个输入邮箱、密码、收件人、邮件内容发送邮件的函数</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#找到你的发送邮箱的服务器地址，已加密的形式发送</span></span><br><span class="line">        server = smtplib.SMTP_SSL(<span class="string">"smtp.mxhichina.com"</span>, <span class="number">465</span>)  <span class="comment"># 发件人邮箱中的SMTP服务器</span></span><br><span class="line">        server.ehlo()</span><br><span class="line">        <span class="comment">#登录你的账号</span></span><br><span class="line">        server.login(sender, password)  <span class="comment"># 括号中对应的是发件人邮箱账号、邮箱密码</span></span><br><span class="line">        <span class="comment">#发送邮件</span></span><br><span class="line">        server.sendmail(sender, receiver, msg.as_string())  <span class="comment"># 括号中对应的是发件人邮箱账号、收件人邮箱账号（是一个列表）、邮件内容</span></span><br><span class="line">        print(<span class="string">"邮件发送成功"</span>)</span><br><span class="line">        server.quit()  <span class="comment"># 关闭连接</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(traceback.print_exc())</span><br><span class="line">        print(<span class="string">"邮件发送失败"</span>)</span><br></pre></td></tr></table></figure><h2 id="八、建立一个main函数，把所有的自定义内容输入进去，最后执行main函数"><a href="#八、建立一个main函数，把所有的自定义内容输入进去，最后执行main函数" class="headerlink" title="八、建立一个main函数，把所有的自定义内容输入进去，最后执行main函数"></a>八、建立一个main函数，把所有的自定义内容输入进去，最后执行main函数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(datetime.datetime.now())</span><br><span class="line">    my_sql = sql = <span class="string">"SELECT a.id '用户ID',\</span></span><br><span class="line"><span class="string">           a.gmtCreate '用户注册时间',\</span></span><br><span class="line"><span class="string">           af.lastLoginTime '最后登录时间',\</span></span><br><span class="line"><span class="string">           af.totalBuyCount '历史付款子单数',\</span></span><br><span class="line"><span class="string">           af.paidmountUSD '历史付款金额',\</span></span><br><span class="line"><span class="string">           af.lastPayTime '用户最后支付时间'\</span></span><br><span class="line"><span class="string">          FROM table a\</span></span><br><span class="line"><span class="string">      LEFT JOIN tableb af ON a.id= af.accountId ;"</span></span><br><span class="line">    <span class="comment"># 生成数据</span></span><br><span class="line">    my_data = get_datas(my_sql)</span><br><span class="line">    <span class="comment"># 生成字段名称</span></span><br><span class="line">    my_field = get_fields(my_sql)</span><br><span class="line">    <span class="comment"># 得到昨天的日期</span></span><br><span class="line">    yesterdaystr = getYesterday()</span><br><span class="line">    <span class="comment"># 文件名称</span></span><br><span class="line">    my_file_name = <span class="string">'user attribute'</span> + yesterdaystr + <span class="string">'.xlsx'</span></span><br><span class="line">    <span class="comment"># 文件路径</span></span><br><span class="line">    file_path = <span class="string">'D:/work/report/'</span> + my_file_name</span><br><span class="line">    <span class="comment"># 生成excel</span></span><br><span class="line">    get_excel(my_data, my_field, file_path)</span><br><span class="line"></span><br><span class="line">    my_email_from = <span class="string">'BI部门自动报表机器人'</span></span><br><span class="line">    my_email_to = <span class="string">'运营部'</span></span><br><span class="line">    <span class="comment"># 邮件标题</span></span><br><span class="line">    my_email_Subject = <span class="string">'user'</span> + yesterdaystr</span><br><span class="line">    <span class="comment"># 邮件正文</span></span><br><span class="line">    my_email_text = <span class="string">"Dear all,\n\t附件为每周数据，请查收！\n\nBI团队 "</span></span><br><span class="line">    <span class="comment">#附件地址</span></span><br><span class="line">    my_annex_path = file_path</span><br><span class="line">    <span class="comment">#附件名称</span></span><br><span class="line">    my_annex_name = my_file_name</span><br><span class="line">    <span class="comment"># 生成邮件</span></span><br><span class="line">    my_msg = create_email(my_email_from, my_email_to, my_email_Subject,</span><br><span class="line">                          my_email_text, my_annex_path, my_annex_name)</span><br><span class="line">    my_sender = <span class="string">'阿里云邮箱'</span></span><br><span class="line">    my_password = <span class="string">'我的密码'</span></span><br><span class="line">    my_receiver = [<span class="number">10001</span>@qq.com<span class="string">']#接收人邮箱列表</span></span><br><span class="line"><span class="string">    # 发送邮件</span></span><br><span class="line"><span class="string">    send_email(my_sender, my_password, my_receiver, my_msg)</span></span><br><span class="line"><span class="string">    print(datetime.datetime.now())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == "__main__":</span></span><br><span class="line"><span class="string">    main();</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python的22个编程技巧，Pick一下？</title>
      <link href="/2018/09/03/Python%E7%9A%8422%E4%B8%AA%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%8CPick%E4%B8%80%E4%B8%8B%EF%BC%9F/"/>
      <url>/2018/09/03/Python%E7%9A%8422%E4%B8%AA%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%8CPick%E4%B8%80%E4%B8%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><div class="note info"><p>源 / <code>代码湾</code>   编辑 / <code>AI时间</code></p></div><h2 id="1-原地交换两个数字"><a href="#1-原地交换两个数字" class="headerlink" title="1. 原地交换两个数字"></a>1. 原地交换两个数字</h2><p>Python 提供了一个直观的在一行代码中赋值与交换（变量值）的方法，请参见下面的示例：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y= <span class="number">10</span>,<span class="number">20</span>print(x,y)x,y= y,xprint(x,y)#<span class="number">1</span> (<span class="number">10</span>, <span class="number">20</span>)#<span class="number">2</span> (<span class="number">20</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>赋值的右侧形成了一个新的元组，左侧立即解析（unpack）那个（未被引用的）元组到变量 和 。  </p><p>一旦赋值完成，新的元组变成了未被引用状态并且被标记为可被垃圾回收，最终也完成了变量的交换。</p><h2 id="2-链状比较操作符"><a href="#2-链状比较操作符" class="headerlink" title="2. 链状比较操作符"></a>2. 链状比较操作符</h2><p>比较操作符的聚合是另一个有时很方便的技巧：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n= <span class="number">10</span>result= <span class="number">1</span>&lt; n&lt; <span class="number">20</span>print(result)# Trueresult= <span class="number">1</span>&gt; n&lt;= <span class="number">9</span>print(result)# False</span><br></pre></td></tr></table></figure><h2 id="3-使用三元操作符来进行条件赋值"><a href="#3-使用三元操作符来进行条件赋值" class="headerlink" title="3. 使用三元操作符来进行条件赋值"></a>3. 使用三元操作符来进行条件赋值</h2><p>三元操作符是 if-else 语句也就是条件操作符的一个快捷方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[表达式为真的返回值] <span class="keyword">if</span> [表达式] <span class="keyword">else</span> [表达式为假的返回值]</span><br><span class="line"></span><br><span class="line">这里给出几个你可以用来使代码紧凑简洁的例子。下面的语句是说“如果 y 是 9，给 x 赋值 10，不然赋值为 20”。如果需要的话我们也可以延长这条操作链。</span><br><span class="line"></span><br><span class="line">x = 10 <span class="keyword">if</span> (y == 9) <span class="keyword">else</span> 20</span><br><span class="line"></span><br><span class="line">同样地，我们可以对类做这种操作：</span><br><span class="line"></span><br><span class="line">x = (classA <span class="keyword">if</span> y == 1 <span class="keyword">else</span> classB)(param1, param2)</span><br><span class="line"></span><br><span class="line">在上面的例子里 classA 与 classB 是两个类，其中一个类的构造函数会被调用。</span><br><span class="line"></span><br><span class="line">下面是另一个多个条件表达式链接起来用以计算最小值的例子：</span><br><span class="line"></span><br><span class="line">def small(a,b,c):returnaifa&lt;= banda&lt;= celse(bifb&lt;= aandb&lt;= celsec)<span class="builtin-name">print</span>(small(1,0,1))<span class="builtin-name">print</span>(small(1,2,2))<span class="builtin-name">print</span>(small(2,2,3))<span class="builtin-name">print</span>(small(5,4,3))#Output#0 #1 #2 #3</span><br><span class="line"></span><br><span class="line">我们甚至可以在列表推导中使用三元运算符：</span><br><span class="line"></span><br><span class="line">[m*<span class="number">*2</span> <span class="keyword">if</span> m &gt; 10 <span class="keyword">else</span> m*<span class="number">*4</span> <span class="keyword">for</span> m <span class="keyword">in</span> range(50)]#=&gt; [0, 1, 16, 81, 256, 625, 1296, 2401, 4096, 6561, 10000, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401]</span><br></pre></td></tr></table></figure><h2 id="4-多行字符串"><a href="#4-多行字符串" class="headerlink" title="4. 多行字符串"></a>4. 多行字符串</h2><p>基本的方式是使用源于 C 语言的反斜杠：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">multiStr= </span>“<span class="keyword">select </span>* from <span class="keyword">multi_rowwhere </span>row_id &lt; <span class="number">5</span>”print(<span class="keyword">multiStr)# </span><span class="keyword">select </span>* from <span class="keyword">multi_row </span>where row_id &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure><p>另一个技巧是使用三引号：  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">multiStr= </span>“””<span class="keyword">select </span>* from <span class="keyword">multi_rowwhere </span>row_id &lt; <span class="number">5</span>″””print(<span class="keyword">multiStr)#select </span>* from <span class="keyword">multi_row#where </span>row_id &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面方法共有的问题是缺少合适的缩进，如果我们尝试缩进会在字符串中插入空格。所以最后的解决方案是将字符串分为多行并且将整个字符串包含在括号中：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiStr= (“<span class="keyword">select</span> * <span class="keyword">from</span> multi_row ”“<span class="keyword">where</span> row_id &lt; <span class="number">5</span> ”“<span class="keyword">order</span> <span class="keyword">by</span> age”)print(multiStr)#<span class="keyword">select</span> * <span class="keyword">from</span> multi_row <span class="keyword">where</span> row_id &lt; <span class="number">5</span> <span class="keyword">order</span> <span class="keyword">by</span> age</span><br></pre></td></tr></table></figure><h2 id="5-存储列表元素到新的变量中"><a href="#5-存储列表元素到新的变量中" class="headerlink" title="5. 存储列表元素到新的变量中"></a>5. 存储列表元素到新的变量中</h2><p>我们可以使用列表来初始化多个变量，在解析列表时，变量的数目不应该超过列表中的元素个数：【译者注：元素个数与列表长度应该严格相同，不然会报错】</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testList= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]x,y,z= testListprint(x,y,z)#-&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="6-打印引入模块的文件路径"><a href="#6-打印引入模块的文件路径" class="headerlink" title="6. 打印引入模块的文件路径"></a>6. 打印引入模块的文件路径</h2><p>如果你想知道引用到代码中模块的绝对路径，可以使用下面的技巧：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threadingimport socketprint(threading)print(socket)#1- #2-</span><br></pre></td></tr></table></figure></p><h2 id="7-交互环境下的-“-”-操作符"><a href="#7-交互环境下的-“-”-操作符" class="headerlink" title="7. 交互环境下的 “_” 操作符"></a>7. 交互环境下的 “_” 操作符</h2><p>这是一个我们大多数人不知道的有用特性，在 Python 控制台，不论何时我们测试一个表达式或者调用一个方法，结果都会分配给一个临时变量： _（一个下划线）。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="number">2</span>+ <span class="number">13</span>&gt;&gt;&gt; _3&gt;&gt;&gt; print_3</span><br></pre></td></tr></table></figure><p>“_” 是上一个执行的表达式的输出。</p><h2 id="8-字典-集合推导"><a href="#8-字典-集合推导" class="headerlink" title="8. 字典/集合推导"></a>8. 字典/集合推导</h2><p>与我们使用的列表推导相似，我们也可以使用字典/集合推导，它们使用起来简单且有效，下面是一个例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testDict= &#123;i: i *iforiinxrange(10)&#125;testSet= &#123;i <span class="number">*2f</span>oriinxrange(10)&#125;<span class="builtin-name">print</span>(testSet)<span class="builtin-name">print</span>(testDict)#<span class="builtin-name">set</span>([0, 2, 4, 6, 8, 10, 12, 14, 16, 18])#&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81&#125;</span><br></pre></td></tr></table></figure><p>注：两个语句中只有一个 &lt;:> 的不同，另，在 Python3 中运行上述代码时，将 改为 。</p><h2 id="9-调试脚本"><a href="#9-调试脚本" class="headerlink" title="9. 调试脚本"></a>9. 调试脚本</h2><p>我们可以在 模块的帮助下在 Python 脚本中设置断点，下面是一个例子：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdbpdb.set_trace()</span><br></pre></td></tr></table></figure></p><p>我们可以在脚本中任何位置指定 并且在那里设置一个断点，相当简便。</p><h2 id="10-开启文件分享"><a href="#10-开启文件分享" class="headerlink" title="10. 开启文件分享"></a>10. 开启文件分享</h2><p>Python 允许运行一个 HTTP 服务器来从根路径共享文件，下面是开启服务器的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Python 2</span></span><br><span class="line">python -m SimpleHTTPServer</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Python 3</span></span><br><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure></p><p>上面的命令会在默认端口也就是 8000 开启一个服务器，你可以将一个自定义的端口号以最后一个参数的方式传递到上面的命令中。</p><h2 id="11-检查-Python-中的对象"><a href="#11-检查-Python-中的对象" class="headerlink" title="11. 检查 Python 中的对象"></a>11. 检查 Python 中的对象</h2><p>我们可以通过调用 dir() 方法来检查 Python 中的对象，下面是一个简单的例子：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test= [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">print(dir(test))[‘<span class="variable">__add__</span>’, ‘<span class="variable">__class__</span>’, ‘<span class="variable">__contains__</span>’, ‘<span class="variable">__delattr__</span>’, ‘<span class="variable">__delitem__</span>’, ‘<span class="variable">__delslice__</span>’, ‘<span class="variable">__doc__</span>’, ‘<span class="variable">__eq__</span>’, ‘<span class="variable">__format__</span>’, ‘<span class="variable">__ge__</span>’, ‘<span class="variable">__getattribute__</span>’, ‘<span class="variable">__getitem__</span>’, ‘<span class="variable">__getslice__</span>’, ‘<span class="variable">__gt__</span>’, ‘<span class="variable">__hash__</span>’, ‘<span class="variable">__iadd__</span>’, ‘<span class="variable">__imul__</span>’, ‘<span class="variable">__init__</span>’, ‘<span class="variable">__iter__</span>’, ‘<span class="variable">__le__</span>’, ‘<span class="variable">__len__</span>’, ‘<span class="variable">__lt__</span>’, ‘<span class="variable">__mul__</span>’, ‘<span class="variable">__ne__</span>’, ‘<span class="variable">__new__</span>’, ‘<span class="variable">__reduce__</span>’, ‘<span class="variable">__reduce_ex__</span>’, ‘<span class="variable">__repr__</span>’, ‘<span class="variable">__reversed__</span>’, ‘<span class="variable">__rmul__</span>’, ‘<span class="variable">__setattr__</span>’, ‘<span class="variable">__setitem__</span>’, ‘<span class="variable">__setslice__</span>’, ‘<span class="variable">__sizeof__</span>’, ‘<span class="variable">__str__</span>’, ‘<span class="variable">__subclasshook__</span>’, ‘<span class="built_in">append</span>’, ‘<span class="built_in">count</span>’, ‘extend’, ‘index’, ‘insert’, ‘pop’, ‘remove’, ‘<span class="built_in">reverse</span>’, ‘<span class="built_in">sort</span>’]</span><br></pre></td></tr></table></figure></p><h2 id="12-简化-if-语句"><a href="#12-简化-if-语句" class="headerlink" title="12. 简化 if 语句"></a>12. 简化 if 语句</h2><p>我们可以使用下面的方式来验证多个值：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]:</span><br></pre></td></tr></table></figure></p><p>而不是：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="attribute">m</span>==1 <span class="keyword">or</span> <span class="attribute">m</span>==3 <span class="keyword">or</span> <span class="attribute">m</span>==5 <span class="keyword">or</span> <span class="attribute">m</span>==7:</span><br></pre></td></tr></table></figure></p><p>或者，对于 in 操作符我们也可以使用 ‘{1,3,5,7}’ 而不是 ‘[1,3,5,7]’，因为 set 中取元素是 O(1) 操作。</p><h2 id="13-一行代码计算任何数的阶乘"><a href="#13-一行代码计算任何数的阶乘" class="headerlink" title="13. 一行代码计算任何数的阶乘"></a>13. 一行代码计算任何数的阶乘</h2><p>Python 2.x.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result= (<span class="name">lambdak</span>: reduce(<span class="name">int</span>.__mul__,range(<span class="number">1</span>,k+1),<span class="number">1</span>))(<span class="number">3</span>)print(<span class="name">result</span>)#-&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>Python 3.x.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">result= (<span class="name">lambdak</span>: functools.reduce(<span class="name">int</span>.__mul__,range(<span class="number">1</span>,k+1),<span class="number">1</span>))(<span class="number">3</span>)</span><br><span class="line">print(<span class="name">result</span>)#-&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="14-找到列表中出现最频繁的数"><a href="#14-找到列表中出现最频繁的数" class="headerlink" title="14. 找到列表中出现最频繁的数"></a>14. 找到列表中出现最频繁的数</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">print(max(set(test),<span class="type">key</span>=test.count))#-&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="15-重置递归限制"><a href="#15-重置递归限制" class="headerlink" title="15. 重置递归限制"></a>15. 重置递归限制</h2><p>Python 限制递归次数到 1000，我们可以重置这个值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="attribute">x</span>=1001</span><br><span class="line"><span class="builtin-name">print</span>(sys.getrecursionlimit())#1-&gt; 1000</span><br><span class="line">sys.setrecursionlimit(x)</span><br><span class="line"><span class="builtin-name">print</span>(sys.getrecursionlimit())#2-&gt; 1001</span><br></pre></td></tr></table></figure><p>请只在必要的时候采用上面的技巧。</p><h2 id="16-检查一个对象的内存使用"><a href="#16-检查一个对象的内存使用" class="headerlink" title="16. 检查一个对象的内存使用"></a>16. 检查一个对象的内存使用</h2><p>在 Python 2.7 中，一个 32 比特的整数占用 24 字节，在 Python 3.5 中利用 28 字节。为确定内存使用，我们可以调用 getsizeof 方法：</p><p>在 Python 2.7 中<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">x=1</span><br><span class="line">print(<span class="name">sys</span>.getsizeof(<span class="name">x</span>))#-&gt; <span class="number">24</span></span><br></pre></td></tr></table></figure></p><p>在 Python 3.5 中  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">x=1</span><br><span class="line">print(<span class="name">sys</span>.getsizeof(<span class="name">x</span>))#-&gt; <span class="number">28</span></span><br></pre></td></tr></table></figure><h2 id="17-使用-slots-来减少内存开支"><a href="#17-使用-slots-来减少内存开支" class="headerlink" title="17. 使用 slots 来减少内存开支"></a>17. 使用 <strong>slots</strong> 来减少内存开支</h2><p>你是否注意到你的 Python 应用占用许多资源特别是内存？有一个技巧是使用 <strong>slots</strong> 类变量来在一定程度上减少内存开支。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#In Python 3.5</span></span><br><span class="line">import sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>(<span class="title">object</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,files,folders,devices)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.files= files</span><br><span class="line">    <span class="keyword">self</span>.folders= folders</span><br><span class="line">    <span class="keyword">self</span>.devices= devices</span><br><span class="line">    print(sys.getsizeof(FileSystem))<span class="comment">#1-&gt; 1016</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem1</span>(<span class="title">object</span>):</span></span><br><span class="line">  __slots_<span class="number">_</span>= [‘files’,’folders’,’devices’]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,files,folders,devices)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.files= files</span><br><span class="line">    <span class="keyword">self</span>.folders= folders</span><br><span class="line">    <span class="keyword">self</span>.devices= devices</span><br><span class="line">    print(sys.getsizeof(FileSystem1))<span class="comment">#2-&gt; 888</span></span><br></pre></td></tr></table></figure><p>很明显，你可以从结果中看到确实有内存使用上的节省，但是你只应该在一个类的内存开销不必要得大时才使用 <strong>slots</strong>。只在对应用进行性能分析后才使用它，不然地话，你只是使得代码难以改变而没有真正的益处。  </p><p>【译者注：在我的 win10 python2.7 中上面的结果是：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#In Python <span class="number">2.7</span> win10#<span class="number">1</span>-&gt; <span class="number">896</span>#<span class="number">2</span>-&gt; <span class="number">1016</span></span><br></pre></td></tr></table></figure><p>所以，这种比较方式是不那么让人信服的，使用 <strong>slots</strong> 主要是用以限定对象的属性信息，另外，当生成对象很多时花销可能会小一些，具体可以参见 python 官方文档:  </p><div class="note info"><p>The slots declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable. Space is saved because dict is not created for each instance.</p></div><h2 id="18-使用-lambda-来模仿输出方法"><a href="#18-使用-lambda-来模仿输出方法" class="headerlink" title="18. 使用 lambda 来模仿输出方法"></a>18. 使用 lambda 来模仿输出方法</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import syslprint=lambda *arg<span class="variable">s:sys</span>.stdout.<span class="keyword">write</span>(” “.<span class="keyword">join</span>(<span class="keyword">map</span>(str,<span class="keyword">args</span>)))lprint(“<span class="keyword">python</span>”,”tips”,<span class="number">1000</span>,<span class="number">1001</span>)#-&gt; <span class="keyword">python</span> tips <span class="number">1000</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure><h2 id="19-从两个相关的序列构建一个字典"><a href="#19-从两个相关的序列构建一个字典" class="headerlink" title="19.从两个相关的序列构建一个字典"></a>19.从两个相关的序列构建一个字典</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1= (1,2,3)</span><br><span class="line">t2= (10,20,30)</span><br><span class="line">print(dict(zip(t1,t2)))<span class="comment">#-&gt; &#123;1: 10, 2: 20, 3: 30&#125;</span></span><br></pre></td></tr></table></figure><h2 id="20-一行代码搜索字符串的多个前后缀"><a href="#20-一行代码搜索字符串的多个前后缀" class="headerlink" title="20. 一行代码搜索字符串的多个前后缀"></a>20. 一行代码搜索字符串的多个前后缀</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(“http<span class="symbol">://www</span>.google.com”.startswith((“http<span class="symbol">://</span>”,”https<span class="symbol">://</span>”)))print(“http<span class="symbol">://www</span>.google.co.uk”.endswith((“.com”,”.co.uk”)))#1-&gt; True#2-&gt; True</span><br></pre></td></tr></table></figure><h2 id="21-不使用循环构造一个列表"><a href="#21-不使用循环构造一个列表" class="headerlink" title="21. 不使用循环构造一个列表"></a>21. 不使用循环构造一个列表</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import itertoolstest= [[<span class="number">-1</span>,<span class="number">-2</span>],[<span class="number">30</span>,<span class="number">40</span>],[<span class="number">25</span>,<span class="number">35</span>]]print(<span class="type">list</span>(itertools.chain.from_iterable(test)))#-&gt; [<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">35</span>]</span><br></pre></td></tr></table></figure><h2 id="22-在-Python-中实现一个真正的-switch-case-语句"><a href="#22-在-Python-中实现一个真正的-switch-case-语句" class="headerlink" title="22. 在 Python 中实现一个真正的 switch-case 语句"></a>22. 在 Python 中实现一个真正的 switch-case 语句</h2><p>下面的代码使用一个字典来模拟构造一个 switch-case。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xswitch</span><span class="params">(x)</span>:</span>returnxswitch._system_dict.get(x,<span class="keyword">None</span>)xswitch._system_dict= &#123;‘files’: <span class="number">10</span>,’folders’: <span class="number">5</span>,’devices’: <span class="number">2</span>&#125;print(xswitch(‘default’))print(xswitch(‘devices’))<span class="comment">#1-&gt; None#2-&gt; 2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（SEO优化）</title>
      <link href="/2018/08/29/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88SEO%E4%BC%98%E5%8C%96%EF%BC%89/"/>
      <url>/2018/08/29/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88SEO%E4%BC%98%E5%8C%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;推广是一个烦人的事情啊喂，特别是对于我们搞技术的来说，可能就不擅长推广，那么怎么才能让别人知道我们呢，我们就要想办法让别人通过搜索就可以搜索到你博客的内容，给我们带来自然流量，这就需要seo优化,让我们的站点变得对搜索引擎友好。</p><a id="more"></a><p><br></p><div class="note default"><p>SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。</p></div><h2 id="让百度收录你的站点"><a href="#让百度收录你的站点" class="headerlink" title="让百度收录你的站点"></a>让百度收录你的站点</h2><p>我们首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入<code>site:&lt;域名&gt;</code>,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180829151511.png" alt="查看站点是否被百度收录"></p><h3 id="验证网站所有权"><a href="#验证网站所有权" class="headerlink" title="验证网站所有权"></a>验证网站所有权</h3><p>登录百度站长平台：<a href="http://zhanzhang.baidu.com" target="_blank" rel="noopener">http://zhanzhang.baidu.com</a>,只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击<a href="http://zhanzhang.baidu.com/site/siteadd" target="_blank" rel="noopener">添加网站</a>然后输入你的站点地址，建议输入的网站为www开头的，不要输入github.io的，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180829151735.png" alt="百度站长添加网站"><br>在选择完网站的类型之后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证。html标签验证和cname解析验证，使用哪一种方式都可以，都是比较简单的，<strong>但是一定要注意，使用文件验证文件存放的位置需要放在source文件夹下，如果是html文件那么hexo就会将其编译，所以必须要加上的<code>layout:false</code>，这样就不会被hexo编译。（如果验证文件是txt格式的就不需要）</strong>，其他两种方式也是很简单的，我个人推荐文件验证和cname验证，cname验证最为简单，只需加一条解析就好~<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180829151710.png" alt="验证网站所有权"></p><h3 id="生成网站地图"><a href="#生成网站地图" class="headerlink" title="生成网站地图"></a>生成网站地图</h3><p>我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎</p><h4 id="安装sitemap插件"><a href="#安装sitemap插件" class="headerlink" title="安装sitemap插件"></a>安装sitemap插件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save     </span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-baidu-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h4 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h4><p>在根目录配置文件中修改url为你的站点地址<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site <span class="keyword">is</span> <span class="keyword">put</span> in <span class="keyword">a</span> subdirectory, <span class="keyword">set</span> url <span class="keyword">as</span> <span class="string">'http://yoursite.com/child'</span> <span class="built_in">and</span> root <span class="keyword">as</span> <span class="string">'/child/'</span></span><br><span class="line">ur<span class="variable">l:</span> http<span class="variable">s:</span>//yfzhou.coding.<span class="keyword">me</span></span><br><span class="line">roo<span class="variable">t:</span> /</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_default<span class="variable">s:</span></span><br></pre></td></tr></table></figure></p><p><strong>执行完之后就会在网站根目录生成sitemap.xml文件和baidusitemap.xml文件</strong>，可以通过<a href="https://yfzhou.coding.me/baidusitemap.xml">https://yfzhou.coding.me/baidusitemap.xml</a>,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。</p><h3 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h3><p>然后我们就可以将我们生成的sitemap文件提交给百度，还是在百度站长平台，找到链接提交，这里我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap</p><div class="note info"><p>如何选择链接提交方式<br>1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。<br>2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。<br>3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。<br>4、手动提交：一次性提交链接给百度，可以使用此种方式。</p></div><p>一般主动提交比手动提交效果好，这里介绍主动提交的三种方法<br>从效率上来说：</p><div class="note default"><p><strong>主动推送&gt;自动推送&gt;sitemap</strong></p></div><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180829152039.png" alt="连接提交"></p><h4 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h4><p>安装插件<code>npm install hexo-baidu-url-submit --save</code><br>然后再根目录的配置文件中新增字段<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line"><span class="attr">  count:</span> <span class="number">100</span> <span class="comment"># 提交最新的一个链接</span></span><br><span class="line"><span class="attr">  host:</span> <span class="attr">https://yfzhou.coding.me</span> <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line"><span class="attr">  token:</span> <span class="number">8</span><span class="string">OGYpxowYnhgVsUM</span> <span class="comment"># 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure></p><p>在加入新的deploye<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">deploy</span>:</span><br><span class="line">- <span class="keyword">type</span>:baidu_url_submitter</span><br></pre></td></tr></table></figure></p><p>这样执行<code>hexo deploy</code>的时候，新的链接就会被推送了</p><h4 id="设置自动推送"><a href="#设置自动推送" class="headerlink" title="设置自动推送"></a>设置自动推送</h4><p>在主题配置文件下设置,将baidu_push设置为true：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>然后就会将一下代码自动推送到百度，位置是themes\next\layout_scripts\baidu_push.swig,这样每次访问博客中的页面就会自动向百度提交sitemap<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.baidu_push %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">(function()&#123;</span></span><br><span class="line"><span class="xml">    var bp = document.createElement('script');</span></span><br><span class="line"><span class="xml">    var curProtocol = window.location.protocol.split(':')[0];</span></span><br><span class="line"><span class="xml">    if (curProtocol === 'https') &#123;</span></span><br><span class="line"><span class="xml">        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        </span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    else &#123;</span></span><br><span class="line"><span class="xml">        bp.src = 'http://push.zhanzhang.baidu.com/push.js';</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    var s = document.getElementsByTagName("script")[0];</span></span><br><span class="line"><span class="xml">    s.parentNode.insertBefore(bp, s);</span></span><br><span class="line"><span class="xml">&#125;)();</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><h4 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h4><p>将我们上一步生成的sitemap文件提交到百度就可以了~<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180829152228.png" alt="将sitemap提交到百度"><br>我记得被百度收录过程还是蛮久的，一度让我以为我的方法有问题，提交链接在站长工具中有显示大概是有两天的时候，站点被百度收录大概花了半个月= =，让大家看一下现在的成果<br>在百度搜索<code>site:cherryblog.site</code>已经可以搜索到结果<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180829152319.png" alt="站点已被百度收录"><br>在搜索框输入域名也可以找到站点<br>输入关键字第一条就是<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180829152439.png" alt="站点已被百度收录"></p><h2 id="其他seo优化"><a href="#其他seo优化" class="headerlink" title="其他seo优化"></a>其他seo优化</h2><hr><p>seo优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，seo优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上keyword和描述<br>在代码中，我们应该写出能让浏览器识别的语义化HTML，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置nofollow标签，避免spider爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为spider会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样spider是很有可能爬到我们中的站点的，so….  </p><div class="note primary no-icon">网站<strong>外链</strong>的推广度、数量和质量<br>网站的<strong>内链</strong>足够强大<br>网站的<strong>原创</strong>质量<br>网站的<strong>年龄</strong>时间<br>网站的<strong>更新频率</strong>（更新次数越多越好）<br>网站的<strong>服务器</strong><br>网站的<strong>流量</strong>：流量越高网站的权重越高<br>网站的<strong>关键词排名</strong>：关键词排名越靠前，网站的权重越高<br>网站的<strong>收录</strong>数量：网站百度收录数量越多，网站百度权重越高<br>网站的浏览量及深度：<strong>用户体验</strong>越好，网站的百度权重越高</div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（代码块复制功能）</title>
      <link href="/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
      <url>/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>为了提高博客代码块的用户体验，仅仅代码高亮还不行，最好还能一键复制代码。故此文将讲述Hexo NexT主题博客的代码块复制功能配置。</p><a id="more"></a><h2 id="下载-clipboard-js"><a href="#下载-clipboard-js" class="headerlink" title="下载 clipboard.js"></a>下载 clipboard.js</h2><p>三方插件 clipboardjs ，相关介绍和兼容性我就不赘述了，去它<a href="https://clipboardjs.com/" target="_blank" rel="noopener">主页</a>或<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">github</a>上看。</p><p><strong>下载地址：</strong></p><ul><li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.js" target="_blank" rel="noopener">clipboard.js</a></li><li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js" target="_blank" rel="noopener">clipboard.min.js</a> <strong>推荐</strong></li></ul><p>保存文件<code>clipboard.js / clipboard.min.js</code> ，目录如下：<br><code>.\themes\next\source\js\src</code></p><h2 id="clipboardjs-使用"><a href="#clipboardjs-使用" class="headerlink" title="clipboardjs 使用"></a>clipboardjs 使用</h2><p>也是在<code>.\themes\next\source\js\src</code>目录下，创建<code>clipboard-use.js</code>，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*页面载入完成后，创建复制按钮*/</span></span><br><span class="line">  !<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> copyHtml = <span class="string">''</span>;</span><br><span class="line">      copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">      <span class="comment">//fa fa-globe可以去字体库替换自己想要的图标</span></span><br><span class="line">copyHtml += <span class="string">'  &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'</span>;</span><br><span class="line">      copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">      $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">      <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">          target: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    initCopyCode();</span><br><span class="line">  &#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>在<code>.\themes\next\source\css\_custom\custom.styl</code>样式文件中添加下面代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码块复制按钮</span></span><br><span class="line">.highlight&#123;</span><br><span class="line">  <span class="comment">//方便copy代码按钮（btn-copy）的定位</span></span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    background-color: #eee;</span><br><span class="line">    background-image: linear-gradient(#fcfcfc,#eee);</span><br><span class="line">    border: 1px solid #d5d5d5;</span><br><span class="line">    border-radius: <span class="number">3</span>px;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">    -webkit-appearance: none;</span><br><span class="line">    font-size: <span class="number">13</span>px;</span><br><span class="line">    font-weight: <span class="number">700</span>;</span><br><span class="line">    line-height: <span class="number">20</span>px;</span><br><span class="line">    color: #333;</span><br><span class="line">    -webkit-transition: opacity <span class="number">.3</span>s ease-<span class="keyword">in</span>-out;</span><br><span class="line">    -o-transition: opacity <span class="number">.3</span>s ease-<span class="keyword">in</span>-out;</span><br><span class="line">    transition: opacity <span class="number">.3</span>s ease-<span class="keyword">in</span>-out;</span><br><span class="line">    padding: <span class="number">2</span>px <span class="number">6</span>px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: <span class="number">5</span>px;</span><br><span class="line">    top: <span class="number">5</span>px;</span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy span &#123;</span><br><span class="line">    margin-left: <span class="number">5</span>px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight:hover .btn-copy&#123;</span><br><span class="line">  opacity: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在<code>.\themes\next\layout\_layout.swig</code>文件中，添加引用（注：在 swig 末尾或 body 结束标签（<code>&lt;/body&gt;</code>）之前添加）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>  </span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard-use.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>效果的可以去<a href="http://yfzhou.coding.me">我博客</a>看</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>懂代码的也可以将<code>clipboard.min.js</code>和<code>clipboard-use.js</code>合并为一个文件，再在<code>.\themes\next\layout\_layout.swig</code>文件中使用。当然<code>clipboard.min.js</code>也可以直接用三方cdn的方式引入也行。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（主题优化）</title>
      <link href="/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/"/>
      <url>/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span></span><br><a id="more"></a></p><ul><li>Hexo版本是3.7.1</li><li>NexT.Pisces v5.1.4</li></ul><h4 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h4><ul><li>Hexo的命令极简单，安装后只需要记住四个常用的即可。执行命令需要Git当前处于blog文件夹根目录下。</li><li>generate 生成静态文件。<br><code>hexo g</code></li><li>server 启动服务器。<br><code>hexo s</code></li><li>deploy 部署网站。部署网站前，需要预先生成静态文件。<br><code>hexo d</code></li><li>clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br><code>hexo clean</code></li><li>卸载Hexo<br><code>npm uninstall hexo-cli -g</code></li></ul><h4 id="2-更换主题-以Next主题为例"><a href="#2-更换主题-以Next主题为例" class="headerlink" title="2.更换主题,以Next主题为例"></a>2.更换主题,以Next主题为例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> your-hexo-site</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>Hexo 站点</code>目录下的<code>_config.yml</code>的主题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><h4 id="3-站点初始设置"><a href="#3-站点初始设置" class="headerlink" title="3.站点初始设置"></a>3.站点初始设置</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Site</span></span><br><span class="line"><span class="symbol">title:</span> Hexo <span class="meta">#网站标题</span></span><br><span class="line"><span class="symbol">subtitle:</span> <span class="meta">#网站副标题</span></span><br><span class="line"><span class="symbol">description:</span> <span class="meta">#网站描述</span></span><br><span class="line"><span class="symbol">author:</span> author <span class="meta">#您的名字</span></span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-Hans <span class="meta">#网站使用的语言</span></span><br><span class="line"><span class="symbol">timezone:</span> Asia/Shanghai <span class="meta">#网站时区。Hexo 默认使用您电脑的时区。</span></span><br></pre></td></tr></table></figure><ul><li>打开<code>Hexo 站点</code>目录下的<code>_config.yml</code>修改内容如下</li></ul><h4 id="4-设置主题风格"><a href="#4-设置主题风格" class="headerlink" title="4.设置主题风格"></a>4.设置主题风格</h4><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>scheme</code>关键字，将你需用启用的<code>scheme</code> 前面注释 # 去除即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Scheme Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Schemes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Muse <span class="comment"># 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Mist <span class="comment"># Muse 的紧凑版本，整洁有序的单栏外观</span></span></span><br><span class="line">scheme: Pisces # 双栏 Scheme，小家碧玉似的清新</span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Gemini <span class="comment"># 类似 Pisces</span></span></span><br></pre></td></tr></table></figure><h4 id="5-设置菜单项的显示文本和图标"><a href="#5-设置菜单项的显示文本和图标" class="headerlink" title="5.设置菜单项的显示文本和图标"></a>5.设置菜单项的显示文本和图标</h4><ul><li>更新说明：NexT.Pisces v5.1.3, 版本更换了修改菜单图标方式。<a href="https://link.jianshu.com?t=https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">参看详细信息</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1157148-aff23889b39e52b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/244/format/webp" alt=""></p><ul><li>NexT 使用的是 <a href="https://link.jianshu.com?t=http://fontawesome.io/icons/" target="_blank" rel="noopener">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</li></ul><h6 id="5-1设置菜单项的显示文本："><a href="#5-1设置菜单项的显示文本：" class="headerlink" title="5.1设置菜单项的显示文本："></a><strong>5.1设置菜单项的显示文本</strong>：</h6><ul><li>打开<code>themes/next/languages</code>下的<code>zh-Hans.yml</code>文件,搜索 <code>menu</code>关键字，修改对应中文或者新增</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> 首页</span><br><span class="line"><span class="symbol">  archives:</span> 归档</span><br><span class="line"><span class="symbol">  categories:</span> 分类</span><br><span class="line"><span class="symbol">  tags:</span> 标签</span><br><span class="line"><span class="symbol">  about:</span> 关于</span><br><span class="line"><span class="symbol">  search:</span> 搜索</span><br><span class="line"><span class="symbol">  schedule:</span> 日程表</span><br><span class="line"><span class="symbol">  sitemap:</span> 站点地图</span><br><span class="line"><span class="symbol">  commonweal:</span> 公益<span class="number">404</span></span><br><span class="line">  <span class="meta"># 新增menu</span></span><br><span class="line"><span class="symbol">  catalogue:</span> 目录</span><br></pre></td></tr></table></figure><h6 id="5-2设定菜单项的图标"><a href="#5-2设定菜单项的图标" class="headerlink" title="5.2设定菜单项的图标"></a><strong>5.2设定菜单项的图标</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>menu_icons</code>关键字，修改对应<code>图标名称</code>或者新增对应<code>menu</code>的图标</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="comment"># Icon Mapping:</span></span><br><span class="line"><span class="comment">#   Map a menu item to a specific FontAwesome icon name.</span></span><br><span class="line"><span class="comment">#   Key is the name of menu item and value is the name of FontAwesome icon. Key is case-senstive.</span></span><br><span class="line"><span class="comment">#   When an question mask icon presenting up means that the item has no mapping icon.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">calendar</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  sitemap:</span> <span class="string">sitemap</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">heartbeat</span></span><br><span class="line">  <span class="comment">#新增menu_icon</span></span><br><span class="line"><span class="attr">  catalogue:</span> <span class="string">th-list</span></span><br></pre></td></tr></table></figure><h6 id="5-3设置菜单项对应的文件目录"><a href="#5-3设置菜单项对应的文件目录" class="headerlink" title="5.3设置菜单项对应的文件目录"></a><strong>5.3设置菜单项对应的文件目录</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>menu</code>关键字，以<code>#</code>注释原有的菜单项，或者新增新的菜单项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Menu Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When running the site <span class="keyword">in</span> a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span></span><br><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories/</span><br><span class="line"><span class="meta">  #</span><span class="bash">about: /about/</span></span><br><span class="line">  archives: /archives/</span><br><span class="line"><span class="meta">  #</span><span class="bash">tags: /tags/</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">新增menu</span></span><br><span class="line">  catalogue: /catalogues/</span><br></pre></td></tr></table></figure><ul><li>除了<code>home</code>，<code>archives</code>,<code>/</code>后面都需要手动创建这个页面</li></ul><h6 id="5-4创建菜单项对应文件目录-以分类为例"><a href="#5-4创建菜单项对应文件目录-以分类为例" class="headerlink" title="5.4创建菜单项对应文件目录,以分类为例"></a><strong>5.4创建菜单项对应文件目录,以<code>分类</code>为例</strong></h6><ul><li>在终端窗口下，定位到 <code>Hexo 站点</code>目录下。使用 <code>hexo new page</code> 新建一个页面，命名为 categories ：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ hexo new<span class="built_in"> page </span>categories</span><br></pre></td></tr></table></figure><h6 id="5-5编辑刚新建的页面-设置分类"><a href="#5-5编辑刚新建的页面-设置分类" class="headerlink" title="5.5编辑刚新建的页面,设置分类"></a><strong>5.5编辑刚新建的页面,设置分类</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="bullet">-12</span><span class="bullet">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Testing</span> <span class="comment">#分类名</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h4 id="6-头像设置"><a href="#6-头像设置" class="headerlink" title="6.头像设置"></a>6.头像设置</h4><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180827165555.png" alt=""></p><h6 id="6-1添加头像"><a href="#6-1添加头像" class="headerlink" title="6.1添加头像"></a><strong>6.1添加头像</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>Sidebar Avatar</code>关键字，去掉<code>avatar</code>前面的<code>#</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Sidebar Avatar</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> theme directory(<span class="built_in">source</span>/images): /images/avatar.jpg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> site  directory(<span class="built_in">source</span>/uploads): /uploads/avatar.jpg</span></span><br><span class="line">avatar: http://example.com/avatar.png</span><br></pre></td></tr></table></figure><ul><li>或者使用本地图片,把图片放入<code>themes/next/source/images</code>下,修改<code>avatar</code></li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">avatar:</span> <span class="meta-keyword">/images/</span>blogLogo.png</span><br></pre></td></tr></table></figure><h6 id="6-2设置头像边框为圆形框"><a href="#6-2设置头像边框为圆形框" class="headerlink" title="6.2设置头像边框为圆形框"></a><strong>6.2设置头像边框为圆形框</strong></h6><ul><li>打开位于<code>themes/next/source/css/_common/components/sidebar/</code>下的<code>sidebar-author.syl</code>文件,修改如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"> <span class="comment">// 修改头像边框</span></span><br><span class="line">  border-radius: <span class="number">50</span>%;</span><br><span class="line">  -webkit-border-radius: <span class="number">50</span>%;</span><br><span class="line">  -moz-border-radius: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="6-3特效：鼠标放置头像上旋转"><a href="#6-3特效：鼠标放置头像上旋转" class="headerlink" title="6.3特效：鼠标放置头像上旋转"></a><strong>6.3特效：鼠标放置头像上旋转</strong></h6><p><img src="https://upload-images.jianshu.io/upload_images/1157148-675a29f5238a55cf.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/240/format/webp" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"> <span class="comment">// 修改头像边框</span></span><br><span class="line">  border-radius: <span class="number">50</span>%;</span><br><span class="line">  -webkit-border-radius: <span class="number">50</span>%;</span><br><span class="line">  -moz-border-radius: <span class="number">50</span>%;</span><br><span class="line">  <span class="comment">// 设置旋转</span></span><br><span class="line">  transition: <span class="number">1.4</span>s all;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可旋转的圆形头像,`hover`动作</span></span><br><span class="line">.site-author-image:hover &#123;</span><br><span class="line">    -webkit-transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">    -moz-transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">    -ms-transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">    -transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-浏览页面的时候显示当前浏览进度"><a href="#7-浏览页面的时候显示当前浏览进度" class="headerlink" title="7.浏览页面的时候显示当前浏览进度"></a>7.浏览页面的时候显示当前浏览进度</h4><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827170432.png" alt=""></p><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>,搜索关键字<code>scrollpercent</code>,把<code>false</code>改为<code>true</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr"> scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>如果想把<code>top</code>按钮放在<code>侧边栏</code>,打开<code>themes/next</code>下的<code>_config.yml</code>,搜索关键字<code>b2t</code>,把<code>false</code>改为<code>true</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Back to top in sidebar</span></span><br><span class="line"><span class="attr"> b2t:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr"> scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827170416.png" alt=""></p><h4 id="8-文章创建和删除"><a href="#8-文章创建和删除" class="headerlink" title="8.文章创建和删除"></a>8.文章创建和删除</h4><ul><li>创建文章</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">   $</span><span class="bash"> <span class="built_in">cd</span> you-site</span></span><br><span class="line"><span class="meta">   $</span><span class="bash"> hexo new post <span class="string">"you title"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用n代替new</span></span><br></pre></td></tr></table></figure><ul><li><p>文章目录<br><code>you-site/source/_posts</code></p></li><li><p>删除文章</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line">在/source/_posts/中直接删除了相应的.md文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br></pre></td></tr></table></figure><h4 id="9-标签设置"><a href="#9-标签设置" class="headerlink" title="9.标签设置"></a>9.标签设置</h4><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827171116.png" alt=""></p><h6 id="9-1创建标签目录"><a href="#9-1创建标签目录" class="headerlink" title="9.1创建标签目录"></a><strong>9.1创建标签目录</strong></h6><ul><li>hexo初始是没有<code>标签</code>目录的需要自己创建</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd you-site</span><br><span class="line">$ hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure><ul><li>创建完成后,打开<code>you-site/source/tags</code>的<code>index.md</code>,修改如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span>  <span class="comment">#页面主题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-08</span><span class="bullet">-18</span> <span class="number">15</span><span class="string">:00:55</span> <span class="comment">#当前创建文件时间</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span> <span class="comment"># 设置页面类型</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><ul><li>得到如下界面</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827171000.png" alt=""></p><h6 id="9-2设置标签云"><a href="#9-2设置标签云" class="headerlink" title="9.2设置标签云"></a><strong>9.2设置标签云</strong></h6><ul><li>标签云的生成:是根据你创建的文章，设定标签类型，自定生成的。某个标签下的 文章越多则，标签越高大</li><li>设置文章标签:打开<code>you-site/source/_posts</code>的<code>you title.md</code>,默认<code>tags:</code>为空,后面加上标签名即可</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">layout</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签1</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-08</span><span class="bullet">-18</span> <span class="number">15</span><span class="string">:41:18</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">标签1</span> <span class="comment">#此文章在`标签1 `标签下</span></span><br><span class="line"><span class="comment">#tags: [标签1,标签2] #此文章在`标签1,标签2`下</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h4 id="10侧边栏设置"><a href="#10侧边栏设置" class="headerlink" title="10侧边栏设置"></a>10侧边栏设置</h4><h6 id="10-1-设置侧边栏社交链接"><a href="#10-1-设置侧边栏社交链接" class="headerlink" title="10.1 设置侧边栏社交链接"></a><strong>10.1 设置侧边栏社交链接</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件,搜索关键字<code>social</code>,然后添加社交站点名称与地址即可。</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Social links</span></span><br><span class="line"><span class="symbol">social:</span></span><br><span class="line"><span class="symbol">  GitHub:</span> https:<span class="comment">//github.com/your-user-name</span></span><br><span class="line"><span class="symbol">  Twitter:</span> https:<span class="comment">//twitter.com/your-user-name</span></span><br><span class="line"><span class="symbol">  Weibo:</span> https:<span class="comment">//weibo.com/your-user-name</span></span><br><span class="line"><span class="symbol">  douban:</span> https:<span class="comment">//douban.com/people/your-user-name</span></span><br><span class="line"><span class="symbol">  zhihu:</span> https:<span class="comment">//www.zhihu.com/people/your-user-name</span></span><br><span class="line">  <span class="meta"># 等等</span></span><br></pre></td></tr></table></figure><h6 id="10-2-设置侧边栏社交图标"><a href="#10-2-设置侧边栏社交图标" class="headerlink" title="10.2 设置侧边栏社交图标"></a><strong>10.2 设置侧边栏社交图标</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件,搜索关键字<code>social_icons</code>，添加社交站点名称（注意大小写）图标，<a href="https://link.jianshu.com?t=http://fontawesome.io/icons/" target="_blank" rel="noopener">Font Awesome图标地址</a></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mappings.</span></span><br><span class="line">  <span class="comment"># KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  Twitter:</span> <span class="string">twitter</span></span><br><span class="line"><span class="attr">  Weibo:</span> <span class="string">weibo</span></span><br><span class="line"><span class="attr">  Linkedin:</span> <span class="string">linkedin</span></span><br></pre></td></tr></table></figure><h6 id="10-3RSS"><a href="#10-3RSS" class="headerlink" title="10.3RSS"></a><strong>10.3RSS</strong></h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827171615.png" alt=""></p><ul><li>在你<code>Hexo 站点</code>目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-feed --save</span></span><br></pre></td></tr></table></figure><ul><li>打开<code>Hexo 站点</code>下的_config.yml,添加如下配置</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># feed</span></span><br><span class="line"><span class="meta"># Dependencies: https:<span class="comment">//github.com/hexojs/hexo-generator-feed</span></span></span><br><span class="line"><span class="symbol">feed:</span></span><br><span class="line"><span class="symbol">  type:</span> atom</span><br><span class="line"><span class="symbol">  path:</span> atom.xml</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">20</span></span><br><span class="line"><span class="symbol">  hub:</span></span><br><span class="line"><span class="symbol">  content:</span></span><br></pre></td></tr></table></figure><h6 id="10-4友情链接"><a href="#10-4友情链接" class="headerlink" title="10.4友情链接"></a><strong>10.4友情链接</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件,搜索关键字<code>Blog rolls</code></li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Blog rolls</span></span><br><span class="line"><span class="symbol">links_title:</span> 友情链接 <span class="meta">#标题</span></span><br><span class="line"><span class="symbol">links_layout:</span> block <span class="meta">#布局，一行一个连接</span></span><br><span class="line"><span class="meta">#links_layout: inline</span></span><br><span class="line"><span class="symbol">links:</span> <span class="meta">#连接</span></span><br><span class="line"><span class="symbol">  baidu:</span> http:<span class="comment">//example.com/</span></span><br><span class="line"><span class="symbol">  google:</span> http:<span class="comment">//example.com/</span></span><br></pre></td></tr></table></figure><h4 id="11好玩的写作样式"><a href="#11好玩的写作样式" class="headerlink" title="11好玩的写作样式"></a>11好玩的写作样式</h4><p>用一些特殊的样式，可以增加文章的可读性。不过也不是越多越好，没必要写一篇文章就把下面的样式全部用一遍，这样只会适得其反，从下面的样式中选几个自己觉得比较好的、经常会用的就行。而且写博客重点是文章的文字内容，而不是这些样式，样式只是为了让文章更美观，更适合阅读。这和我们用 Markdown 写文章是一样的道理，用 Markdown 而不是直接写 HTML 代码，就是为了将更多时间花在文字上。</p><h6 id="11-01主题自带样式-文本居中引用"><a href="#11-01主题自带样式-文本居中引用" class="headerlink" title="11.01主题自带样式 文本居中引用"></a><strong>11.01主题自带样式 文本居中引用</strong></h6><p>效果：<br><blockquote class="blockquote-center"><p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p></blockquote></p><p>源码：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">cq</span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">人生乃是一面镜子，</span></span><br><span class="line"><span class="xml">从镜子里认识自己，</span></span><br><span class="line"><span class="xml">我要称之为头等大事，</span></span><br><span class="line"><span class="xml">也只是我们追求的目的！</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endcq</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>更多 NexT 主题自带的标签样式，请点击：<a href="http://theme-next.iissnan.com/tag-plugins.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/tag-plugins.html</a></p><h6 id="11-02主题自带样式-note-标签"><a href="#11-02主题自带样式-note-标签" class="headerlink" title="11.02主题自带样式 note 标签"></a><strong>11.02主题自带样式 note 标签</strong></h6><p>在主题配置文件_config.yml里有一个关于这个的配置，但官方文档没有提供 HTML 的使用方式，个人认为这种方式更简单，也不会产生一些奇怪的显示 bug……</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note default"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>default<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note default"><p>default</p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note primary"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>primary<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note primary"><p>primary</p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note success"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>success<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note success"><p>success</p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note info"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>info<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note info"><p>info</p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note warning"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>warning<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note warning"><p>warning</p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note danger"><p>danger</p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note danger no-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>danger no-icon<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note danger no-icon"><p>danger no-icon</p></div><p>首先可以在<code>主题配置文件</code>中需要配置下，贴上我的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Note tag (bs-callout).</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># 风格</span></span><br><span class="line"><span class="attr">  style:</span> <span class="string">flat</span></span><br><span class="line">  <span class="comment"># 要不要图标</span></span><br><span class="line"><span class="attr">  icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 圆角矩形</span></span><br><span class="line"><span class="attr">  border_radius:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  light_bg_offset:</span></span><br></pre></td></tr></table></figure></p><p>里面的三种风格长啥样？开启图标长啥样？可以查看<a href="https://github.com/iissnan/hexo-theme-next/pull/1697" target="_blank" rel="noopener">这个页面</a>，更多的介绍也在这个页面，请自行查看。</p><h6 id="11-03主题自带样式-label-标签"><a href="#11-03主题自带样式-label-标签" class="headerlink" title="11.03主题自带样式 label 标签"></a><strong>11.03主题自带样式 label 标签</strong></h6><p>首先可以在<code>主题配置文件</code>中有配置，需要配置下，贴上我的:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Label tag.</span></span><br><span class="line"><span class="keyword">label</span><span class="bash">: <span class="literal">true</span></span></span><br></pre></td></tr></table></figure></p><p>然后效果如下（@ 前面的是<span class="label success">label</span>的名字，后面的是要显示的文字）：</p><span class="label default">default</span><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-variable">&#123;% label <span class="keyword">default</span>@<span class="keyword">default</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><span class="label primary">primary</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">label</span> primary@primary %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><span class="label success">success</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">label</span> success@success %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><span class="label info">info</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">label</span> info@info %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><span class="label warning">warning</span><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label <span class="keyword">warning</span>@warning %&#125;</span><br></pre></td></tr></table></figure><span class="label danger">danger</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">label</span> danger@danger %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h6 id="11-03主题自带样式-tabs-标签"><a href="#11-03主题自带样式-tabs-标签" class="headerlink" title="11.03主题自带样式 tabs 标签"></a><strong>11.03主题自带样式 tabs 标签</strong></h6><p>效果：<br><div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong></p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了！φ(≧ω≦*)♪～</p></div></div></div></p><p>源码：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">tabs</span> 选项卡, 2 %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 1** 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 2**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>首先可以在<code>主题配置文件</code>中有配置，需要配置下，贴上我的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tabs tag.</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  transition:</span></span><br><span class="line"><span class="attr">    tabs:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    labels:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  border_radius:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>然后上面源码中, 2表示一开始在第二个选项卡，非必须，若数值为-1则隐藏选项卡内容。更多用法请查看<a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Tab-tag-test" target="_blank" rel="noopener">这个页面</a>。</p><h6 id="11-04主题自带样式-tabs-标签"><a href="#11-04主题自带样式-tabs-标签" class="headerlink" title="11.04主题自带样式 tabs 标签"></a><strong>11.04主题自带样式 tabs 标签</strong></h6><p>源码：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btn http<span class="variable">s:</span>//www.baidu.<span class="keyword">com</span>, 点击下载百度, download fa-<span class="keyword">lg</span> fa-fw %&#125;</span><br></pre></td></tr></table></figure></p><p>效果：<a class="btn" href="https://www.baidu.com" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-fw"></i>点击下载百度</a><br>关于按钮的更多使用可以前往<a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener">这个页面</a>查看。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 Python 生成二维码</title>
      <link href="/2018/08/27/%E4%BD%BF%E7%94%A8-Python-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
      <url>/2018/08/27/%E4%BD%BF%E7%94%A8-Python-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;新时代，人们有人信新的追求，自然而然会有新发明的诞生。去年，在“一带一路”国际合作高峰论坛举行期间，20国青年投票选出中国的“新四大发明”：高铁、扫码支付、共享单车和网购。其中扫码支付指手机通过扫描二维码跳转到支付页面，再进行付款。这种新的支付方式，造就二维码满天飞的现象。那么让我们来扒一扒如何使用 Python 来生成二维码图片。</p><a id="more"></a><h3 id="1-二维码"><a href="#1-二维码" class="headerlink" title="1 二维码"></a>1 二维码</h3><p>二维码（2-dimensional bar code），是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的。它能将数字、英文字母、汉字、日文字母、特殊符号(如空格，%，/ 等)、二进制等信息记录到一个正方形的图片中。</p><p>因此，在转换的过程中，离不开编码压缩方式。在许多种类的二维条码中，常用的码制有：Data Matrix, Maxi Code, Aztec, QR Code, Vericode, PDF417, Ultracode, Code 49, Code 16K等。</p><p>二维码在现实生活中的应用越来与普遍，归于功于 QR code 码制的流行。我们常说的二维码就是它。所以，二维码又被称为 QR code。</p><p>QR code 是一种矩阵式二维条码（又称棋盘式二维条码）。它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。在矩阵相应元素位置上，<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制的“0”，点的排列组合确定了矩阵式二维条码所代表的意义</strong>。</p><h3 id="2-二维码结构"><a href="#2-二维码结构" class="headerlink" title="2 二维码结构"></a>2 二维码结构</h3><p>我们的目的是要使用 Python 生成 QR 码，那我们需要先了解二维码(QR 码)的结构。根据标准（ISO/IEC 18004），我们可以了解到 QR 码结构如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827141504.png" alt=""></p><p>图片来源网络</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">1) 功能图形</strong><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">功能图形</strong>是不参与编码数据的区域。它包含<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">空白区</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形分隔符</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">定位图形</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">校正图形</strong>五大模块。</p><ul><li>空白区</li></ul><p>空白区顾名思义就是要留空白。因此，这里不能有任何图样或标记。这样才能保证 QR 能被识别。</p><ul><li>位置探测图形</li></ul><p>这个有点类似中文的“回”字。在 QR 码中有个这样的标识，它分别的左上、右上和左下角。作用是协助扫描软件定位 QR 码并转换坐标系。我们在扫描二维码的时候，不管是竖着扫、横着扫、斜着扫都能识别出内容，主要是它的功劳。</p><ul><li>位置探测图形分隔符</li></ul><p>主要作用是区分功能图形和编码区域。</p><ul><li>定位图形</li></ul><p>它由黑白间隔的各自各自组成的线条。主要用于指示标识密度和确定坐标系。原因是 QR 码一种有 40 个版本，也就是说有 40 种尺寸。每种二维码的尺寸越大，扫描的距离就越远。</p><ul><li>校正图形</li></ul><p>只有 Version 2 及以上的QR码有校正标识。校正标识用于进一步校正坐标系。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">2) 编码区域</strong><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">编码区域是数据进行编码存储的区域。它由<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">格式信息</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">版本信息</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">数据和纠错码字</strong>三部分构成。</p><ul><li>格式信息</li></ul><p>所有尺寸的二维码都有该信息。它存放一些格式化数据的信息，例如容错级别、数据掩码，和额外的自身 BCH 容错码。</p><ul><li>版本信息</li></ul><p>版本信息是规定二维码的规格。前面讲到 QR 码一共有 40 种规格的矩阵（一般为黑白色），从21x21（版本1），到177x177（版本40），每一版本符号比前一版本 每边增加4个模块。</p><ul><li>数据和纠错码</li></ul><p>主要是存储实际数据以及用于纠错码字。</p><h3 id="3-二维码的绘制过程"><a href="#3-二维码的绘制过程" class="headerlink" title="3 二维码的绘制过程"></a>3 二维码的绘制过程</h3><p>二维码已经是有一套国际标准，绘制二维码过程的严格按照标准来执行。这个过程是比较复杂，我自己也是看了大概，然后总结出大致绘制过程。如果你想深入了解绘制细节，可以阅读标准。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);">二维码的绘制大概过程如下：<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">1）在二维码的左上角、左下角、右上角绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形</strong>。位置探测图形一定是一个 7x7 的矩阵。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">2）绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">校正图形</strong>。校正图形一定是一个 5x5 的矩阵。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">3）绘制两条连接三个<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形</strong>的<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">定位图形</strong>。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">4）在上述图片的基础上，继续绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">格式信息</strong>。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">5）接着绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">版本信息</strong>。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">6）填充<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">数据码</strong>和<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">纠错码</strong>到二维码图中。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">7）最后是绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">蒙版图案</strong>。因为按照上述方式填充内容，可能会出现大面积的空白或黑块的情况，导致扫描识别会十分困难。所以需要对整个图像与蒙版进行蒙版操作(Masking)，蒙版操作即为异或 XOR 操作。在这一步，我们可以将数据排列成各种图片。</p><h3 id="4-二维码的生成"><a href="#4-二维码的生成" class="headerlink" title="4 二维码的生成"></a>4 二维码的生成</h3><p>我们既然已经了解二维码原理，那么可以利用 Python 生成二维码。然而网络上高人比比皆是。已经有大神编写了 Python 生成二维码的第三方库，所以我们不需要重复造轮子, 使用现成的库即可。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);">我就推荐两个库：<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong>&nbsp;和&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">python-qrcode</strong>。</p><ul><li><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong></li></ul><p><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong> 运行在 Python 3 版本上，它可以玩出很多花样。例如能生成以下三种二维码图片：普通二维码、带图片的艺术二维码（黑白与彩色）、动态二维码（黑白与彩色）。它比较适合直接用于生成二维码图片的场景。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);">安装 qrcode 库可以使用 pip 方式。但是该库依赖&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">pillow</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">numpy</strong>&nbsp;和&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">imageio</strong>。因此，我们需要先安装依赖库，再安装 qrcode。最后的安装命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐一安装</span></span><br><span class="line">pip <span class="keyword">install</span> pillow</span><br><span class="line">pip <span class="keyword">install</span> numpy</span><br><span class="line">pip <span class="keyword">install</span> imageio</span><br><span class="line">pip <span class="keyword">install</span> myqr</span><br></pre></td></tr></table></figure><p>该库生成带图片的艺术二维码算是一大亮点，具体用法如下:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myqr <span class="string">https:</span><span class="comment">//github.com -p github.jpg -c</span></span><br></pre></td></tr></table></figure><p>上述命令作用是将 github 主页写到彩色二维码中。  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/642.webp" alt=""></p><p>该库还支持生成 gif 的彩色二维码图片，具体用法如下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myqr http<span class="variable">s:</span>//github.<span class="keyword">com</span> -<span class="keyword">p</span> github.gif -<span class="keyword">c</span> -<span class="keyword">con</span> <span class="number">1.5</span> -bri <span class="number">1.6</span></span><br></pre></td></tr></table></figure></p><p>效果图如下：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/640.gif" alt=""></p><p>最后补上该库的 Github 地址：<a href="https://github.com/sylnsfar/qrcode" target="_blank" rel="noopener">https://github.com/sylnsfar/qrcode</a></p><ul><li><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">python-qrcode</strong></li></ul><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">python-qrcode</strong>&nbsp;相比&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong>&nbsp;要稍微逊色一点。不过它也有自己的特色。它支持生成矢量图，而且比较适合在代码中生成二维码的场景。</p><p>安装 python-qrcode 同样建议使用 pip 方式，安装命令如下：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> qrcode</span><br></pre></td></tr></table></figure></p><p>在 Python 代码中，最简单的用法是这样。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qrcodeimg = qrcode.make('https://github.com')</span><br></pre></td></tr></table></figure></p><p>它也支持自定义二维码的信息，具体用法如下：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> qrcode</span><br><span class="line"><span class="attr">qr</span> = qrcode.QRCode(</span><br><span class="line">    <span class="attr">version=1,</span></span><br><span class="line">    <span class="attr">error_correction=qrcode.constants.ERROR_CORRECT_L,</span></span><br><span class="line">    <span class="attr">box_size=10,</span></span><br><span class="line">    <span class="attr">border=4,</span></span><br><span class="line">)</span><br><span class="line">qr.add_data('https://github.com')</span><br><span class="line">qr.make(<span class="attr">fit=True)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">img</span> = qr.make_image(<span class="attr">fill_color="black",</span> <span class="attr">back_color="white")</span></span><br></pre></td></tr></table></figure></p><p>如果你想深入了解该库，可以到 Github 仓库阅读相关的文档。<br>Github 地址是：<a href="https://github.com/lincolnloop/python-qrcode" target="_blank" rel="noopener">https://github.com/lincolnloop/python-qrcode</a></p><p><br></p><p><center><br>此文摘自微信公众号【Python中文社区】<br>微信扫一扫<br>关注该公众号<br></center><br><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000005&amp;size=102&amp;__biz=MzAxMjUyNDQ5OA==&amp;mid=2653557161&amp;idx=1&amp;sn=e6b0e7656e7e700e41a33a7142cf38b6&amp;send_time=" alt="Python中文社区"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>都是套路：高并发系统的降级特技</title>
      <link href="/2018/08/26/%E9%83%BD%E6%98%AF%E5%A5%97%E8%B7%AF%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%99%8D%E7%BA%A7%E7%89%B9%E6%8A%80/"/>
      <url>/2018/08/26/%E9%83%BD%E6%98%AF%E5%A5%97%E8%B7%AF%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%99%8D%E7%BA%A7%E7%89%B9%E6%8A%80/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在开发高并发<a href="http://www.yunweipai.com/archives/8269.html" target="_blank" rel="noopener">系统</a>时有三把利器用来保护系统：缓存、降级和限流。之前已经有一些文章介绍过缓存和限流了。本文将详细聊聊降级。</p><a id="more"></a><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。</p><p>系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。本文将介绍一些笔者在实际工作中遇到的或见到过的一些降级方案供大家参考。</p><p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><h2 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h2><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p><strong>一般：</strong>比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p><strong>警告：</strong>有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p><strong>错误：</strong>比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p><strong>严重错误：</strong>比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><h4 id="降级的类别"><a href="#降级的类别" class="headerlink" title="降级的类别"></a>降级的类别</h4><ul><li>降级按照是否自动化可分为：自动开关降级和人工开关降级。</li><li>降级按照功能可分为：读服务降级、写服务降级。</li><li>降级按照处于的系统层次可分为：多级降级。</li></ul><h3 id="降级的功能点"><a href="#降级的功能点" class="headerlink" title="降级的功能点"></a>降级的功能点</h3><p>降级的功能点主要从服务端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级：</p><p><strong>页面降级：</strong>在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；</p><p><strong>页面片段降级：</strong>比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；</p><p><strong>页面异步请求降级：</strong>比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；</p><p><strong>服务功能降级：</strong>比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；</p><p><strong>读降级：</strong>比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；</p><p><strong>写降级：</strong>比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</p><p><strong>爬虫降级：</strong>在大促活动时，可以将爬虫流量导向静态页或者返回空数据从而降级保护后端稀缺资源。</p><h2 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h2><h3 id="1、自动开关降级"><a href="#1、自动开关降级" class="headerlink" title="1、自动开关降级"></a>1、自动开关降级</h3><p>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。</p><h4 id="超时降级"><a href="#超时降级" class="headerlink" title="超时降级"></a>超时降级</h4><p>当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；</p><div class="note info"><p>比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响</p></div><p>对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。</p><p>之前总结过一些的文章《使用httpclient必须知道的参数设置及代码写法、存在的风险》和《dbcp配置及jdbc超时设置总结》。在实际场景用一定主要配置好超时时间和超时重试次数和机制。</p><h4 id="统计失败次数降级"><a href="#统计失败次数降级" class="headerlink" title="统计失败次数降级"></a>统计失败次数降级</h4><p>有时候依赖一些不稳定的API，比如调用外部机票服务，当失败调用次数达到一定阀值自动降级；然后通过异步线程去探测服务是否恢复了，则取消降级。</p><h4 id="故障降级"><a href="#故障降级" class="headerlink" title="故障降级"></a>故障降级</h4><p>比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。</p><p><strong>降级后的处理方案有：</strong></p><div class="note info no-icon"><p>默认值（比如库存服务挂了，返回默认现货）<br>兜底数据（比如广告挂了，返回提前准备好的一些静态页面）<br>缓存（之前暂存的一些缓存数据）</p></div><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><p>当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；</p><p><strong>降级后的处理方案可以是：</strong></p><div class="note info no-icon"><p>排队页面（将用户导流到排队页面等一会重试）<br>无货（直接告知用户没货了）<br>错误页（如活动太火爆了，稍后重试）</p></div><h3 id="2、人工开关降级"><a href="#2、人工开关降级" class="headerlink" title="2、人工开关降级"></a>2、人工开关降级</h3><div class="note info no-icon"><p>1. 在大促期间通过监控发现线上的一些服务存在问题，这个时候需要暂时将这些服务摘掉；<br>2. 还有有时候通过任务系统调用一些服务，但是服务依赖的数据库可能存在：网卡被打满了、挂掉了或者很多慢查询，此时需要暂停下任务系统让服务方进行处理；<br>3. 还有发现突然调用量太大，可能需要改变处理方式（比如同步转换为异步）；</p></div><p>此时就可以<strong>使用开关来完成降级</strong>。</p><p>开关可以存放到配置文件、存放到数据库、存放到Redis/ZooKeeper；如果不是存放在本地，可以定期同步开关数据（比如1秒同步一次）。然后通过判断某个KEY的值来决定是否降级。</p><p>另外对于新开发的服务想上线进行灰度测试；但是不太确定该服务的逻辑是否正确，此时就需要设置开关，当新服务有问题可以通过开关切换回老服务。</p><p>还有多机房服务，如果某个机房挂掉了，此时需要将一个机房的服务切到另一个机房，此时也可以通过开关完成切换。</p><p>还有一些是因为功能问题需要暂时屏蔽掉某些功能，比如商品规格参数数据有问题，数据问题不能用回滚解决，此时需要开关控制降级。</p><h3 id="3、读服务降级"><a href="#3、读服务降级" class="headerlink" title="3、读服务降级"></a>3、读服务降级</h3><p><strong>对于读服务降级一般采用的策略有：</strong></p><div class="note info no-icon"><p>暂时切换读（降级到读缓存、降级到走静态化）<br>暂时屏蔽读（屏蔽读入口、屏蔽某个读服务）</p></div><p>在《应用多级缓存模式支撑海量读服务》中曾经介绍过<strong>读服务</strong>，即：</p><div class="note info no-icon"><p>接入层缓存→应用层本地缓存→分布式缓存→RPC服务/DB</p></div><p>我们会在接入层、应用层设置开关，当分布式缓存、RPC服务/DB有问题自动降级为不调用。当然这种情况适用于对读一致性要求不高的场景。</p><p>页面降级、页面片段降级、页面异步请求降级都是读服务降级，目的是丢卒保帅（比如因为这些服务也要使用核心资源、或者占了带宽影响到核心服务）或者因数据问题暂时屏蔽。</p><p>还有一种是页面静态化场景：</p><p><strong>动态化降级为静态化：</strong>比如平时网站可以走动态化渲染商品详情页，但是到了大促来临之际可以将其切换为静态化来减少对核心资源的占用，而且可以提升性能；其他还有如列表页、首页、频道页都可以这么玩；可以通过一个程序定期的推送静态页到缓存或者生成到磁盘，出问题时直接切过去；</p><p><strong>静态化降级为动态化：</strong>比如当使用静态化来实现商品详情页架构时，平时使用静态化来提供服务，但是因为特殊原因静态化页面有问题了，需要暂时切换回动态化来保证服务正确性。</p><p>以上都保证出问题了有预案，用户还是可以使用网站，不影响用户购物。</p><h3 id="4、写服务降级"><a href="#4、写服务降级" class="headerlink" title="4、写服务降级"></a>4、写服务降级</h3><p>写服务在大多数场景下是不可降级的，不过可以通过一些迂回战术来解决问题。比如将同步操作转换为异步操作，或者限制写的量/比例。</p><p>比如扣减库存一般这样操作：</p><h4 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h4><p>a、扣减DB库存；</p><p>b、扣减成功后更新Redis中的库存；</p><h4 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a><strong>方案2：</strong></h4><p>a、扣减Redis库存；</p><p>b、同步扣减DB库存，如果扣减失败则回滚Redis库存；</p><p>前两种方案非常依赖DB，假设此时DB性能跟不上则扣减库存就会遇到问题；因此我们可以想到<strong>方案3：</strong></p><p>a、扣减Redis库存：</p><p>b、正常同步扣减DB库存，性能扛不住时降级为发送一条扣减DB库存的消息，然后异步进行DB库存扣减实现最终一致即可；</p><p>这种方式发送扣减DB库存消息也可能成为瓶颈；这种情况我们可以考虑<strong>方案4：</strong></p><p>a、扣减Redis库存；</p><p>b、正常同步扣减DB库存，性能扛不住时降级为写扣减DB库存消息到本机，然后本机通过异步进行DB库存扣减来实现最终一致性。</p><p>也就是说正常情况可以同步扣减库存，在性能扛不住时降级为异步；另外如果是秒杀场景可以直接降级为异步，从而保护系统。</p><p>还有如下单操作可以在大促时暂时降级将下单数据写入Redis，然后等峰值过去了再同步回DB，当然也有更好的解决方案，但是更复杂，不是本文的重点。</p><p>还有如用户评价，如果评价量太大，也可以把评价从同步写降级为异步写。当然也可以对评价按钮进行按比例开放（比如一些人的看不到评价操作按钮）。比如评价成功后会发一些奖励，在必要的时候降级同步到异步。</p><h3 id="5、多级降级"><a href="#5、多级降级" class="headerlink" title="5、多级降级"></a>5、多级降级</h3><p>缓存是离用户最近越高效；而降级是离用户越近越能对系统保护的好。因为业务的复杂性导致越到后端QPS/TPS越低。</p><p><strong>页面JS降级开关：</strong>主要控制页面功能的降级，在页面中通过JS脚本部署功能降级开关，在适当时机开启/关闭开关；</p><p><strong>接入层降级开关</strong>：主要控制请求入口的降级，请求进入后会首先进入接入层，在接入层可以配置功能降级开关，可以根据实际情况进行自动/人工降级；</p><p>这个可以参考《京东商品详情页服务闭环实践》，尤其在后端应用服务出问题时，通过接入层降级从而给应用服务有足够的时间恢复服务；</p><p><strong>应用层降级开关：</strong>主要控制业务的降级，在应用中配置相应的功能开关，根据实际业务情况进行自动/人工降级。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>降级能保障系统在大促中活下来，而不是死去，达到丢卒保帅的作用。对用户提供有损服务，总比不服务要好。根据自己的场景设计相应的降级策略，保障系统在危机时刻能通过降级手段平稳度过。</p><p><a href="https://blog.csdn.net/enweitech" target="_blank" rel="noopener">EnweiTech</a>原创作品。转载请注明出处<a href="https://blog.csdn.net/enweitech" target="_blank" rel="noopener">https://blog.csdn.net/enweitech</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 降级 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</title>
      <link href="/2018/08/26/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7%E7%AD%89%E9%97%AE%E9%A2%98/"/>
      <url>/2018/08/26/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7%E7%AD%89%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;前面一节说到了《<a href="http://yfzhou.coding.me/2018/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8ARedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%81/#more">为什么说Redis是单线程的以及Redis为什么这么快！</a>》，今天给大家整理一篇关于Redis经常被问到的问题：缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等概念的入门及简单解决方案。</p><a id="more"></a><h2 id="一、缓存雪崩"><a href="#一、缓存雪崩" class="headerlink" title="一、缓存雪崩"></a>一、缓存雪崩</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存雪崩我们可以简单的理解为：<strong>由于原有缓存失效，新缓存未到期间</strong>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p><p>缓存正常从Redis中获取，示意图如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180312200437182.png" alt="这里写图片描述"></p><p>缓存失效瞬间示意图如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180312200640916.png" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存失效时的雪崩效应对底层系统的冲击非常可怕！大多数系统设计者考虑用<strong>加锁</strong>或者<strong>队列</strong>的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p>以下简单介绍两种实现方式的伪代码：</p><p>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是<strong>加锁排队</strong>，伪代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">public</span> object GetProductListNew() &#123;</span><br><span class="line">    <span class="built_in">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">String</span> cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    <span class="keyword">String</span> lockKey = cacheKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">String</span> cacheValue = CacheHelper.<span class="built_in">get</span>(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockKey) &#123;</span><br><span class="line">            cacheValue = CacheHelper.<span class="built_in">get</span>(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cacheValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里一般是sql查询数据</span></span><br><span class="line">                cacheValue = GetProductListFromDB(); </span><br><span class="line">                CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p><p>（2）还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">public</span> object GetProductListNew() &#123;</span><br><span class="line">    <span class="built_in">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">String</span> cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    <span class="comment">//缓存标记</span></span><br><span class="line">    <span class="keyword">String</span> cacheSign = cacheKey + <span class="string">"_sign"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">String</span> sign = CacheHelper.Get(cacheSign);</span><br><span class="line">    <span class="comment">//获取缓存值</span></span><br><span class="line">    <span class="keyword">String</span> cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (sign != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue; <span class="comment">//未过期，直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHelper.Add(cacheSign, <span class="string">"1"</span>, cacheTime);</span><br><span class="line">        ThreadPool.QueueUserWorkItem((arg) -&gt; &#123;</span><br><span class="line">            <span class="comment">//这里一般是 sql查询数据</span></span><br><span class="line">            cacheValue = GetProductListFromDB(); </span><br><span class="line">            <span class="comment">//日期设缓存时间的2倍，用于脏读</span></span><br><span class="line">            CacheHelper.Add(cacheKey, cacheValue, cacheTime * <span class="number">2</span>);                 </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><p>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p><p>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">GetProductListNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    String cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line"></span><br><span class="line">    String cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//数据库查询不到，为空</span></span><br><span class="line">        cacheValue = GetProductListFromDB();</span><br><span class="line">        <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果发现为空，设置个默认值，也缓存起来</span></span><br><span class="line">            cacheValue = <span class="keyword">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p><h2 id="三、缓存预热"><a href="#三、缓存预热" class="headerlink" title="三、缓存预热"></a>三、缓存预热</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p>解决思路：</p><p>1、直接写个缓存刷新页面，上线时手工操作下；</p><p>2、数据量不大，可以在项目启动的时候自动进行加载；</p><p>3、定时刷新缓存；</p><h2 id="四、缓存更新"><a href="#四、缓存更新" class="headerlink" title="四、缓存更新"></a>四、缓存更新</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>（1）定时去清理过期的缓存；</p><p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h2 id="五、缓存降级"><a href="#五、缓存降级" class="headerlink" title="五、缓存降级"></a>五、缓存降级</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这些都是实际项目中，可能碰到的一些问题，也是面试的时候经常会被问到的知识点，实际上还有很多很多各种各样的问题，文中的解决方案，也不可能满足所有的场景，相对来说只是对该问题的入门解决方法。一般正式的业务场景往往要复杂的多，应用场景不同，方法和解决方案也不同，由于上述方案，考虑的问题并不是很全面，因此并不适用于正式的项目开发，但是可以作为概念理解入门，具体解决方案要根据实际情况来确定！</p><hr><p>参考文章：</p><p>1、<a href="http://www.cnblogs.com/zhangweizhong/p/6258797.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangweizhong/p/6258797.html</a><br>2、<a href="http://www.cnblogs.com/zhangweizhong/p/5884761.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangweizhong/p/5884761.html</a><br>3、<a href="http://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">http://blog.csdn.net/zeb_perfect/article/details/54135506</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 集群分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么说Redis是单线程的以及Redis为什么这么快！</title>
      <link href="/2018/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8ARedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%81/"/>
      <url>/2018/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8ARedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><span><span><br><a id="more"></a></span></span></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;近乎所有与Java相关的面试都会问到缓存的问题，基础一点的会问到什么是“二八定律”、什么是“热数据和冷数据”，复杂一点的会问到缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题，这些看似不常见的概念，都与我们的缓存服务器相关，一般常用的缓存服务器有Redis、Memcached等，而笔者目前最常用的也只有Redis这一种。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你在以前面试的时候还没有遇到过面试官问你《为什么说Redis是单线程的以及Redis为什么这么快！》，那么你看到这篇文章的时候，你应该觉得是一件很幸运的事情！如果你刚好是一位高逼格的面试官，你也可以拿这道题去面试对面“望穿秋水”般的小伙伴，测试一下他的掌握程度。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;好啦！步入正题！我们先探讨一下Redis是什么，Redis为什么这么快、然后在探讨一下为什么Redis是单线程的？</p><h2 id="二、Redis简介"><a href="#二、Redis简介" class="headerlink" title="二、Redis简介"></a>二、Redis简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis是一个开源的内存中的数据结构存储系统，它可以用作：<strong>数据库、缓存和消息中间件</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。<strong>其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p><p>（1）硬盘数据库的工作模式：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20170307142145648.png" alt="这里写图片描述"><br>（2）内存数据库的工作模式：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20170307142210929.png" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;看完上述的描述，对于一些常见的Redis相关的面试题，是否有所认识了，例如：什么是Redis、Redis常见的数据结构类型有哪些、Redis是如何进行持久化的等。</p><h2 id="三、Redis到底有多快"><a href="#三、Redis到底有多快" class="headerlink" title="三、Redis到底有多快"></a>三、Redis到底有多快</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis采用的是基于内存的采用的是<strong>单进程单线程</strong>模型的 <strong>KV 数据库</strong>，<strong>由C语言编写</strong>，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差！有兴趣的可以参考官方的基准程序测试《<a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">How fast is Redis？</a>》（<a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">https://redis.io/topics/benchmarks</a>）</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/2018030715491722.png" alt="这里写图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>横轴是连接数，纵轴是QPS</strong>。此时，这张图反映了一个数量级，希望大家在面试的时候可以正确的描述出来，不要问你的时候，你回答的数量级相差甚远！</p><h2 id="四、Redis为什么这么快"><a href="#四、Redis为什么这么快" class="headerlink" title="四、Redis为什么这么快"></a>四、Redis为什么这么快</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p><p>（1）多路 I/O 复用模型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h2 id="五、那么为什么Redis是单线程的"><a href="#五、那么为什么Redis是单线程的" class="headerlink" title="五、那么为什么Redis是单线程的"></a>五、那么为什么Redis是单线程的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180307162652293.png" alt="这里写图片描述"><br>可以参考：<a href="https://redis.io/topics/faq" target="_blank" rel="noopener">https://redis.io/topics/faq</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;看到这里，你可能会气哭！本以为会有什么重大的技术要点才使得Redis使用单线程就可以这么快，没想到就是一句官方看似糊弄我们的回答！但是，我们已经可以很清楚的解释了为什么Redis这么快，并且正是由于在单线程模式的情况下已经很快了，就没有必要在使用多线程了！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p><p><strong>警告1</strong>：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180307172053108.png" alt="这里写图片描述"></p><p>ps命令的“-T”参数表示显示线程（Show threads, possibly with SPID column.）“SID”栏表示线程ID，而“CMD”栏则显示了线程名称。</p><p><strong>警告2</strong>：在上图中FAQ中的最后一段，表述了从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！所以该篇文章在以后的版本中是否还是单线程的方式需要读者考证！</p><h2 id="六、注意点"><a href="#六、注意点" class="headerlink" title="六、注意点"></a>六、注意点</h2><p>1、我们知道Redis是用”单线程-多路复用IO模型”来实现高性能的内存数据服务的，这种机制避免了使用锁，但是同时这种机制在进行sunion之类的比较耗时的命令时会使redis的并发下降。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个CPU核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成master-master或者master-slave的形式，耗时的读命令可以完全在slave进行。</p><p>需要改的redis.conf项：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis/redis_6377.pid  #pidfile要加上端口号</span><br><span class="line">port 6377  #这个是必须改的</span><br><span class="line">logfile /var/log/redis/redis_6377.log #logfile的名称也加上端口号</span><br><span class="line">dbfilename dump_6377.rdb  #rdbfile也加上端口号</span><br></pre></td></tr></table></figure></p><p>2、“我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以，我们可以手动地为其分配CPU核，而不会过多地占用CPU，或是让我们关键进程和一堆别的进程挤在一起。”。<br>CPU 是一个重要的影响因素，由于是单线程模型，Redis 更喜欢大缓存快速 CPU， 而不是多核</p><p>在多核 CPU 服务器上面，Redis 的性能还依赖NUMA 配置和处理器绑定位置。最明显的影响是 redis-benchmark 会随机使用CPU内核。为了获得精准的结果，需要使用固定处理器工具（在 Linux 上可以使用 taskset）。最有效的办法是将客户端和服务端分离到两个不同的 CPU 来高校使用三级缓存。</p><h2 id="七、扩展"><a href="#七、扩展" class="headerlink" title="七、扩展"></a>七、扩展</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;以下也是你应该知道的几种模型，祝你的面试一臂之力！</p><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180307172918264.png" alt="这里写图片描述"></p><hr><p>参考文章：</p><p>1、<a href="http://www.syyong.com/db/Redis-why-the-use-of-single-process-and-single-threaded-way-so-fast.html" target="_blank" rel="noopener">http://www.syyong.com/db/Redis-why-the-use-of-single-process-and-single-threaded-way-so-fast.html</a><br>2、<a href="http://blog.csdn.net/xxb2008/article/details/42238557" target="_blank" rel="noopener">http://blog.csdn.net/xxb2008/article/details/42238557</a><br>3、<a href="http://blog.csdn.net/hobbs136/article/details/7619719" target="_blank" rel="noopener">http://blog.csdn.net/hobbs136/article/details/7619719</a><br>4、<a href="http://blog.csdn.net/yushitao/article/details/43565851" target="_blank" rel="noopener">http://blog.csdn.net/yushitao/article/details/43565851</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载器深入探索</title>
      <link href="/2018/08/24/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/"/>
      <url>/2018/08/24/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h1 id="什么是-class文件？"><a href="#什么是-class文件？" class="headerlink" title="什么是.class文件？"></a>什么是.class文件？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;class文件全名称为Java class文件，主要在平台无关性和网络移动性方面使Java更适合网络。它在平台无关性方面的任务是：为Java程序提供独立于底层主机平台的二进制形式的服务。class文件径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。而这也是Java宣称的“一次编译，到处运行”的真正原因，因为各个系统上的Java文件都是被编译成.class文件，然后通过虚拟机来加载运行的。</p><h1 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;类加载器是一个用来加载类文件的类。Java源代码通过javac编译器编译成类文件。然后JVM来执行类文件中的字节码来执行程序。类加载器负责加载文件系统、网络或其他来源的类文件。有三种默认使用的类加载器：Bootstrap类加载器、Extension类加载器和System类加载器（或者叫作Application类加载器）。每种类加载器都有设定好从哪里加载类。</p><h1 id="生成一个对象实例发生了什么事？"><a href="#生成一个对象实例发生了什么事？" class="headerlink" title="生成一个对象实例发生了什么事？"></a>生成一个对象实例发生了什么事？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;生成一个实例，程序主要会把对应的类的java文件使用编译器生成字节码文件，然后等此类被调用静态变量或方法或生成实例时，虚拟机自动去相应目录查找字节码文件，并加载到虚拟机当中，然后生成对应的实例对象。每一个字节码文件只会被加载一次。其过程如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920142201727" alt="">  </p><h1 id="类加载的方式"><a href="#类加载的方式" class="headerlink" title="类加载的方式"></a>类加载的方式</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Java提供两种方法来达成动态行，一种是隐式的，另一种是显式的。这两种方式底层用到的机制完全相同，差异只有程序代码不同。隐式的就是当用到new这个Java关键字时，会让类加载器依需求载入所需的类。显式的又分为两种方法：一种是借用java.lang.Class里的forName()方法，另一种则是借用java.lang.ClassLoader里的loadClass()方法。  </p><h1 id="类加载器的树状组织结构及加载文件目录"><a href="#类加载器的树状组织结构及加载文件目录" class="headerlink" title="类加载器的树状组织结构及加载文件目录"></a>类加载器的树状组织结构及加载文件目录</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><p>(1) Bootstrap ClassLoader（引导类加载器） : 它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。将存放于&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用  </p><p>(2) Extension ClassLoader（扩展类加载器） : 它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。将&lt;JAVA_HOME&gt;\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。  </p><p>(3) Application ClassLoader或叫System Classloader （系统类加载器）: 负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p><p>以下有两种方式来取得类加载器的组织结构：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassLoadTest1</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line"> ClassLoader loader = ClassLoadTest1.class.getClassLoader(); </span><br><span class="line"> ClassLoader loader1 = ClassLoader.getSystemClassLoader();</span><br><span class="line"> <span class="comment">//从子到父取得加载器</span></span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="literal">null</span>) &#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(loader.toString()); </span><br><span class="line">            loader = loader.getParent(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (loader1 != <span class="literal">null</span>) &#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(loader1.toString()); </span><br><span class="line">            loader1 = loader1.getParent(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920145542249" alt="">  </p><p>可以看到，两种方法都是先取得 Application ClassLoader，然后再取得Extension ClassLoader。</p><p>表 1. ClassLoader 中与加载类相关的方法</p><table border="1"><tr><td>方法</td><td>说明</td></tr><tr></tr><tr><td>getParent()</td><td>返回该类加载器的父类加载器。</td></tr><tr></tr><tr><td>loadClass(String name)</td><td>加载名称为 name的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr></tr><tr><td>findClass(String name)</td><td>查找名称为 name的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例</td></tr><tr></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。</td></tr><tr></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>链接指定的 Java 类。</td></tr><tr></tr></table><p>&nbsp;&nbsp;&nbsp;&nbsp;除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 表 1中给出的 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。下图 中给出了一个典型的类加载器树状组织结构示意图，其中的箭头指向的是父类加载器。  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920143136831" alt="">  </p><p>每次加载的具体的过程：</p><h1 id="类加载器工作过程"><a href="#类加载器工作过程" class="headerlink" title="类加载器工作过程"></a>类加载器工作过程</h1><p>类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：<br>(1) 装载：查找和导入Class文件；<br>(2) 链接：把类的二进制数据合并到JRE中；<br>&nbsp;&nbsp;&nbsp;&nbsp;(a)校验：检查载入Class文件数据的正确性；<br>&nbsp;&nbsp;&nbsp;&nbsp;(b)准备：给类的静态变量分配存储空间；<br>&nbsp;&nbsp;&nbsp;&nbsp;(c)解析：将符号引用转成直接引用；</p><p>(3) 初始化：对类的静态变量，静态代码块执行初始化操作</p><h1 id="类加载器的工作原理"><a href="#类加载器的工作原理" class="headerlink" title="类加载器的工作原理"></a>类加载器的工作原理</h1><p>(1)委托机制<br>&nbsp;&nbsp;&nbsp;&nbsp;当一个类加载和初始化的时候，类仅在有需要加载的时候被加载。假设你有一个应用需要的类叫作Abc.class，首先加载这个类的请求由Application类加载器委托给它的父类加载器Extension类加载器，然后再委托给Bootstrap类加载器。Bootstrap类加载器会先看看rt.jar中有没有这个类，因为并没有这个类，所以这个请求由回到Extension类加载器，它会查看jre/lib/ext目录下有没有这个类，如果这个类被Extension类加载器找到了，那么它将被加载，而Application类加载器不会加载这个类；而如果这个类没有被Extension类加载器找到，那么再由Application类加载器从classpath中寻找。记住classpath定义的是类文件的加载目录，而PATH是定义的是可执行程序如javac，java等的执行路径。  </p><p>工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920154823695" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。下面通过示例来具体说明。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"> </span><br><span class="line">public class Sample &#123;</span><br><span class="line">private Sample<span class="built_in"> instance; </span></span><br><span class="line">    public void setSample(Object instance) &#123; </span><br><span class="line">        this.instance = (Sample)<span class="built_in"> instance; </span></span><br><span class="line">    &#125; </span><br><span class="line">    public void say()&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello LinBingwen"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是使用：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class ClassLoadTest4&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException, IllegalAccessException, NoSuchMethodException, InstantiationException, InvocationTargetException&#123;</span><br><span class="line">    ClassLoader pClassLoader = ClassLoader.getSystemClassLoader(); <span class="comment">// 以System ClassLoader作为父类加载器</span></span><br><span class="line">    URL[] baseUrls = &#123;<span class="keyword">new</span> URL(<span class="string">"file:/E:/workspace/Eclipse/ClassLoadTest"</span>)&#125;; <span class="comment">// 搜索类库的目录</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> binaryName = <span class="string">"com.lin.Sample"</span>; <span class="comment">// 需要加载的类的二进制名称</span></span><br><span class="line"> </span><br><span class="line">    ClassLoader userClassLoader1 = <span class="keyword">new</span> URLClassLoader(baseUrls, pClassLoader);</span><br><span class="line">    ClassLoader userClassLoader2 = <span class="keyword">new</span> URLClassLoader(baseUrls, pClassLoader);</span><br><span class="line">    Class clazz1 = userClassLoader1.loadClass(binaryName);</span><br><span class="line">    Class clazz2 = userClassLoader2.loadClass(binaryName);</span><br><span class="line">    <span class="keyword">Object</span> instance1 = clazz1.newInstance();</span><br><span class="line">    <span class="keyword">Object</span> instance2 = clazz2.newInstance();</span><br><span class="line">    <span class="comment">// 调用say方法</span></span><br><span class="line">    clazz1.getMethod(<span class="string">"say"</span>).invoke(instance1);</span><br><span class="line">    clazz2.getMethod(<span class="string">"say"</span>).invoke(instance2);</span><br><span class="line">    <span class="comment">// 输出类的二进制名称</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz1.toString());</span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz2.toString());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 比较两个类的地址是否相同</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz1 == clazz2);</span><br><span class="line">    <span class="comment">// 比较两个类是否相同或是否为继承关系</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz1.isAssignableFrom(clazz2));</span><br><span class="line">    <span class="comment">// 查看类型转换是否成功</span></span><br><span class="line">    <span class="built_in">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       Method setSampleMethod = clazz1.getMethod(<span class="string">"setSample"</span>, java.lang.<span class="keyword">Object</span>.class); </span><br><span class="line">       setSampleMethod.invoke(instance1, instance2); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.<span class="built_in">println</span>(ret);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920161618517" alt=""></p><p>因为都是从 ClassLoader.getSystemClassLoader(); // 以System ClassLoader作为父类加载器，所以两个加载器其实是一样的。</p><p>(2)可见性机制<br>根据可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。所以下面的例子中，当Abc.class已经被Application类加载器加载过了，然后如果想要使用Extension类加载器加载这个类，将会抛出java.lang.ClassNotFoundException异常。  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassLoadTest2 &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;          </span><br><span class="line">            <span class="comment">//打印当前的类加载器</span></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"ClassLoadTest2.getClass().getClassLoader() : "</span></span><br><span class="line">                                 + ClassLoadTest2.<span class="keyword">class</span>.getClassLoader());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//使用扩展类加载器再次加载子类加载器加载过的</span></span><br><span class="line">            <span class="keyword">Class</span>.forName(<span class="string">" com.lin.ClassLoadTest1"</span>, <span class="keyword">true</span></span><br><span class="line">                            ,  ClassLoadTest2.<span class="keyword">class</span>.getClassLoader().getParent());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            Logger.getLogger(ClassLoadTest2.<span class="keyword">class</span>.getName()).log(Level.SEVERE, <span class="keyword">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920152839964" alt=""></p><p>(3)单一性机制<br>根据这个机制，父加载器加载过的类不能被子加载器加载第二次。虽然重写违反委托和单一性机制的类加载器是可能的，但这样做并不可取。你写自己的类加载器的时候应该严格遵守这三条机制。  </p><p>参考文章：</p><p>1、<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a></p><p>2、<a href="http://www.cnblogs.com/ITtangtang/p/3978102.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3978102.html</a></p><p>3、<a href="http://www.cnblogs.com/rason2008/archive/2012/01/01/2309718.html" target="_blank" rel="noopener">http://www.cnblogs.com/rason2008/archive/2012/01/01/2309718.html</a></p><p>4、<a href="http://www.importnew.com/6581.html" target="_blank" rel="noopener">http://www.importnew.com/6581.html</a></p><p><br><br><a href="http://my.csdn.net/?ref=toolbar" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
            <tag> 类加载器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射探索研究</title>
      <link href="/2018/08/24/Java%E5%8F%8D%E5%B0%84%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6/"/>
      <url>/2018/08/24/Java%E5%8F%8D%E5%B0%84%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;摘要：本文详细深入讲解是Java中反射的机制，并介绍了如何通过反射来生成对象、调用函数、取得字段、设置字段的方法。最后，给出了一些反射常用到的实例。</p><a id="more"></a><h1 id="一、反射"><a href="#一、反射" class="headerlink" title="一、反射"></a>一、反射</h1><p>（1）概念<br>&nbsp;&nbsp;&nbsp;&nbsp;反射含义：可以获取正在运行的Java对象。<br>（2）功能<br>&nbsp;&nbsp;&nbsp;&nbsp;1)在运行时判断任意一个对象所属的类<br>&nbsp;&nbsp;&nbsp;&nbsp;2)在运行时构造任意一个类的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;3) 在运行时判断任意一个类所具有的成员变量和方法<br>&nbsp;&nbsp;&nbsp;&nbsp;4)在运行时调用任意一个对象的方法<br>（3）实现Java反射的类<br>&nbsp;&nbsp;&nbsp;&nbsp;1)Class：它表示正在运行的Java应用程序中的类和接口<br>&nbsp;&nbsp;&nbsp;&nbsp;2)Field：提供有关类或接口的属性信息，以及对它的动态访问权限<br>&nbsp;&nbsp;&nbsp;&nbsp;3)Constructor：提供关于类的单个构造方法的信息以及对它的访问权限<br>&nbsp;&nbsp;&nbsp;&nbsp;4)Method：提供关于类或接口中某个方法信息<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：<span style="color:red">Class类是Java反射中最重要的一个功能类，所有获取对象的信息(包括：方法/属性/构造方法/访问权限)都需要它来实现  </span></p><p>（4）取得class的三种方法</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> Dog(); </span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass = dog.getClass();</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass1 = Dog.<span class="keyword">class</span>;</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass2 = <span class="keyword">Class</span>.forName(<span class="string">"com.lin.Dog"</span>);<span class="comment">//注意要添加异常抛出</span></span><br></pre></td></tr></table></figure><p>（5）关键方法</p><table border="1"><tr><td>方法关键字</td><td>含义</td></tr><tr><td>getDeclaredMethods()</td><td>获取所有的方法</td></tr><tr><td>getReturnType()</td><td>获得方法的放回类型</td></tr><tr><td>getParameterTypes()</td><td>获得方法的传入参数类型</td></tr><tr><td>getDeclaredMethod(“方法名”,参数类型.class,……)</td><td>获得特定的方法</td></tr><tr><td></td><td></td></tr><tr><td>构造方法关键字</td><td>含义</td></tr><tr><td>getDeclaredConstructors()</td><td>获取所有的构造方法</td></tr><tr><td>getDeclaredConstructor(参数类型.class,……)</td><td>获取特定的构造方法</td></tr><tr><td></td><td></td></tr><tr><td>父类和父接口</td><td>含义</td></tr><tr><td>getSuperclass()</td><td>获取某类的父类</td></tr><tr><td>getInterfaces()</td><td>获取某类实现的接口</td></tr></table><p>（6）一些区别函数</p><p>public Method[] getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。</p><p>public Method[] getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p><p>getFields()获得某个类的所有的公共（public）的字段，包括父类。  </p><p>getDeclaredFields()获得某个类的所有申明的字段，即包括public、private和proteced，<br>但是不包括父类的申明字段。  </p><p>下面来看一个例子说明：</p><p>动物接口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"> </span><br><span class="line">public<span class="built_in"> interface </span>Aminal &#123;</span><br><span class="line"></span><br><span class="line">public String eat(String obj);</span><br><span class="line"></span><br><span class="line">public int <span class="builtin-name">run</span>(int obj);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.jar.Attributes.Name;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Aminal</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO 自动生成的构造函数存根  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;     </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">        System.out.println(name + <span class="string">"睡觉"</span> + x + <span class="string">"分钟"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eat</span><span class="params">(String obj)</span> </span>&#123;  </span><br><span class="line">        System.out.println(name + <span class="string">"吃"</span>+ obj);  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"跑，速度："</span>+ obj);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"狗名："</span> + name + <span class="string">"  狗的年纪："</span> + age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"狗狗自己玩啊玩"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看各自的调用：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectLearning</span> &#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line"> System.out.println(dog.getClass()); </span><br><span class="line"> System.out.println(dog.getClass().getName()); </span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">dogClass</span> = <span class="title">dog</span>.<span class="title">getClass</span>();</span></span><br><span class="line"> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">dogClass1</span> = <span class="title">Dog</span>.<span class="title">class</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">dogClass2</span> = <span class="title">Class</span>.<span class="title">forName</span>("<span class="title">com</span>.<span class="title">lin</span>.<span class="title">Dog</span>");</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">Method</span>[] <span class="title">methods1</span> =</span> dogClass.getMethods();</span><br><span class="line"> System.out.println(<span class="string">"====================通过getMethods取得方法开始===================="</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="function"><span class="keyword">Method</span> <span class="title">method</span> :</span> methods1) &#123;</span><br><span class="line"> System.out.println(<span class="function"><span class="keyword">method</span>); </span></span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(<span class="string">"====================通过getMethods取得方法结束===================="</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">Method</span>[] <span class="title">methods2</span> =</span> dogClass.getDeclaredMethods();</span><br><span class="line"> System.out.println(<span class="string">"====================通过getDeclaredMethods取得方法开始===================="</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="function"><span class="keyword">Method</span> <span class="title">method</span> :</span> methods2) &#123;</span><br><span class="line"> System.out.println(<span class="function"><span class="keyword">method</span>); </span></span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(<span class="string">"====================通过getDeclaredMethods取得方法结束===================="</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下结果：</p><p>getMethods方法</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122162709709" alt=""></p><p>getDeclareMethos方法：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122194430541" alt="">  </p><p>从上面可以看出getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p><h1 id="二、通过反射调用构造函数"><a href="#二、通过反射调用构造函数" class="headerlink" title="二、通过反射调用构造函数"></a>二、通过反射调用构造函数</h1><p>（1）、列出所有的构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = dogClass.getConstructors();</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"====================列出所有的构造函数结束===================="</span>);</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; <span class="keyword">constructor</span> : constructors) &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">constructor</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"====================列出所有的构造函数结束===================="</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122164012549" alt=""></p><p>（2）、通过反射生成对象</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"====================通过newInstance()来生成对象，一定在有默认构造函数===================="</span>);</span><br><span class="line">Dog dog1 = (Dog) dogClass.newInstance();</span><br><span class="line">dog1.setName(<span class="string">"狗狗1号"</span>);</span><br><span class="line">dog1.setAge(<span class="number">7</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(dog1);</span><br><span class="line"> </span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"====================通过newInstance(参数)方法一来生成对象===================="</span>);</span><br><span class="line">Dog dog2 = (Dog)constructors[<span class="number">0</span>].newInstance(<span class="string">"狗狗2号"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(dog2);</span><br><span class="line"> </span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"====================通过newInstance(参数)方法二来生成对象===================="</span>);</span><br><span class="line">Constructor con1 = dogClass.getConstructor(<span class="keyword">new</span>  <span class="keyword">Class</span>[]&#123;String.<span class="keyword">class</span>,<span class="keyword">int</span>.<span class="keyword">class</span>&#125;);     <span class="comment">//主要就是这句了</span></span><br><span class="line">Dog dog3 = (Dog) con1.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">"狗狗3号"</span>,<span class="number">14</span>&#125;);</span><br><span class="line">System.out.<span class="keyword">println</span>(dog3);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122165743286" alt="">  </p><p>从上面可以看出，先通过getConstructor(new  Class[]{xxxx.class,yyy.class}),再通过con1.newInstance(new Object[]{“xxxxx”,…});的方式是最灵活的，可以自动根据输入的参数类型和个数，找到对应的构造函数来调用。第二种方法需要得到构造函数的数组，并且需要知道对应哪一个构造函数。第一种就只能调用无参构造函数。</p><h1 id="三、通过反射调用普通函数、静态函数"><a href="#三、通过反射调用普通函数、静态函数" class="headerlink" title="三、通过反射调用普通函数、静态函数"></a>三、通过反射调用普通函数、静态函数</h1><p>（1）取得函数的一些基本信息</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass = Dog.class;</span><br><span class="line"><span class="function"><span class="keyword">Method</span>[] <span class="title">methods</span> = <span class="title">dogClass</span>.<span class="title">getDeclaredMethods</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="function"><span class="keyword">Method</span> <span class="title">method</span> :</span> methods) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">System.out.println("函数名："+method.getName() +"        函数类型："+ method.getModifiers() + "         函数返回： "+ method.getReturnType() + "        函数参数个数：" + method.getParameterCount());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122171525947" alt="">  </p><p>其中函数类型对应表如下：<br>PUBLIC: 1<br>PRIVATE: 2<br>PROTECTED: 4<br>STATIC: 8<br>FINAL: 16<br>SYNCHRONIZED: 32<br>VOLATILE: 64<br>TRANSIENT: 128<br>NATIVE: 256<br>INTERFACE: 512<br>ABSTRACT: 1024<br>STRICT: 2048  </p><p>（2）方法调用</p><p>这是当前狗类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.jar.Attributes.Name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Aminal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的构造函数存根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">"睡觉"</span> + x + <span class="string">"分钟"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">eat</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">"吃"</span>+ obj);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"跑，速度："</span>+ obj);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"狗名："</span> + name + <span class="string">"  狗的年纪："</span> + age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狗狗自己玩啊玩"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同方法的调用过程：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用私有方法</span></span><br><span class="line">Method method1 = dogClass.getDeclaredMethod(<span class="string">"sleep"</span>, int.class);<span class="comment">//不要用getMethod，它只能取到public方法</span></span><br><span class="line">Dog dog1 = (Dog) dogClass.getConstructor(<span class="keyword">new</span> <span class="type">Class</span>[] &#123;<span class="keyword">String</span>.class&#125;).<span class="keyword">new</span><span class="type">Instance</span>(<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"狗狗1号"</span>&#125;);</span><br><span class="line">method1.setAccessible(<span class="literal">true</span>);<span class="comment">//私有方法一定要加这句</span></span><br><span class="line">method1.invoke(dog1, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用私有静态方法</span></span><br><span class="line">              Method method2 = dogClass.getDeclaredMethod(<span class="string">"play"</span>);<span class="comment">//不要用getMethod，它只能取到public方法 </span></span><br><span class="line">              method2.setAccessible(<span class="literal">true</span>);<span class="comment">//私有方法一定要加这句</span></span><br><span class="line">             method2.invoke(dogClass.<span class="keyword">new</span><span class="type">Instance</span>()); </span><br><span class="line">      </span><br><span class="line">             <span class="comment">//调用公共方法</span></span><br><span class="line">Method method3 = dogClass.getMethod(<span class="string">"eat"</span>, <span class="keyword">String</span>.class);<span class="comment">//这里也可以用getDeclaredMethod</span></span><br><span class="line">Dog dog3 = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"狗狗3号"</span>, <span class="number">45</span>);</span><br><span class="line">method3.invoke(dog3, <span class="string">"苹果～"</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122173757753" alt="">  </p><p>方法调用这里一定要记住getMethod和getDeclaredMethod的区别，并且在调用私有的方法之前一定要加setAccessible（true）这一句，要不会报错！</p><h1 id="四、通过反射取得字段、设置字段值"><a href="#四、通过反射取得字段、设置字段值" class="headerlink" title="四、通过反射取得字段、设置字段值"></a>四、通过反射取得字段、设置字段值</h1><p>(1)怎么通过反射获取类的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;a)Class.getDeclaredField(String name);<br>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。<br>&nbsp;&nbsp;&nbsp;&nbsp;b)Class.getDeclaredFields();<br>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。<br>&nbsp;&nbsp;&nbsp;&nbsp;c)Class.getField(String name);<br>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。<br>&nbsp;&nbsp;&nbsp;&nbsp;d)Class.getField();<br>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。  </p><p>(2)进行属性获取更改  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dog dog1 = <span class="keyword">new</span> Dog(<span class="string">"狗狗1号"</span>, <span class="number">12</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(dog1);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; dogClass = dog1.getClass();</span><br><span class="line">Field field1 = dogClass.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//注意，getField只能取得public的字段</span></span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);<span class="comment">//私有变量必须先设置Accessible为true</span></span><br><span class="line">   System.<span class="keyword">out</span>.println(<span class="string">"原本狗名："</span> + field1.<span class="keyword">get</span>(dog1));</span><br><span class="line"></span><br><span class="line">field1.<span class="keyword">set</span>(dog1,<span class="string">"狗狗2号"</span>);</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(dog1);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122194146554" alt="">  </p><p>值得注意的是获取私有属性的时候必须先设置Accessible为true，然后才能获取。  </p><h1 id="五、反射常用工具类"><a href="#五、反射常用工具类" class="headerlink" title="五、反射常用工具类"></a>五、反射常用工具类</h1><p>（1）bean复制工具<br>&nbsp;&nbsp;&nbsp;&nbsp;这里可以使用commons-beanutils中的copyProperties()方法，自己写是为了加深对反射的理解。</p><p>1、toString的基类</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean基類</span></span><br><span class="line"><span class="comment"> * @author lin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class BaseBean &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> toString() &#123; </span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();  </span><br><span class="line">  SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">      Class&lt;?&gt; cls = <span class="keyword">this</span>.getClass();</span><br><span class="line">      Field[] fields = cls.getDeclaredFields();</span><br><span class="line">  sb.<span class="built_in">append</span>(cls.getName() + <span class="string">"&#123;"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">          field.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">          sb.<span class="built_in">append</span>(field.getName());  </span><br><span class="line">          sb.<span class="built_in">append</span>(<span class="string">"="</span>);  </span><br><span class="line">          sb.<span class="built_in">append</span>(field.<span class="built_in">get</span>(<span class="keyword">this</span>));  </span><br><span class="line">          sb.<span class="built_in">append</span>(<span class="string">" "</span>);  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">          e.printStackTrace();  </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line">      sb.<span class="built_in">append</span>(<span class="string">"&#125;"</span>);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、bean复制工具</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个JavaBean风格对象的属性值拷贝到另一个对象的同名属性中 (如果不存在同名属性的就不拷贝）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class BeanCopy &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> GET = <span class="string">"get"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> SET = <span class="string">"set"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param source</span></span><br><span class="line"><span class="comment">     * @param target</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">copy</span>(<span class="keyword">Object</span> source,<span class="keyword">Object</span> target)&#123;</span><br><span class="line">Class&lt;?&gt; sourceClz = source.getClass();</span><br><span class="line">Class&lt;?&gt; targetClz = target.getClass();</span><br><span class="line"><span class="comment">// 得到Class对象所表征的类的所有属性(包括私有属性)</span></span><br><span class="line">Field[] sourceFields = sourceClz.getDeclaredFields();</span><br><span class="line"><span class="keyword">if</span> (sourceFields.length == <span class="number">0</span>) &#123;</span><br><span class="line">sourceFields = sourceClz.getSuperclass().getDeclaredFields();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> len = sourceFields.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">String</span> fieldName = sourceFields[i].getName();</span><br><span class="line">Field targetField = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 得到targetClz对象所表征的类的名为fieldName的属性，不存在就进入下次循环</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">targetField = targetClz.getDeclaredField(fieldName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">targetField = targetClz.getSuperclass().getDeclaredField(fieldName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (targetField == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断sourceClz字段类型和targetClz同名字段类型是否相同</span></span><br><span class="line"><span class="keyword">if</span> (sourceFields[i].getType() == targetField.getType()) &#123;</span><br><span class="line"><span class="comment">// 由属性名字得到对应get和set方法的名字</span></span><br><span class="line"><span class="keyword">String</span> getMethodName = GET + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">String</span> setMethodName = SET + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 由方法的名字得到get和set方法的Method对象</span></span><br><span class="line">Method getMethod;</span><br><span class="line">Method setMethod;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getMethod = sourceClz.getDeclaredMethod(getMethodName,<span class="keyword">new</span> Class[] &#123;&#125;);<span class="comment">//get方法入參為空</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">getMethod = sourceClz.getSuperclass().getDeclaredMethod(getMethodName,<span class="keyword">new</span> Class[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">setMethod = targetClz.getDeclaredMethod(setMethodName,sourceFields[i].getType());<span class="comment">//set方法入參不為空</span></span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">setMethod = targetClz.getSuperclass().getDeclaredMethod(setMethodName,sourceFields[i].getType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用source对象的getMethod方法</span></span><br><span class="line"><span class="keyword">Object</span> result = getMethod.invoke(source, <span class="keyword">new</span> <span class="keyword">Object</span>[] &#123;&#125;);</span><br><span class="line"><span class="comment">// 调用target对象的setMethod方法</span></span><br><span class="line">setMethod.invoke(target, result);</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><p>新建两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">BaseBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Boolean sellFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> maxSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> minSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> driverPeople;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getSellFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSellFlag</span><span class="params">(Boolean sellFlag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sellFlag = sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">double</span> maxSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMinSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinSpeed</span><span class="params">(<span class="keyword">double</span> minSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.minSpeed = minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDriverPeople</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverPeople</span><span class="params">(<span class="keyword">int</span> driverPeople)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.driverPeople = driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">BaseBean</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Boolean sellFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> maxSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> minSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> driverPeople;<span class="comment">//和car類型不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> driverYear;<span class="comment">//car沒有這個</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getSellFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSellFlag</span><span class="params">(Boolean sellFlag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sellFlag = sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">double</span> maxSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMinSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinSpeed</span><span class="params">(<span class="keyword">double</span> minSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.minSpeed = minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDriverPeople</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverPeople</span><span class="params">(<span class="keyword">long</span> driverPeople)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.driverPeople = driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDriverYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> driverYear;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverYear</span><span class="params">(<span class="keyword">int</span> driverYear)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.driverYear = driverYear;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void test5() &#123;</span><br><span class="line">Car car = new Car()<span class="comment">;</span></span><br><span class="line">car.setAge(<span class="number">12</span>)<span class="comment">;</span></span><br><span class="line">car.setDriverPeople(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">car.setId(<span class="string">"YU1234"</span>)<span class="comment">;</span></span><br><span class="line">car.setMaxSpeed(<span class="number">13</span>.<span class="number">66</span>)<span class="comment">;</span></span><br><span class="line">car.setMinSpeed(<span class="number">1</span>.<span class="number">09</span>)<span class="comment">;</span></span><br><span class="line">car.setName(<span class="string">"小车"</span>)<span class="comment">;</span></span><br><span class="line">car.setSellFlag(false)<span class="comment">;</span></span><br><span class="line">car.setDate(new Date())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bus </span><span class="keyword">bus </span>= new <span class="keyword">Bus();</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">BeanCopy.copy(car,bus);</span></span><br><span class="line"><span class="keyword"></span>System.out.println(car)<span class="comment">;</span></span><br><span class="line">System.out.println(<span class="keyword">bus);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122205834415" alt=""></p><p>除了两个不同的字段外，其它的都复制过去了，这在DTO、VO、DOMAIN对象转换时经常用到。</p><p><br><br><a href="http://my.csdn.net/?ref=toolbar" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射探索-----从类加载说起</title>
      <link href="/2018/08/24/Java%E5%8F%8D%E5%B0%84%E6%8E%A2%E7%B4%A2-%E4%BB%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%AF%B4%E8%B5%B7/"/>
      <url>/2018/08/24/Java%E5%8F%8D%E5%B0%84%E6%8E%A2%E7%B4%A2-%E4%BB%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;摘要：本文主要讲了Java类加载的机制，这是学习反射的入门基础。</span></p><h1 id="一、类加载"><a href="#一、类加载" class="headerlink" title="一、类加载"></a>一、类加载</h1><p><strong>JVM和类</strong>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们调用Java命令运行某个Java程序时，该命令将会启动一条Java虚拟机进程，不管该Java程序有多么复杂，该程序启动了多少个线程，它们都处于该Java虚拟机进程里。正如前面介绍的，同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。当系统出现以下几种情况时，JVM进程将被终止:  </p><p>1、程序运行到最后正常结束。<br>2、程序运行到使用System.exit()或Runtime.getRuntime().exit()代码结束程序。<br>3、程序执行过程中遇到未捕获的异常或错误而结束。<br>3、程序所在平台强制结束了JVM进程。<br>从上面的介绍可以看出，当Java程序运行结束时，JVM进程结束，该进程在内存中状态将会丢失。</p><p><strong>类的生命周期</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021091611555" alt=""></p><p><strong>类的加载/类初始化</strong>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。</p><p><strong>加载：查找并加载类的二进制数据</strong></p><p>1、通过一个类的全限定名来获取定义此类的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</p><p><span style="color:red"><strong>注意：将编译后的java类文件（也就是.class文件）中的二进制数据读入内存，并将其放在运行时数据区的方法区内，然后再堆区创建一个Java.lang.Class对象，用来封装类在方法区的数据结构。即加载后最终得到的是Class对象，并且更加值得注意的是：该Java.lang.Class对象是单实例的，无论这个类创建了多少个对象，他的Class对象时唯一的！</strong>  </span><br><strong>连接：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1、验证：确保被加载的类的正确性<br>&nbsp;&nbsp;&nbsp;&nbsp;2、准备：为类的静态变量分配内存，并将其初始化为默认值<br>&nbsp;&nbsp;&nbsp;&nbsp;3、解析：把类中的符号引用转换为直接引用。<br><strong>初始化：为类的静态变量赋予正确的初始值。</strong></p><p><strong><span style="color:red">注意：连接和初始化阶段，其实静态变量经过了两次赋值：第一次是静态变量类型的默认值；第二次是我们真正赋给静态变量的值。</span></strong></p><p>我简单画了个图，其过程如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021091656155" alt="">  </p><p><strong><span style="color:red">类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。事实上，每个类是一批具有相同特征的对象的抽象(或者说概念)，而系统中所有的类，它们实际上也是对象，它们都是java.lang.Class的实例。</span></strong>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是我们前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</strong>  </p><p>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源:  </p><p><strong> 1、从本地文件系统来加载class文件，这是绝大部分示例程序的类加载方式。  </strong><br><strong>  2、从JAR包中加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就是放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。  </strong><br><strong>  3、通过网络加载class文件。  </strong><br><strong>  4、把一个Java源文件动态编译、并执行加载。</strong>  </p><p>类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。</p><p><strong>Java程序对类的使用方式  </strong><br><strong>  主动使用</strong><br>1、创建类的实例<br>2、方法某个类或接口的静态变量，或者对该静态变量赋值<br>3、调用类的静态方法<br>4、反射（如 Class.forName(“com.itzhai.Test”)）<br>5、初始化一个类的子类<br>6、Java虚拟机启动时被标明为启动类的类（Main Class）  </p><p><strong>被动使用</strong><br>除了以上6中方式，其他对类的使用都是被动使用，都不会导致类的初始化。类的初始化时机正是java程序对类的首次主动使用，<br>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化它们。</p><p><strong>对象初始化</strong><br>在类被装载、连接和初始化，这个类就随时都可能使用了。对象实例化和初始化是就是对象生命的起始阶段的活动，在这里我们主要讨论对象的初始化工作的相关特点。<br>Java 编译器在编译每个类时都会为该类至少生成一个实例初始化方法–即”<init>()” 方法。此方法与源代码中的每个构造方法相对应，如果类没有明确地声明任何构造方法，编译器则为该类生成一个默认的无参构造方法，这个默认的构造器仅仅调用父类的无参构造器，与此同时也会生成一个与默认构造方法对应的 “<init>()” 方法.<br>通常来说，<init>() 方法内包括的代码内容大概为：调用另一个 <init>() 方法；对实例变量初始化；与其对应的构造方法内的代码。<br>如果构造方法是明确地从调用同一个类中的另一个构造方法开始，那它对应的 <init>() 方法体内包括的内容为：一个对本类的 <init>() 方法的调用；对应用构造方法内的所有字节码。<br>如果构造方法不是通过调用自身类的其它构造方法开始，并且该对象不是 Object 对象，那 <init>() 法内则包括的内容为：一个对父类 <init>() 方法的调用；对实例变量初始化方法的字节码；最后是对应构造子的方法体字节码。<br>如果这个类是 Object，那么它的 <init>() 方法则不包括对父类 <init>() 方法的调用。</init></init></init></init></init></init></init></init></init></init></p><h1 id="二、Class-forName、实例对象-class-属性-、实例对象getClass-的区别"><a href="#二、Class-forName、实例对象-class-属性-、实例对象getClass-的区别" class="headerlink" title="二、Class.forName、实例对象.class(属性)、实例对象getClass()的区别"></a>二、Class.forName、实例对象.class(属性)、实例对象getClass()的区别</h1><p>1、相同点：<br>通过这几种方式，得到的都是Java.lang.Class对象（这个是上面讲到的类在加载时获得的最终产物）<br>例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> people &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> * @param args    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"..............使用不同的方式加载类..................."</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(people.<span class="keyword">class</span>);<span class="comment">//通过类.class获得Class对象</span></span><br><span class="line">people a = <span class="keyword">new</span> people();</span><br><span class="line">System.out.<span class="keyword">println</span>(a.getClass());<span class="comment">//通过 实例名.getClass()获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">Class</span>.forName(<span class="string">"com.lin.people"</span>));<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"..............使用不同的方式创建对象..................."</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(a);<span class="comment">//使用不同的方式创建对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(people.<span class="keyword">class</span>.newInstance());</span><br><span class="line">System.out.<span class="keyword">println</span>(a.getClass().newInstance());</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">Class</span>.forName(<span class="string">"com.lin.people"</span>).newInstance()); </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021091837350" alt=""></p><p>从上面可以看到不同的方式加载类。其实这一过程只发生一次！</p><p>2、区别：</p><p>下面用一个实例来说说它们的区别</p><p>如下新建一个类</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"生成了一只猫"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CatTest &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> * @param args    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class开始------------------"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(Cat.<span class="keyword">class</span>);<span class="comment">//通过类.class获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Class.forName开始------------------"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">Class</span>.forName(<span class="string">"com.lin.Cat"</span>));<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Class.forName结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()开始------------------"</span>);</span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.<span class="keyword">println</span>(cat.getClass());<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021092000170" alt=""></p><p>如果，将Class.forName()去掉：</p><p>如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CatTest &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> * @param args    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class开始------------------"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(Cat.<span class="keyword">class</span>);<span class="comment">//通过类.class获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class结束------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("---------------Class.forName开始------------------");</span></span><br><span class="line"><span class="comment">//System.out.println(Class.forName("com.lin.Cat"));//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line"><span class="comment">//System.out.println("---------------Class.forName结束------------------");</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()开始------------------"</span>);</span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.<span class="keyword">println</span>(cat.getClass());<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果又变成：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021092344220" alt=""></p><p>所以，可以得出以下结论：</p><p>1)Class cl=Cat.class; <strong>JVM将使用类Cat的类装载器,将类A装入内存(前提是:类A还没有装入内存),不对类A做类的初始化工作.</strong>返回类A的Class的对象<br>2)Class cl=对象引用o.getClass();<strong>返回引用o运行时真正所指的对象(因为:儿子对象的引用可能会赋给父对象的引用变量中)所属的类的Class的对象 ,如果还没装载过，会进行装载。</strong><br>3)Class.forName(“类名”); <strong>装入类A,并做类的初始化(前提是:类A还没有装入内存)</strong>  </p><h1 id="三、new和newInstance"><a href="#三、new和newInstance" class="headerlink" title="三、new和newInstance()"></a>三、new和newInstance()</h1><p>从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。但是使用Class对象的newInstance()方法的时候，就必须保证：</p><p>1、这个类已经加载；</p><p>2、这个类已经连接了。而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。   </p><p>现在可以看出，Class对象的newInstance()（这种用法和Java中的工厂模式有着异曲同工之妙）实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。 </p><p>Class.forName().newInstance()和通过new得到对象的区别</p><p>1、使用newInstance可以解耦。使用newInstance的前提是，类已加载并且这个类已连接，这是正是class的静态方法forName（）完成的工作。newInstance实际上是把new 这个方式分解为两步，即，首先调用class的加载方法加载某个类，然后实例化。  </p><p>2、newInstance: 弱类型。低效率。只能调用无参构造。 new: 强类型。相对高效。能调用任何public构造。   </p><p>3、newInstance()是实现IOC、反射、面对接口编程和依赖倒置等技术方法的必然选择，new只能实现具体类的实例化，不适合于接口编程。   </p><p>4、 newInstance() 一般用于动态加载类。  </p><p>5、Class.forName(“”).newInstance()返回的是object 。</p><p>6、newInstance( )是一个方法，而new是一个关键字；</p><p>注:一般在通用框架里面用的就是class.forName来加载类,然后再通过反射来调用其中的方法,譬如Tomcat源码里面,这样就避免了new关键字的耦合度,还有让不同的类加载器来加载不同的类,方便提高类之间的安全性和隔离性.</p><p><a href="http://my.csdn.net/Evankaka" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java多线程学习（吐血超详细总结）</title>
      <link href="/2018/08/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%90%90%E8%A1%80%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93%EF%BC%89/"/>
      <url>/2018/08/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%90%90%E8%A1%80%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;写在前面的话：此文只能说是java多线程的一个入门，其实Java里头线程完全可以写一本书了，但是如果最基本的你都学掌握好，又怎么能更上一个台阶呢？如果你觉得此文很简单，那推荐你看看Java并发包的的线程池（<a href="http://blog.csdn.net/evankaka/article/details/51489322" target="_blank" rel="noopener">Java并发编程与技术内幕:线程池深入理解</a>），或者看这个专栏：<a href="http://blog.csdn.net/column/details/javahhighconcurrence.html" target="_blank" rel="noopener">Java并发编程与技术内幕</a>。你将会对Java里头的高并发场景下的线程有更加深刻的理解。</p><a id="more"></a><p>目录</p><ol><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t0">一扩展javalangThread类</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t1">二实现javalangRunnable接口</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t2">三Thread和Runnable的区别</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t3">四线程状态转换</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t4">五线程调度</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t5">六常用函数说明</a><ol><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t6">使用方式</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t7">为什么要用join方法</a></li></ol></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t8">七常见线程名词解释</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t9">八线程同步</a></li><li><a href="/2018/08/23/Java多线程学习（吐血超详细总结）#t10">九线程数据传递</a></li></ol><p>本文主要讲了java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别：</p><p><strong>　　进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）</strong></p><p><strong>　　线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</strong></p><p>　　<span style="color:red">线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</span></p><p>　　<span style="color:red">多进程是指操作系统能同时运行多个任务（程序）。</span></p><p>　　多线程是指在同一程序中有多个顺序流在执行。</p><p>在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(<span style="color:red"><strong>其实准确来讲，应该有三种，还有一种是实现Callable接口</strong></span>，并与Future、线程池结合使用，此文这里不讲这个，有兴趣看这里<a href="http://blog.csdn.net/evankaka/article/details/51610635" target="_blank" rel="noopener">Java并发编程与技术内幕:Callable、Future、FutureTask、CompletionService</a>)  </p><h1 id="一、扩展java-lang-Thread类"><a href="#一、扩展java-lang-Thread类" class="headerlink" title="一、扩展java.lang.Thread类"></a><a name="t0">一、扩展java.lang.Thread类</a></h1><p>这里继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.（<span style="color:red"><strong>笔者推荐使用Runable，后头会说明为什么</strong></span>）。下面来看一个简单的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.multithread.learning;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行  :  "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：</p><p>A运行  :  0<br>B运行  :  0<br>A运行  :  1<br>A运行  :  2<br>A运行  :  3<br>A运行  :  4<br>B运行  :  1<br>B运行  :  2<br>B运行  :  3<br>B运行  :  4</p><p>再运行一下：</p><p>A运行  :  0<br>B运行  :  0<br>B运行  :  1<br>B运行  :  2<br>B运行  :  3<br>B运行  :  4<br>A运行  :  1<br>A运行  :  2<br>A运行  :  3<br>A运行  :  4  </p><p>说明：</p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。</p><p>注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p><p>从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</p><p>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</p><p>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。</p><p>但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread1 mTh1=new Thread1(<span class="string">"A"</span>)<span class="comment">;</span></span><br><span class="line">Thread1 mTh2=mTh1<span class="comment">;</span></span><br><span class="line">mTh1.start()<span class="comment">;</span></span><br><span class="line">mTh2.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.IllegalThreadStateException</span>  </span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.start</span>(Unknown Source)  </span><br><span class="line">    at com<span class="selector-class">.multithread</span><span class="selector-class">.learning</span><span class="selector-class">.Main</span><span class="selector-class">.main</span>(Main<span class="selector-class">.java</span>:<span class="number">31</span>)  </span><br><span class="line">A运行  :  <span class="number">0</span>  </span><br><span class="line">A运行  :  <span class="number">1</span>  </span><br><span class="line">A运行  :  <span class="number">2</span>  </span><br><span class="line">A运行  :  <span class="number">3</span>  </span><br><span class="line">A运行  :  <span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="二、实现java-lang-Runnable接口"><a href="#二、实现java-lang-Runnable接口" class="headerlink" title="二、实现java.lang.Runnable接口"></a><a name="t1">二、实现java.lang.Runnable接口</a></h1><p>采用Runnable也是非常常见的一种，我们只需要重写run方法即可。下面也来看个实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.multithread.runnable;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行  :  "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"C"</span>)).start();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"D"</span>)).start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：</p><p>C运行  :  0<br>D运行  :  0<br>D运行  :  1<br>C运行  :  1<br>D运行  :  2<br>C运行  :  2<br>D运行  :  3<br>C运行  :  3<br>D运行  :  4<br>C运行  :  4</p><p>说明：</p><p>Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><h1 id="三、Thread和Runnable的区别"><a href="#三、Thread和Runnable的区别" class="headerlink" title="三、Thread和Runnable的区别"></a><a name="t2">三、Thread和Runnable的区别</a></h1><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p><p><strong>总结：  </strong></p><p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p><p><strong>1）：适合多个相同的程序代码的线程去处理同一个资源</strong></p><p><strong>2）：可以避免java中的单继承的限制</strong></p><p><strong>3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</strong></p><p><strong>4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</strong></p><p><span style="color:red"><strong>提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。</strong></span></p><p><span style="color:red"><strong>在**</strong>java<strong><strong>中，每次程序运行至少启动</strong></strong>2<strong><strong>个线程。一个是</strong></strong>main<strong><strong>线程，一个是垃圾收集线程。因为每当使用</strong></strong>java<strong>**命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ实习在就是在操作系统中启动了一个进程。</strong></span></p><h1 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a><a name="t3">四、线程状态转换</a></h1><p>下面的这个图非常重要！你如果看懂了这个图，那么对于多线程的理解将会更加深刻！</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150309140927553" alt="">  </p><p>1、新建状态（New）：新创建了一个线程对象。</p><p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</p><p>3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</p><p><span style="color:red"><strong>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</strong></span></p><p><span style="color:red"><strong>（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</strong></span></p><p><span style="color:red"><strong>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</strong></span></p><p><span style="color:red"><strong>（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</strong></span></p><p>5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。  </p><h1 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a><a name="t4">五、线程调度</a></h1><p>线程的调度</p><p>1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。</p><p>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程可以具有的最高优先级，取值为10。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY</span><br><span class="line"><span class="comment">//线程可以具有的最低优先级，取值为1。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY</span><br><span class="line"><span class="comment">//分配给线程的默认优先级，取值为5。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY</span><br></pre></td></tr></table></figure></p><p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p><p> 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。</p><p>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p><p>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p><p>2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><p>3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p><p>4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><p>5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><p>6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><p> 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。  </p><h1 id="六、常用函数说明"><a href="#六、常用函数说明" class="headerlink" title="六、常用函数说明"></a><a name="t5">六、常用函数说明</a></h1><p><strong>① sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）  </strong>  </p><p><strong>② join():指等待t线程终止。</strong>  </p><p><a name="t6">### 使用方式。</a></p><p>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> t = <span class="function"><span class="keyword">new</span> <span class="title">AThread</span>(); <span class="title">t</span>.<span class="title">start</span>(); <span class="title">t</span>.<span class="title">join</span>();</span></span><br></pre></td></tr></table></figure><p><a name="t7">### 为什么要用join()方法</a></p><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p>不加join。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@functon 多线程学习,join</span></span><br><span class="line"><span class="comment"> *@author 林炳文</span></span><br><span class="line"><span class="comment"> *@time 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">package com.multithread.<span class="keyword">join</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span>(<span class="params">String name</span>) </span>&#123;</span><br><span class="line">    super(name);</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" 线程运行开始!"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span>+name + <span class="string">"运行 : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" 线程运行结束!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+<span class="string">"主线程运行开始!"</span>);</span><br><span class="line">Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+ <span class="string">"主线程运行结束!"</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>main主线程运行开始!<br>main主线程运行结束!<br>B 线程运行开始!<br>子线程B运行 : 0<br>A 线程运行开始!<br>子线程A运行 : 0<br>子线程B运行 : 1<br>子线程A运行 : 1<br>子线程A运行 : 2<br>子线程A运行 : 3<br>子线程A运行 : 4<br>A 线程运行结束!<br>子线程B运行 : 2<br>子线程B运行 : 3<br>子线程B运行 : 4<br>B 线程运行结束!<br>发现主线程比子线程早结束  </p><p>加join<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+<span class="string">"主线程运行开始!"</span>);</span><br><span class="line">Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mTh1.<span class="keyword">join</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mTh2.<span class="keyword">join</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+ <span class="string">"主线程运行结束!"</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>main主线程运行开始!<br>A 线程运行开始!<br>子线程A运行 : 0<br>B 线程运行开始!<br>子线程B运行 : 0<br>子线程A运行 : 1<br>子线程B运行 : 1<br>子线程A运行 : 2<br>子线程B运行 : 2<br>子线程A运行 : 3<br>子线程B运行 : 3<br>子线程A运行 : 4<br>子线程B运行 : 4<br>A 线程运行结束!<br>主线程一定会等子线程都结束了才结束  </p><p><strong>③ yield():暂停当前正在执行的线程对象，并执行其他线程。</strong>  </p><p>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p><p><span style="color:red"><strong>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。</strong></span>因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p> <span style="color:red">结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习 yield</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.multithread.yield;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadYield</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">""</span> + <span class="keyword">this</span>.getName() + <span class="string">"-----"</span> + i);</span><br><span class="line">            <span class="comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）</span></span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ThreadYield yt1 = <span class="keyword">new</span> ThreadYield(<span class="string">"张三"</span>);</span><br><span class="line">    ThreadYield yt2 = <span class="keyword">new</span> ThreadYield(<span class="string">"李四"</span>);</span><br><span class="line">        yt1.start();</span><br><span class="line">        yt2.start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。</p><p>第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。  </p><p><strong>sleep()和yield()的区别</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>&nbsp;&nbsp;&nbsp;sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程<br>&nbsp;&nbsp;&nbsp;&nbsp;另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。  </p><p><strong>④setPriority(): 更改线程的优先级。</strong><br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MIN_PRIORITY</span> = <span class="number">1</span>  </span><br><span class="line"><span class="attr">NORM_PRIORITY</span> = <span class="number">5</span>  </span><br><span class="line"><span class="attr">MAX_PRIORITY</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>用法：  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread4 <span class="built_in">t1</span> = new Thread4(<span class="string">"t1"</span>)<span class="comment">;</span></span><br><span class="line">Thread4 <span class="built_in">t2</span> = new Thread4(<span class="string">"t2"</span>)<span class="comment">;</span></span><br><span class="line"><span class="built_in">t1</span>.setPriority(Thread.MAX_PRIORITY)<span class="comment">;</span></span><br><span class="line"><span class="built_in">t2</span>.setPriority(Thread.MIN_PRIORITY)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><span style="color:red"><strong>⑤interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！</strong></span></p><p>⑥wait()</p><p>Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对Object.wait()，Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题了吧，这是一道比较经典的面试题，题目要求如下：</p><p>&nbsp;&nbsp;&nbsp;建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait用法</span></span><br><span class="line"><span class="comment"> * @author DreamSea </span></span><br><span class="line"><span class="comment"> * @time 2015.3.9 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.multithread.wait;</span><br><span class="line"><span class="keyword">public</span> class MyThreadPrinter2 implements Runnable &#123;   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> prev;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> self;   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> MyThreadPrinter2(<span class="keyword">String</span> name, <span class="keyword">Object</span> prev, <span class="keyword">Object</span> self) &#123;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.prev = prev;   </span><br><span class="line">        <span class="keyword">this</span>.self = self;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;   </span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">10</span>;   </span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            <span class="keyword">synchronized</span> (prev) &#123;   </span><br><span class="line">                <span class="keyword">synchronized</span> (self) &#123;   </span><br><span class="line">                    System.out.<span class="built_in">print</span>(name);   </span><br><span class="line">                    count--;  </span><br><span class="line">                    </span><br><span class="line">                    self.notify();   </span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">try</span> &#123;   </span><br><span class="line">                    prev.wait();   </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;   </span><br><span class="line">        <span class="keyword">Object</span> a = <span class="keyword">new</span> <span class="keyword">Object</span>();   </span><br><span class="line">        <span class="keyword">Object</span> b = <span class="keyword">new</span> <span class="keyword">Object</span>();   </span><br><span class="line">        <span class="keyword">Object</span> c = <span class="keyword">new</span> <span class="keyword">Object</span>();   </span><br><span class="line">        MyThreadPrinter2 pa = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"A"</span>, c, a);   </span><br><span class="line">        MyThreadPrinter2 pb = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"B"</span>, a, b);   </span><br><span class="line">        MyThreadPrinter2 pc = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"C"</span>, b, c);   </span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">new</span> Thread(pa).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  <span class="comment">//确保按顺序A、B、C执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(pb).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        <span class="keyword">new</span> Thread(pc).start();   </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>ABCABCABCABCABCABCABCABCABCABC  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>wait和sleep区别  </strong><br><strong>共同点：</strong><br>1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。<br>2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。<br>   如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。<br>   需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。<br><strong>不同点：</strong><br>1. Thread类的方法：sleep(),yield()等<br>   Object的方法：wait()和notify()等<br>2. 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。<br>   <span style="color:red">sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。  </span><br>3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用<br><span style="color:red">所以sleep()和wait()方法的最大区别是：<br>　　　　sleep()睡眠时，保持对象锁，仍然占有该锁；<br>　　　　而wait()睡眠时，释放对象锁。<br>　　但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。  </span><br><strong>sleep（）方法</strong><br>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;<br>　　 sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。<br>　　在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。<br><strong>wait（）方法</strong><br>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；<br>　　wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。<br>　　wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。  </p><h1 id="七、常见线程名词解释"><a href="#七、常见线程名词解释" class="headerlink" title="七、常见线程名词解释"></a><a name="t8">七、常见线程名词解释<a name="t0"></a></a></h1><p>主线程：JVM调用程序main()所产生的线程。</p><p>当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。</p><p>后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。<strong>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</strong></p><p>前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</p><p><strong>线程类的一些常用方法：   </strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sleep</span><span class="params">()</span></span>: 强迫一个线程睡眠Ｎ毫秒。 </span><br><span class="line"><span class="function"><span class="title">isAlive</span><span class="params">()</span></span>: 判断一个线程是否存活。 </span><br><span class="line"><span class="function"><span class="title">join</span><span class="params">()</span></span>: 等待线程终止。 </span><br><span class="line"><span class="function"><span class="title">activeCount</span><span class="params">()</span></span>: 程序中活跃的线程数。 </span><br><span class="line"><span class="function"><span class="title">enumerate</span><span class="params">()</span></span>: 枚举程序中的线程。 </span><br><span class="line"><span class="function"><span class="title">currentThread</span><span class="params">()</span></span>: 得到当前线程。 </span><br><span class="line"><span class="function"><span class="title">isDaemon</span><span class="params">()</span></span>: 一个线程是否为守护线程。 </span><br><span class="line"><span class="function"><span class="title">setDaemon</span><span class="params">()</span></span>: 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) </span><br><span class="line"><span class="function"><span class="title">setName</span><span class="params">()</span></span>: 为线程设置一个名称。 </span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">()</span></span>: 强迫一个线程等待。 </span><br><span class="line"><span class="function"><span class="title">notify</span><span class="params">()</span></span>: 通知一个线程继续运行。 </span><br><span class="line"><span class="function"><span class="title">setPriority</span><span class="params">()</span></span>: 设置一个线程的优先级。</span><br></pre></td></tr></table></figure><h1 id="八、线程同步"><a href="#八、线程同步" class="headerlink" title="八、线程同步"></a><a name="t9">八、线程同步</a></h1><p><span style="color:#0000ff;">1、synchronized关键字的作用域有二种：  </span><br><span style="color:#0000ff;">1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；  </span><br><span style="color:#0000ff;">2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。  </span></p><p><span style="color:#0000ff;">2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象；  </span></p><p><span style="color:#0000ff;">3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；  </span></p><p>Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对synchronized关键字的作用进行深入了解才可定论。</p><p>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</p><p>在进一步阐述之前，我们需要明确几点：</p><p>A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</p><p>B．每个对象只有一个锁（lock）与之相关联。</p><p>C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p><p>接着来讨论synchronized用到不同地方对代码产生的影响：</p><p>假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。</p><p>1．  把synchronized当作函数修饰符时，示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//….</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。</p><p>上边的示例代码等同于如下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;      <span class="comment">//  (1)</span></span><br><span class="line">    <span class="comment">//…..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> (1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱：（</p><p>2．同步块，示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">(SomeObject so)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(so) &#123;</span><br><span class="line">    <span class="comment">//…..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量</span></span><br><span class="line">  <span class="function">Public <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123; </span><br><span class="line">      <span class="comment">//… &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//…..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p><p>3．将synchronized作用于static 函数，示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Foo &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span> </span>&#123;  <span class="comment">// 同步的static 函数</span></span><br><span class="line">    <span class="comment">//….</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">methodBBB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Foo.class)   <span class="comment">//  class literal(类名称字面常量)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。</p><p>记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。</p><p>可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。</p><p><strong>总结一下：</strong></p><p>1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。<br>2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法<br>3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。<br>4、对于同步，要时刻清醒在哪个对象上同步，这是关键。<br>5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。<br>6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。<br>7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。  </p><h1 id="九、线程数据传递"><a href="#九、线程数据传递" class="headerlink" title="九、线程数据传递"></a><a name="t10">九、线程数据传递</a></h1><p>在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和return语句来返回数据。  </p><p>9.1、通过构造方法传递数据<br>在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用(其实就是在run方法中使用)。下面的代码演示了如何通过构造方法来传递数据：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">package</span> mythread; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span>  </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(String name)</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"hello "</span> + name); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread1(<span class="string">"world"</span>); </span><br><span class="line">    thread.start(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 </p><p>9.2、通过变量和方法传递数据<br>向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对MyThread1类的改版，使用了一个setName方法来设置 name变量：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">package</span> mythread; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">this</span>.name = name; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">System.out.println(<span class="string">"hello "</span> + name); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">MyThread2 myThread = <span class="keyword">new</span> MyThread2(); </span><br><span class="line">myThread.setName(<span class="string">"world"</span>); </span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread); </span><br><span class="line">thread.start(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.3、通过回调函数传递数据 </p><p>上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个 value是无法事先就传入线程类的。   </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">package mythread; </span><br><span class="line"><span class="keyword">class</span> <span class="title">Data</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Work</span> &#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">Data data, Integer numbers</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : numbers) &#123; </span><br><span class="line">      data.<span class="keyword">value</span> += n; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyThread3</span> <span class="title">extends</span> <span class="title">Thread</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> Work work; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread3</span>(<span class="params">Work work</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.work = work; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    java.util.Random random = <span class="keyword">new</span> java.util.Random(); </span><br><span class="line">    Data data = <span class="keyword">new</span> Data(); </span><br><span class="line">    <span class="keyword">int</span> n1 = random.nextInt(<span class="number">1000</span>); </span><br><span class="line">    <span class="keyword">int</span> n2 = random.nextInt(<span class="number">2000</span>); </span><br><span class="line">    <span class="keyword">int</span> n3 = random.nextInt(<span class="number">3000</span>); </span><br><span class="line">    work.process(data, n1, n2, n3); <span class="comment">// 使用回调函数 </span></span><br><span class="line">    System.<span class="keyword">out</span>.println(String.valueOf(n1) + <span class="string">"+"</span> + String.valueOf(n2) + <span class="string">"+"</span> </span><br><span class="line">    + String.valueOf(n3) + <span class="string">"="</span> + data.<span class="keyword">value</span>); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread3(<span class="keyword">new</span> Work()); </span><br><span class="line">    thread.start(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;好了，Java多线程的基础知识就讲到这里了，有兴趣研究多线程的推荐直接看java的源码，你将会得到很大的提升！</p><p><a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a>  </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript工作原理：V8引擎和5招优化</title>
      <link href="/2018/08/23/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9AV8%E5%BC%95%E6%93%8E%E5%92%8C5%E6%8B%9B%E4%BC%98%E5%8C%96/"/>
      <url>/2018/08/23/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9AV8%E5%BC%95%E6%93%8E%E5%92%8C5%E6%8B%9B%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript引擎是执行JavaScript代码的程序或解释器。JavaScript引擎可以作为标准解释器或即时编译器来实现，该编译器以某种形式将JavaScript编译为字节码。</p><a id="more"></a><p>流行的JavaScript引擎：</p><ul><li>V8：开源，Google开发，C++，Chrome浏览器 Rhino：开源，Mozilla开发，Java</li><li>SpiderMonkey：第一个JavaScript引擎，网景浏览器（之前）和Firefox（现在）</li><li>JavaScriptCore：开源，苹果Safari浏览器 - Chakra（JSscript9）：Internet Explorer浏览器</li><li>Chakra（JavaScript）：Microsoft Edge浏览器</li></ul><h3 id="V8起源"><a href="#V8起源" class="headerlink" title="V8起源"></a>V8起源</h3><p>V8引擎是由Google构建的，以C++开发并且开源，与其它的引擎不同的是，V8还是Node.js的运行时环境。</p><p><img src="https://image-static.segmentfault.com/118/401/1184019299-599fa1648acc6_articlex" alt="v8_why" title="v8_why"></p><p>V8最初设计用于提高浏览器内部JavaScript执行的性能。为了获得速度，V8将JavaScript代码转换为更高效的机器代码，而不是使用解释器。它通过实现JIT（Just-In-Time）编译器（如SpiderMonkey或Rhino（Mozilla）等许多现代JavaScript引擎）将JavaScript代码编译为机器代码。 这里的主要区别在于V8不生成字节码或任何中间代码。</p><h3 id="V8曾经的两个编译器"><a href="#V8曾经的两个编译器" class="headerlink" title="V8曾经的两个编译器"></a>V8曾经的两个编译器</h3><p>在V8引擎的v5.9版本出来之前，V8有两个编译器：<br>full-codegen：一个简单而且速度非常快的编译器，可以生成简单且相对较慢的机器代码。<br>Crankshaft：一种更复杂（Just-In-Time）的优化编译器，可以生成高度优化的代码。</p><p>V8引擎还在内部使用多个线程：</p><ul><li>主线程完成预定的任务：获取你的代码，编译它然后执行它</li><li>一个单独的线程用于编译，当这个单独的线程优化代码时，主线程可以继续执行</li><li>一个Profiler线程，它会告诉运行时我们花了很多时间，使得Crankshaft能够优化它们</li><li>一些线程处理垃圾处理器扫描</li></ul><p>当第一次执行JavaScript代码时，V8利用full-codegen，直接将解析的JavaScript翻译成机器代码而无需任何转换。这使它可以非常快速地开始执行机器代码。请注意，V8不使用中间字节码表示法，不需要解释器。</p><p>当您的代码运行一段时间后，Profiler线程已经收集了足够的数据以确定哪种方法应该进行优化。</p><p>接下来，Crankshaft优化从另一个线程开始。它将JavaScript抽象语法树翻译为称为Hydrogen的高级静态单分配（SSA）表示，并尝试优化该hydrogen图。 大多数优化都是在这个级别完成的。</p><h3 id="优化：内联"><a href="#优化：内联" class="headerlink" title="优化：内联"></a>优化：内联</h3><p>第一次优化是提前尽可能多地嵌入代码。 内联是将被调用函数的主体替换为调用网站（调用该函数的代码行）的过程。 这个简单的步骤可以让以下优化变得更有意义。</p><p><img src="https://image-static.segmentfault.com/912/896/912896149-5ae2d38d99b77_articlex" alt="v8_inling" title="v8_inling"></p><h3 id="优化：隐藏的类"><a href="#优化：隐藏的类" class="headerlink" title="优化：隐藏的类"></a>优化：隐藏的类</h3><p>JavaScript是一种基于原型的语言：没有类，对象的创建是通过克隆实现的。JavaScript也是一种动态编程语言，它意味着属性可以在实例化后轻松添加或从对象中移除。</p><p>大多数JavaScript解释器使用字典式结构（基于哈希函数）来存储对象属性值在内存中的位置。这种结构使得检索JavaScript中的属性的值比在Java或C＃等非动态编程语言中的计算更昂贵。在Java中，所有对象属性都是在编译之前由固定的对象布局确定的，并且不能在运行时动态添加或删除（当然，C＃的动态类型是另一个主题）。因此，属性的值（或指向这些属性的指针）可以作为连续缓冲区存储在内存中，每个值之间都有一个固定偏移量。偏移量的长度可以根据属性类型轻松确定，但在运行时可以更改属性类型的JavaScript中不可行。</p><p>由于使用字典查找内存中对象属性的位置效率非常低，因此V8使用不同的方法：隐藏类。隐藏类的工作方式与Java等语言中使用的固定对象布局（类）类似，除了它们是在运行时创建的。现在，让我们看看他们实际的样子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>当“new Point(1, 2)”被执行时， V8引擎会创建一个名为C0的隐藏类。</p><p><img src="https://image-static.segmentfault.com/338/869/3388694770-5ae29b3121882_articlex" alt="v8_hidden_class_c0" title="v8_hidden_class_c0"></p><p>由于Point还未定义任何属性，因此“C0”为空。</p><p>一旦执行了第一条语句“this.x = x”（在“Point”函数内部），V8将创建第二个隐藏类“C1”，它基于“C0”。“C1”描述了可以找到属性x的存储器中的位置（相对于对象指针）。在这种情况下，“x”存储在偏移量0处，这意味着在内存中将点对象视为连续缓冲区时，第一个偏移量将对应于属性“x”。 V8还将用“类别转换”更新“C0”，该类别转换指出如果将属性“x”添加到点对象，隐藏类应从“C0”切换到“C1”。 下面的点对象的隐藏类现在是“C1”。</p><p><img src="https://image-static.segmentfault.com/247/471/2474713203-5ae29c6d63386_articlex" alt="v8_hidden-class_c1" title="v8_hidden-class_c1"></p><p>每次将新属性添加到对象时，旧的隐藏类都会使用到新隐藏类的转换路径进行更新。隐藏类转换非常重要，因为它们允许隐藏类在以相同方式创建的对象之间共享。如果两个对象共享一个隐藏类并向它们添加了相同的属性，则转换将确保两个对象都接收到相同的新隐藏类以及随附的所有优化代码。</p><p>当执行语句“this.y = y”（同样，在“this.x = x”语句之后的Point函数内部）时，将重复此过程。</p><p>创建一个名为“C2”的新隐藏类，将类转换添加到“C1”，指出如果将属性“y”添加到Point对象（已包含属性“x”），则隐藏类应更改为 “C2”，点对象的隐藏类更新为“C2”。</p><p><img src="https://image-static.segmentfault.com/400/635/4006356827-5ae2c8a2f300d_articlex" alt="v8_hidden-class_c2" title="v8_hidden-class_c2"></p><p>隐藏类转换取决于将属性添加到对象的顺序。 看看下面的代码片段：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span></span>(x, y) &#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p>现在，您可能认为对于p1和p2，将使用相同的隐藏类和转换。事实上却不是。对于“p1”，首先添加属性“a”，然后添加属性“b”。然而，对于“p2”，首先分配“b”，然后是“a”。 因此，由于不同的转换路径，“p1”和“p2”以不同的隐藏类结束。在这种情况下，以相同顺序初始化动态属性好得多，以便隐藏的类可以重用。</p><p><strong>内联缓存</strong><br>V8利用另一种技术来优化称为内联缓存的动态类型化语言。内联缓存依赖于观察到对相同方法的重复调用倾向于发生在相同类型的对象上。在这里可以找到关于内联缓存的深入解释。</p><p>我们将讨论内联缓存的一般概念（如果您没有时间通过​​上面的深入解释）。</p><p>那么它是怎样工作的？ V8维护一个对象类型的缓存，这些对象在最近的方法调用中作为参数传递，并使用这些信息来预测将来作为参数传递的对象的类型。如果V8能够对传递给方法的对象的类型做出很好的假设，那么它可以绕过确定如何访问对象属性的过程，而是使用以前查找存储的信息到对象的隐藏课程。</p><p>那么隐藏类和内联缓存的概念如何相关？无论何时在特定对象上调用方法，V8引擎都必须执行对该对象的隐藏类的查找，以确定访问特定属性的偏移量。在相同隐藏类的两次成功调用之后，V8省略了隐藏类查找，并简单地将该属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8引擎都假定隐藏的类没有更改，并使用从以前的查找存储的偏移量直接跳转到特定属性的内存地址。这大大提高了执行速度。</p><p>内联缓存也是为什么相同类型的对象共享隐藏类非常重要的原因。如果您创建两个具有相同类型和不同隐藏类的对象（就像我们之前的示例中那样），V8将无法使用内联缓存，因为即使这两个对象的类型相同，它们对应的隐藏类为其属性分配不同的偏移量。</p><p><img src="https://image-static.segmentfault.com/307/815/3078150790-5ae2caae22fb4_articlex" alt="v8_inline_cacahing" title="v8_inline_cacahing"></p><h3 id="编译为机器码"><a href="#编译为机器码" class="headerlink" title="编译为机器码"></a>编译为机器码</h3><p>一旦Hydrogen图被优化，Crankshaft将其降低到称为Lithium的较低级表示。大部分的Lithium实施都是特定于架构的。寄存器分配发生在这个级别。</p><p>最终，Lithium被编译成机器码。然后发生其他事情，称为OSR：堆栈替换。在我们开始编译和优化那些耗时较长的方法之前，我们可能会运行它。V8不会忘记它刚刚缓慢执行的内容，以再次优化版本开始。相反，它会转换我们拥有的所有上下文（堆栈，寄存器），以便我们可以在执行过程中切换到优化版本。这是一项非常复杂的任务，考虑到除了其他优化之外，V8最初还是将代码内联。 V8不是唯一能够做到的引擎。</p><p>有一种叫做去最佳化的保护措施可以做出相反的转变，并在引擎的假设不再成立的情况下恢复到非优化的代码。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>对于垃圾收集，V8采用了传统的标记清除方式来清理老一代。标记阶段应该停止JavaScript执行。为了控制GC成本并使执行更加稳定，V8使用增量标记：不是遍历整个堆，而是试图标记每个可能的对象，它只走过堆的一部分，然后恢复正常执行。下一个GC停止将从先前堆走过的地方继续。这允许在正常执行期间非常短的暂停。如前所述，扫描阶段由单独的线程处理。</p><h3 id="Ignition和TurboFan"><a href="#Ignition和TurboFan" class="headerlink" title="Ignition和TurboFan"></a>Ignition和TurboFan</h3><p>随着2017年早些时候发布V8 5.9，引入了新的执行流程。这个新的管道在实际的JavaScript应用程序中实现了更大的性能改进和显着的内存节省。</p><p>新的执行流程建立在Ignition，V8的解释器和TurboFan，V8的最新优化编译器之上。</p><p>您可以查看V8团队关于此主题的博客文章。</p><p>自从V8.5版本问世以来，V8团队一直在努力跟上新的JavaScript语言特性，而V8团队已经不再使用V8版本的全代码和Crankshaft（自2010年以来服务于V8的技术）。这些功能需要进行优化。</p><p>这意味着整体V8将有更简单和更可维护的架构。</p><p><img src="https://image-static.segmentfault.com/295/050/2950506090-5ae2d1c0cf39e_articlex" alt="v8_benchmarks" title="v8_benchmarks"></p><p>这些改进仅仅是一个开始。 新的Ignition和TurboFan管道为进一步优化铺平了道路，这将在未来几年提升JavaScript性能并缩小V8在Chrome和Node.js中的占用空间。</p><p>最后，这里有一些关于如何编写优化的，更好的JavaScript的技巧和窍门。 您可以轻松地从上述内容中获取这些内容，但是，为了方便起见，以下是摘要：</p><h3 id="如何编写优化的JavaScript"><a href="#如何编写优化的JavaScript" class="headerlink" title="如何编写优化的JavaScript"></a>如何编写优化的JavaScript</h3><ul><li>对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。</li><li>动态属性：在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。</li><li>方法：重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。</li><li>数组：避免稀疏数组，其中的键不是增量数字。稀疏数组中没有每个元素都是哈希表。这种阵列中的元素访问费用较高。另外，尽量避免预分配大型数组。随着你的成长，成长会更好。最后，不要删除数组中的元素。它使密钥稀疏。</li><li>标记值：V8用32位来表示对象和数字。由于它的31位，它使用1个bit来知道它是一个对象（flag = 1）还是一个称为SMI（SMall Integer）的整数（flag = 0）。然后，如果数字值大于31位，V8会将该数字框起来，将其变成双精度值并创建一个新对象以将该数字放入其中。尝试尽可能使用31位有符号数字以避免将昂贵的装箱操作转换为JS对象。</li></ul><p><strong>此文摘自<a href="https://segmentfault.com/a/1190000014593649" target="_blank" rel="noopener">《JavaScript工作原理（二）：V8引擎和5招优化》</a></strong></p><p><strong>作者：<a href="https://segmentfault.com/u/xupea" target="_blank" rel="noopener">xupea</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL执行效率总结</title>
      <link href="/2018/08/22/SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/22/SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><span></span><br><a id="more"></a></p><p>1.关于SQL查询效率，100w数据，查询只要1秒，与您分享:</p><p>机器情况 p4: 2.4 内存: 1 G os: windows 2003 数据库: ms sql server 2000 目的: 查询性能测试,比较两种查询的性能</p><p>SQL查询效率 step by step</p><p>-- setp 1. – 建表 <code>create table t_userinfo ( userid int identity(1,1) primary key nonclustered, nick varchar(50) not null default &#39;&#39;, classid int not null default 0, writetime datetime not null default getdate() ) go</code></p><p>-- 建索引 <code>create clustered index ix_userinfo_classid on t_userinfo(classid) go</code></p><p>-- step 2.<br><code>declare @i int declare @k int declare @nick varchar(10) set @i = 1 while @i&lt;1000000 begin set @k = @i % 10 set @nick = convert(varchar,@i) insert into t_userinfo(nick,classid,writetime) values(@nick,@k,getdate()) set @i = @i + 1 end</code> </p><p>-- 耗时 08:27 ，需要耐心等待</p><p>-- step 3. <code>select top 20 userid,nick,classid,writetime from t_userinfo where userid not in ( select top 900000 userid from t_userinfoorder by userid asc )</code></p><p>-- 耗时 8 秒 ,够长的</p><p>-- step 4. <code>select a.userid,b.nick,b.classid,b.writetime from ( select top 20 a.userid from ( select top 900020 userid from t_userinfo order by userid asc ) a order by a.userid desc ) a inner join t_userinfo b on a.userid = b.userid order by a.userid asc</code></p><p>-- 耗时 1 秒，太快了吧，不可以思议</p><p>-- step 5 where 查询 <code>select top 20 userid,nick,classid,writetime from t_userinfo where classid = 1 and userid not in ( select top 90000 userid from t_userinfo where classid = 1 order by userid asc )</code> – 耗时 2 秒</p><p>-- step 6 where 查询 <code>select a.userid,b.nick,b.classid,b.writetime from ( select top 20 a.userid from ( select top 90000 userid from t_userinfo where classid = 1 order by userid asc ) a order by a.userid desc ) a inner join t_userinfo b on a.userid = b.userid order by a.userid asc</code></p><p>-- 查询分析器显示不到 1 秒.</p><p>查询效率分析： 子查询为确保消除重复值，必须为外部查询的每个结果都处理嵌套查询。在这种情况下可以考虑用联接查询来取代。 如果要用子查询，那就用EXISTS替代IN、用NOT EXISTS替代NOT IN。因为EXISTS引入的子查询只是测试是否存在符合子查询中指定条件的行，效率较高。无论在哪种情况下,NOT IN都是最低效的。因为它对子查询中的表执行了一个全表遍历。</p><p>建立合理的索引,避免扫描多余数据，避免表扫描！ 几百万条数据，照样几十毫秒完成查询,对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： <code>select id from t where num is null</code> 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： <code>select id from t where num=0</code></p><p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： <code>select id from t where num=10 or num=20</code> 可以这样查询： <code>select id from t where num=10 union all select id from t where num=20</code></p><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如： <code>select id from t where num in(1,2,3)</code> 对于连续的数值，能用 between 就不要用 in 了： <code>select id from t where num between 1 and 3</code></p><p>6.下面的查询也将导致全表扫描： <code>select id from t where name like &#39;%c%&#39;</code> 若要提高效率，可以考虑全文检索。</p><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： <code>select id from t where[num=@num](mailto:num=@num)</code> 可以改为强制查询使用索引： <code>select id from t with(index(索引名)) where[num=@num](mailto:num=@num)</code></p><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： <code>select id from t where num/2=100</code> 应改为: <code>select id from t where num=100*2</code></p><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： <code>select id from t where substring(name,1,3)=&#39;abc&#39;--name以abc开头的id select id from t where datediff(day,createdate,&#39;2005-11-30&#39;)=0--‘2005-11-30’</code>生成的id 应改为: <code>select id from t where name like &#39;abc%&#39; select id from t where createdate&gt;=&#39;2005-11-30&#39; and createdate&lt;&#39;2005-12-1&#39;</code></p><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12.不要写一些没有意义的查询，如需要生成一个空表结构： <code>select col1,col2 into #t from t where 1=0</code> 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<code>create table #t(...)</code></p><p>13.很多时候用 exists 代替 in 是一个好的选择： <code>select num from a where num in(select num from b)</code> 用下面的语句替换： <code>select num from a where exists(select 1 from b where num=a.num)</code></p><p>14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p><p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19.任何地方都不要使用 <code>select * from t</code> ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>29.尽量避免大事务操作，提高系统并发能力。</p><p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理</p><div class="note info no-icon"><p>1、避免将字段设为“允许为空”<br>2、数据表设计要规范<br>3、深入分析数据操作所要对数据库进行的操作<br>4、尽量不要使用临时表<br>5、多多使用事务<br>6、尽量不要使用游标<br>7、避免死锁<br>8、要注意读写锁的使用<br>9、不要打开大的数据集<br>10、不要使用服务器端游标<br>11、在程序编码时使用大数据量的数据库<br>12、不要给“性别”列创建索引<br>13、注意超时问题<br>14、不要使用Select *<br>15、在细节表中插入纪录时，不要在主表执行Select MAX(ID)<br>16、尽量不要使用TEXT数据类型<br>17、使用参数查询<br>18、不要使用Insert导入大批的数据<br>19、学会分析查询<br>20、使用参照完整性<br>21、用INNER JOIN 和LEFT JOIN代替Where </p></div><h3 id="提高SQL查询效率（要点与技巧）："><a href="#提高SQL查询效率（要点与技巧）：" class="headerlink" title="提高SQL查询效率（要点与技巧）："></a>提高SQL查询效率（要点与技巧）：</h3><h4 id="技巧一"><a href="#技巧一" class="headerlink" title="技巧一"></a>技巧一</h4><p>问题类型：ACCESS数据库字段中含有日文片假名或其它不明字符时查询会提示内存溢出。 解决方法：修改查询语句 <code>sql=&quot;select * from tablename where column like &#39;%&quot;&amp;word&amp;&quot;%&#39;&quot; 改为 sql=&quot;select * from tablename&quot; rs.filter = &quot; column like &#39;%&quot;&amp;word&amp;&quot;%&#39;&quot;</code> </p><h4 id="技巧二"><a href="#技巧二" class="headerlink" title="技巧二"></a>技巧二</h4><p>问题类型：如何用简易的办法实现类似百度的多关键词查询（多关键词用空格或其它符号间隔）。 解决方法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//用空格分割查询字符串 </span><br><span class="line">ck=split(word," ")</span><br><span class="line">//得到分割后的数量 </span><br><span class="line">sck=UBound(ck) </span><br><span class="line">sql="<span class="keyword">select</span> * tablename <span class="keyword">where</span><span class="string">" 在一个字段中查询 For i = 0 To sck SQL = SQL &amp; tempJoinWord &amp; "</span>(<span class="string">" &amp; _ "</span><span class="keyword">column</span> <span class="keyword">like</span> <span class="string">'"&amp;ck(i)&amp;"%'</span>)<span class="string">" tempJoinWord = "</span> <span class="keyword">and</span> <span class="string">" Next 在二个字段中同时查询 For i = 0 To sck SQL = SQL &amp; tempJoinWord &amp; "</span>(<span class="string">" &amp; _ "</span><span class="keyword">column</span> <span class="keyword">like</span> <span class="string">'"&amp;ck(i)&amp;"%'</span> <span class="keyword">or</span> <span class="string">" &amp; _ "</span>column1 <span class="keyword">like</span> <span class="string">'"&amp;ck(i)&amp;"%'</span>)<span class="string">" tempJoinWord = "</span> <span class="keyword">and</span> <span class="string">" Next</span></span><br></pre></td></tr></table></figure></p><h4 id="技巧三"><a href="#技巧三" class="headerlink" title="技巧三"></a>技巧三</h4><p>大大提高查询效率的几种技巧</p><ol><li>尽量不要使用 or，使用or会引起全表扫描，将大大降低查询效率。  </li><li>经过实践验证，charindex()并不比前面加%的like更能提高查询效率，并且charindex()会使索引失去作用（指sqlserver数据库）  </li><li>column like ‘%”&amp;word&amp;”%’ 会使索引不起作用<br>column like ‘“&amp;word&amp;”%’ 会使索引起作用（去掉前面的%符号）<br>（指sqlserver数据库）  </li><li>‘%”&amp;word&amp;”%’ 与’”&amp;word&amp;”%’ 在查询时的区别：<br>比如你的字段内容为 一个容易受伤的女人<br>‘%”&amp;word&amp;”%’ ：会通配所有字符串，不论查“受伤”还是查“一个”，都会显示结果。<br>‘“&amp;word&amp;”%’ ：只通配前面的字符串，例如查“受伤”是没有结果的，只有查“一个”，才会显示结果。  </li><li>字段提取要按照“需多少、提多少”的原则，避免“select *”，尽量使用“select 字段1,字段2,字段3……..”。实践证明：每少提取一个字段，数据的提取速度就会有相应的提升。提升的速度还要看您舍弃的字段的大小来判断。  </li><li>order by按聚集索引列排序效率最高。一个sqlserver数据表只能建立一个聚集索引，一般默认为ID，也可以改为其它的字段。  </li><li>为你的表建立适当的索引，建立索引可以使你的查询速度提高几十几百倍。（指sqlserver数据库）  </li></ol><h3 id="以下是建立索引与不建立索引的一个查询效率分析："><a href="#以下是建立索引与不建立索引的一个查询效率分析：" class="headerlink" title="以下是建立索引与不建立索引的一个查询效率分析："></a>以下是建立索引与不建立索引的一个查询效率分析：</h3><p>Sqlserver索引与查询效率分析。<br>表 News<br>字段<br>Id：自动编号<br>Title：文章标题<br>Author：作者<br>Content：内容<br>Star：优先级<br>Addtime：时间<br>记录：100万条<br>测试机器：P4 2.8/1G内存/IDE硬盘  </p><h4 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h4><p>主键Id，默认为聚集索引，不建立其它非聚集索引<br><code>select * from News where Title like &#39;%&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;%&quot;&amp;word&amp;&quot;%&#39; order by Id desc</code><br>从字段Title和Author中模糊检索，按Id排序<br>查询时间：50秒  </p><h4 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39; order by Id desc</code><br>从字段Title和Author中模糊检索，按Id排序<br>查询时间：2 - 2.5秒 </p><h4 id="方案3："><a href="#方案3：" class="headerlink" title="方案3："></a>方案3：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39; order by Star desc</code><br>从字段Title和Author中模糊检索，按Star排序<br>查询时间：2 秒  </p><h4 id="方案4："><a href="#方案4：" class="headerlink" title="方案4："></a>方案4：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39;</code><br>从字段Title和Author中模糊检索，不排序<br>查询时间：1.8 - 2 秒  </p><h4 id="方案5："><a href="#方案5：" class="headerlink" title="方案5："></a>方案5：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39;</code><br>或<br><code>select * from News where Author like &#39;&quot;&amp;word&amp;&quot;%&#39;</code><br>从字段Title 或 Author中检索，不排序<br>查询时间：1秒  </p><h3 id="如何提高SQL语言的查询效率"><a href="#如何提高SQL语言的查询效率" class="headerlink" title="如何提高SQL语言的查询效率?"></a>如何提高SQL语言的查询效率?</h3><p>问：请问我如何才能提高SQL语言的查询效率呢？<br>答：这得从头说起：<br>由于SQL是面向结果而不是面向过程的查询语言，所以一般支持SQL语言的大型关系型数据库都使用一个基于查询成本的优化器，为即时查询提供一个最佳的执行策略。对于优化器，输入是一条查询语句，输出是一个执行策略。<br>一条SQL查询语句可以有多种执行策略，优化器将估计出全部执行方法中所需时间最少的所谓成本最低的那一种方法。所有优化都是基于用记所使用的查询语句中的where子句，优化器对where子句中的优化主要用搜索参数(Serach Argument)。<br>搜索参数的核心思想就是数据库使用表中字段的索引来查询数据，而不必直接查询记录中的数据。<br>带有 =、&lt;、&lt;=、&gt;、&gt;= 等操作符的条件语句可以直接使用索引，如下列是搜索参数：<br>emp_id = “10001” 或 salary &gt; 3000 或 a =1 and c = 7<br>而下列则不是搜索参数：<br>salary = emp_salary 或 dep_id != 10 或 salary * 12 &gt;= 3000 或 a=1 or c=7<br>应当尽可能提供一些冗余的搜索参数，使优化器有更多的选择余地。请看以下3种方法：  </p><h4 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select employee.emp_name,department.dep_name <span class="keyword">from</span> department,employee </span><br><span class="line">where (employee.dep_id = department.dep_id) </span><br><span class="line"><span class="keyword">and</span> (department.<span class="attribute">dep_code</span>=<span class="string">"01"</span>) </span><br><span class="line"><span class="keyword">and</span> (employee.<span class="attribute">dep_code</span>=<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure><p>它的搜索分析结果如下：<br>Estimate 2 I/O operations<br>Scan department using primary key<br>for rows where dep_code equals “01”<br>Estimate getting here 1 times<br>Scan employee sequentially<br>Estimate getting here 5 times  </p><h4 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select employee.emp_name,department.dep_name <span class="keyword">from</span> department,employee</span><br><span class="line">where (employee.<span class="attribute">dep_id</span>=department.dep_id) </span><br><span class="line"><span class="keyword">and</span> (department.<span class="attribute">dep_code</span>=<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure><p>它的搜索分析结果如下：<br>Estimate 2 I/O operations<br>Scan department using primary key<br>for rows where dep_code equals “01”<br>Estimate getting here 1 times<br>Scan employee sequentially<br>Estimate getting here 5 times  </p><p>第一种方法与第二种运行效率相同，但第一种方法最好，因为它为优化器提供了更多的选择机会。</p><h4 id="第三种方法："><a href="#第三种方法：" class="headerlink" title="第三种方法："></a>第三种方法：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee.emp_name,department.dep_name <span class="keyword">from</span> department,employee </span><br><span class="line"><span class="keyword">where</span> (employee.dep_id = department.dep_id) </span><br><span class="line"><span class="keyword">and</span> (employee.dep_code=<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure><p>这种方法最不好，因为它无法使用索引，也就是无法优化……</p><p>使用SQL语句时应注意以下几点：<br>1、避免使用不兼容的数据类型。例如，Float和Integer，Char和Varchar，Binary和Long Binary不兼容的。数据类型的不兼容可能使优化器无法执行一些本可以进行的优化操作。例如：<br>select emp_name form employee where salary &gt; 3000;<br>在此语句中若salary是Float类型的，则优化器很难对其进行优化，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。<br>2、尽量不要使用表达式，因它在编绎时是无法得到的，所以SQL只能使用其平均密度来估计将要命中的记录数。<br>3、避免对搜索参数使用其他的数学操作符。如：<br><code>select emp_name from employee where salary * 12 &gt; 3000;`</code><br>应改为：<br><code>select emp_name from employee where salary &gt; 250;</code></p><p>4、避免使用 != 或 &lt;&gt; 等这样的操作符，因为它会使系统无法使用索引，而只能直接搜索表中的数据。  </p><h3 id="ORACAL中的应用"><a href="#ORACAL中的应用" class="headerlink" title="ORACAL中的应用"></a>ORACAL中的应用</h3><p>一个1600万数据表－－短信上行表TBL_SMS_MO<br>结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TBL_SMS_MO  </span><br><span class="line">(  </span><br><span class="line">SMS_ID <span class="built_in">NUMBER</span>,  </span><br><span class="line">MO_ID VARCHAR2(<span class="number">50</span>),  </span><br><span class="line">MOBILE VARCHAR2(<span class="number">11</span>),  </span><br><span class="line">SPNUMBER VARCHAR2(<span class="number">20</span>),  </span><br><span class="line">MESSAGE VARCHAR2(<span class="number">150</span>),  </span><br><span class="line">TRADE_CODE VARCHAR2(<span class="number">20</span>),  </span><br><span class="line">LINK_ID VARCHAR2(<span class="number">50</span>),  </span><br><span class="line">GATEWAY_ID <span class="built_in">NUMBER</span>,  </span><br><span class="line">GATEWAY_PORT <span class="built_in">NUMBER</span>,  </span><br><span class="line">MO_TIME <span class="built_in">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">SYSDATE</span>  </span><br><span class="line">);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_MO_DATE <span class="keyword">ON</span> TBL_SMS_MO (MO_TIME)  </span><br><span class="line">PCTFREE <span class="number">10</span>  </span><br><span class="line"><span class="keyword">INITRANS</span> <span class="number">2</span>  </span><br><span class="line"><span class="keyword">MAXTRANS</span> <span class="number">255</span>  </span><br><span class="line"><span class="keyword">STORAGE</span>  </span><br><span class="line">(  </span><br><span class="line"><span class="keyword">INITIAL</span> <span class="number">1</span>M  </span><br><span class="line"><span class="keyword">NEXT</span> <span class="number">1</span>M  </span><br><span class="line"><span class="keyword">MINEXTENTS</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span>  </span><br><span class="line"><span class="keyword">PCTINCREASE</span> <span class="number">0</span>  </span><br><span class="line">);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_MO_MOBILE <span class="keyword">ON</span> TBL_SMS_MO (MOBILE)  </span><br><span class="line">PCTFREE <span class="number">10</span>  </span><br><span class="line"><span class="keyword">INITRANS</span> <span class="number">2</span>  </span><br><span class="line"><span class="keyword">MAXTRANS</span> <span class="number">255</span>  </span><br><span class="line"><span class="keyword">STORAGE</span>  </span><br><span class="line">(  </span><br><span class="line"><span class="keyword">INITIAL</span> <span class="number">64</span>K  </span><br><span class="line"><span class="keyword">NEXT</span> <span class="number">1</span>M  </span><br><span class="line"><span class="keyword">MINEXTENTS</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span>  </span><br><span class="line"><span class="keyword">PCTINCREASE</span> <span class="number">0</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>　　问题：从表中查询某时间段内某手机发送的短消息，如下SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOBILE,MESSAGE,TRADE_CODE,MO_TIME  </span><br><span class="line"><span class="keyword">FROM</span> TBL_SMS_MO  </span><br><span class="line"><span class="keyword">WHERE</span> MOBILE=<span class="string">'130XXXXXXXX'</span>  </span><br><span class="line"><span class="keyword">AND</span> MO_TIME <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-01'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>) <span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-07'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>)  </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> MO_TIME <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></p><p>返回结果大约需要10分钟，应用于网页查询，简直难以忍受。<br>分析：<br>在PL/SQL Developer，点击“Explain Plan”按钮（或F5键），对SQL进行分析，发现缺省使用的索引是IDX_MO_DATE。问题可能出在这里，因为相对于总数量1600万数据来说， 都mobile的数据是很少的，如果使用ID_MO_MOBILE比较容易锁定数据。<br>如下优化：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOBILE,MESSAGE,TRADE_CODE,MO_TIME  </span><br><span class="line"><span class="keyword">FROM</span> TBL_SMS_MO  </span><br><span class="line"><span class="keyword">WHERE</span> MOBILE=<span class="string">'130XXXXXXXX'</span>  </span><br><span class="line"><span class="keyword">AND</span> MO_TIME <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-01'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>) <span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-07'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>)  </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> MO_TIME <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></p><p>测试：<br>按F8运行这个SQL，哇～… … 2.360s，这就是差别。<br>用索引提高SQL Server性能<br>特别说明<br>　　在微软的SQL Server系统中通过有效的使用索引可以提高数据库的查询性能，但是性能的提高取决于数据库的实现。在本文中将会告诉你如何实现索引并有效的提高数据库的性能。　  </p><p>　 　在关系型数据库中使用索引能够提高数据库性能，这一点是非常明显的。用的索引越多，从数据库系统中得到数据的速度就越快。然而，需要注意的是，用的索引 越多，向数据库系统中插入新数据所花费的时间就越多。在本文中，你将了解到微软的SQL Server数据库所支持的各种不同类型的索引，在这里你将了解到如何使用不同的方法来实现索引，通过这些不同的实现方法，你在数据库的读性能方面得到的 远比在数据库的整体性能方面的损失要多得多。  </p><p>　　索引的定义<br>　　索引是数据库的工具，通过使用索引，在数据库中获取数据的时 候，就可以不用扫描数据库中的所有数据记录，这样能够提高系统获取数据的性能。使用索引可以改变数据的组织方式，使得所有的数据都是按照相似的结构来组织 的，这样就可以很容易地实现数据的检索访问。索引是按照列来创建的，这样就可以根据索引列中的值来帮助数据库找到相应的数据。  </p><p>　　索引的类型<br>　 　微软的SQL Server 支持两种类型的索引：clustered 索引和nonclustered索引。Clustered 索引在数据表中按照物理顺序存储数据。因为在表中只有一个物理顺序，所以在每个表中只能有一个clustered索引。在查找某个范围内的数据 时，Clustered索引是一种非常有效的索引，因为这些数据在存储的时候已经按照物理顺序排好序了。  </p><p>　　 Nonclustered索引不会影响到下面的物理存储，但是它是由数据行指针构成的。如果已经存在一个clustered索引，在 nonclustered中的索引指针将包含clustered索引的位置参考。这些索引比数据更紧促，而且对这些索引的扫描速度比对实际的数据表扫描要 快得多。  </p><p>　　如何实现索引<br>　　数据库可以自动创建某些索引。例如，微软的SQL Server系统通过自动创建唯一索引来强制实现UNIQUE约束，这样可以确保在数据库中不会插入重复数据。也可以使用CREATE INDEX语句或者通过SQL Server Enterprise Manager来创建其他索引，SQL Server Enterprise Manager还有一个索引创建模板来指导你如何创建索引。  </p><p>　　得到更好的性能<br>　　虽然索引可以带来性能上的优势，但是同时 也将带来一定的代价。虽然SQL Server系统允许你在每个数据表中创建多达256个nonclustered索引，但是建议不要使用这么多的索引。因为索引需要在内存和物理磁盘驱动 器上使用更多的存储空间。在执行插入声明的过程中可能会在一定程度上导致系统性能的下降，因为在插入数据的时候是需要根据索引的顺序插入，而不是在第一个 可用的位置直接插入数据，这样一来，存在的索引越多将导致插入或者更新声明所需要的时间就越多。  </p><p>　　在使用SQL Server系统创建索引的时候，建议参照下面的创建准则来实现：  </p><p>　　正确的选择数据类型<br>　 　在索引中使用某些数据类型可以提高数据库系统的效率，例如，Int，bigint， smallint，和tinyint等这些数据类型都非常适合于用在索引中，因为他们都占用相同大小的空间并且可以很容易地实现比较操作。其他的数据类型 如char和varchar的效率都非常低，因为这些数据类型都不适合于执行数学操作，并且执行比较操作的时间都比上面提到数据类型要长。  </p><p>　　确保在使用的过程中正确的利用索引值<br>　 　在执行查询操作时，可能所使用的列只是clustered的一部分，这时尤其要注意的是如何使用这些数据。当用这些数据列作为参数调用函数时，这些函数 可能会使现有的排序优势失效。例如，使用日期值作为索引，而为了实现比较操作，可能需要将这个日期值转换为字符串，这样将导致在查询过程中无法用到这个日 期索引值。  </p><p>　　在创建多列索引时，需要注意列的顺序<br>　　数据库将根据第一列索引的值来排列记录，然后进一步根据第二列的值来排序，依次排序直到最后一个索引排序完毕。哪一列唯一数据值较少，哪一列就应该为第一个索引，这样可以确保数据可以通过索引进一步交叉排序。  </p><p>　　在clustered索引中限制列的数量<br>　　在clustered索引中用到的列越多，在nonclustered索引中包含的clustered索引参考位置就越多，需要存储的数据也就越多。这样将增加包含索引的数据表的大小，并且将增加基于索引的搜索时间。  </p><p>　　避免频繁更新clustered索引数据列<br>　 　由于nonclustered 索引依赖于clustered 索引，所以如果构成clustered 索引的数据列频繁更新，将导致在nonclustered中存储的行定位器也将随之频繁更新。对于所有与这些列相关的查询来说，如果发生记录被锁定的情况 时，这将可能导致性能成本的增加。  </p><p>　　分开操作（如果可能的话）<br>　　对于一个表来说，如果需要进行频繁的执行插入、更新操作，同时还有大量读操作的话，在可能的情况下尝试将这个表分开操作。所有的插入和更新操作可以在一个没有索引的表中操作，然后将其复制到另外一个表中，在这个表里有大量的索引可以优化读数据的能力。  </p><p>　　适当的重建索引<br>　 　Nonclustered索引包含clustered索引的指针，这样一来Nonclustered索引将从属于clustered 索引。当重建clustered索引时，首先是丢弃原来的索引，然后再使用CREATE INDEX 来创建索引，或者在使用CREATE INDEX 声明的同时将DROP_EXISTING 子句作为重建索引的一部分。将丢弃和创建分为几步将会导致多次重建nonclustered 索引，而不象使用DROP_EXISTING 子句那样，只重建一次nonclustered 索引。  </p><p>　　明智的使用填充因子<br>　 　数据存储在那些具有固定大小的连续内存页面内。随着新的记录行的加入，数据内存页将逐渐被填满，系统就必须执行数据页的拆分工作，通过这个拆分工作将部 分数据转移到下一个新的页面当中。这样的拆分之后，将加重系统的负担，并且会导致存储的数据支离破碎。填充因子可以维护数据之间的缺口，一般在创建索引的 时候，该索引的填充因子就已经被设置好了。这样一来，可以减少插入数据所引起的页面分裂的次数。因为只是在创建索引的时候才维护空间的大小，在增加数据或 者更新数据时不会去维护空间的大小。因此，要想能够充分的利用填充因子，就必须周期性的重建索引。由填充因子所造成的缺口将导致读性能的下降，因为随着数 据库的扩张，越来越多的磁盘存取工作需要读取数据。所以，在读的次数超过写的次数的时候，很重要的一点是考虑使用填充因子还是使用缺省方式合适。  </p><p>　　管理层的决策<br>　 　通过有效的使用索引，可以在微软的SQL Server系统中实现很好的查询功能，但是使用索引的效率取决于几种不同的实现决策。在索引的性能平衡方面，要做出正确的数据库管理决策意味着需要在良 好的性能和困境中抉择。在特定的情况下，本文给出的一些建议将有助于你做出正确的决策</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle 分组统计，按照天、月份周和自然周、月、季度和年</title>
      <link href="/2018/08/21/Oracle-%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1%EF%BC%8C%E6%8C%89%E7%85%A7%E5%A4%A9%E3%80%81%E6%9C%88%E4%BB%BD%E5%91%A8%E5%92%8C%E8%87%AA%E7%84%B6%E5%91%A8%E3%80%81%E6%9C%88%E3%80%81%E5%AD%A3%E5%BA%A6%E5%92%8C%E5%B9%B4/"/>
      <url>/2018/08/21/Oracle-%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1%EF%BC%8C%E6%8C%89%E7%85%A7%E5%A4%A9%E3%80%81%E6%9C%88%E4%BB%BD%E5%91%A8%E5%92%8C%E8%87%AA%E7%84%B6%E5%91%A8%E3%80%81%E6%9C%88%E3%80%81%E5%AD%A3%E5%BA%A6%E5%92%8C%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>做报表统计时会经常用到 周，月，季度，年进行分组统计，所以结合网络搜索推荐的sql，总结如下</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按天统计</span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED+<span class="number">15</span>/<span class="number">24</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="keyword">as</span> 天,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED+<span class="number">15</span>/<span class="number">24</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">--trunc(t.CREATED, 'DD')</span></span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822152940276.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按自然周的日期统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(next_day(t.CREATED+<span class="number">15</span>/<span class="number">24</span> - <span class="number">7</span>,<span class="number">2</span>),<span class="string">'YYYY-MM-DD'</span>) <span class="keyword">AS</span> 周,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(next_day(t.CREATED+<span class="number">15</span>/<span class="number">24</span> - <span class="number">7</span>,<span class="number">2</span>),<span class="string">'YYYY-MM-DD'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 周;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153822139.jpg" alt="">  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按自然周统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'iw'</span>) <span class="keyword">AS</span> 周,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED,<span class="string">'iw'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 周;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153043617.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按自然月统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'YYYY-MM'</span>) <span class="keyword">as</span> 月份,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">to_char(t.CREATED,<span class="string">'YYYY-MM'</span>) <span class="comment">-- to_char(t.CREATED+15/24,'yyyy-mm') 不大准确</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 月份;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153206494.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按季统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'q'</span>) 季度,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED,<span class="string">'q'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 季度 <span class="keyword">NULLS</span>  <span class="keyword">LAST</span>;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153233106.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--按年统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'yyyy'</span>) <span class="keyword">AS</span> 年度,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED,<span class="string">'yyyy'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年度;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153258464.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring任务调度之Quartz</title>
      <link href="/2018/08/21/Spring%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B9%8BQuartz/"/>
      <url>/2018/08/21/Spring%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B9%8BQuartz/</url>
      
        <content type="html"><![CDATA[<p><code>Quartz</code>是<code>OpenSymphony</code>开源组织在<code>Job scheduling</code>领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。<br><a id="more"></a><br><code>Quartz</code>用一个小Java库发布文件（.jar文件），这个库文件包含了所有Quartz核心功能。这些功能的主要接口(API)是<code>Scheduler</code>接口。它提供了简单的操作，例如：将任务纳入日程或者从日程中取消，开始/停止/暂停日程进度。 </p><hr><h4 id="一、Quartz作业类的继承方式来讲，可以分为两类："><a href="#一、Quartz作业类的继承方式来讲，可以分为两类：" class="headerlink" title="一、Quartz作业类的继承方式来讲，可以分为两类："></a>一、Quartz作业类的继承方式来讲，可以分为两类：</h4><ol><li>作业类需要继承自特定的作业类基类，如Quartz中需要继承自<code>org.springframework.scheduling.quartz.QuartzJobBean</code>；<code>java.util.Time</code>r中需要继承自<code>java.util.TimerTask</code>。</li><li>作业类即普通的java类，不需要继承自任何基类。</li></ol><p>注:推荐使用第二种方式，因为这样所以的类都是普通类，不需要事先区别对待。</p><ul><li><h5 id="从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种："><a href="#从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种：" class="headerlink" title="从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种："></a>从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种：</h5></li></ul><ol><li>每隔指定时间则触发一次，在<code>Quartz</code>中对应的触发器为：<code>org.springframework.scheduling.quartz.SimpleTriggerBean</code></li><li>每到指定时间则触发一次，在<code>Quartz</code>中对应的调度器为：<code>org.springframework.scheduling.quartz.CronTriggerBean</code></li></ol><p>注：并非每种任务都可以使用这两种触发器，如<code>java.util.TimerTask</code>任务就只能使用第一种。<code>Quartz</code>和<code>spring tas</code>k都可以支持这两种触发条件。</p><hr><h4 id="第一种，作业类继承自特定的基类：org-springframework-scheduling-quartz-QuartzJobBean"><a href="#第一种，作业类继承自特定的基类：org-springframework-scheduling-quartz-QuartzJobBean" class="headerlink" title="第一种，作业类继承自特定的基类：org.springframework.scheduling.quartz.QuartzJobBean"></a>第一种，作业类继承自特定的基类：org.springframework.scheduling.quartz.QuartzJobBean</h4><h5 id="第一步：定义作业类"><a href="#第一步：定义作业类" class="headerlink" title="第一步：定义作业类"></a>第一步：定义作业类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;  </span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.QuartzJobBean;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job1</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> timeout;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">  <span class="comment">//调度工厂实例化后，经过timeout时间开始执行调度  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">this</span>.timeout = timeout;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 要调度的具体任务 </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span>  </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JobExecutionException </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"定时任务执行中…"</span>);  </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二步：spring配置文件中配置作业类JobDetailBean"><a href="#第二步：spring配置文件中配置作业类JobDetailBean" class="headerlink" title="第二步：spring配置文件中配置作业类JobDetailBean"></a>第二步：spring配置文件中配置作业类JobDetailBean</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"job1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.JobDetailBean"</span>&gt;  </span><br><span class="line">&lt;property name=<span class="string">"jobClass"</span> value=<span class="string">"com.gy.Job1"</span> /&gt;  </span><br><span class="line">&lt;property name=<span class="string">"jobDataAsMap"</span>&gt;  </span><br><span class="line">  &lt;map&gt;  </span><br><span class="line">    &lt;entry key=<span class="string">"timeout"</span> value=<span class="string">"0"</span> /&gt;  </span><br><span class="line">  &lt;<span class="regexp">/map&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>property&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><div class="note info"><p>说明：org.springframework.scheduling.quartz.JobDetailBean有两个属性，jobClass属性即我们在java代码中定义的任务类，jobDataAsMap属性即该任务类中需要注入的属性值。</p></div><h5 id="第三步：配置作业调度的触发方式（触发器）"><a href="#第三步：配置作业调度的触发方式（触发器）" class="headerlink" title="第三步：配置作业调度的触发方式（触发器）"></a>第三步：配置作业调度的触发方式（触发器）</h5><p>   Quartz的作业触发器有两种，分别是</p><p>   <code>org.springframework.scheduling.quartz.SimpleTriggerBean</code></p><p>   <code>org.springframework.scheduling.quartz.CronTriggerBean</code></p><h6 id="第一种-SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："><a href="#第一种-SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：" class="headerlink" title="第一种 SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："></a>第一种 SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SimpleTriggerBean"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span> <span class="attr">ref</span>=<span class="string">"job1"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startDelay"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span><span class="comment">&lt;!--调度工厂实例化后，经过0秒开始执行调度 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"repeatInterval"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span><span class="comment">&lt;!--每2秒调度一次 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="第二种-CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下："><a href="#第二种-CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下：" class="headerlink" title="第二种 CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下："></a>第二种 CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"cronTrigger"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"jobDetail"</span> ref=<span class="string">"job1"</span> /&gt;  </span><br><span class="line">  &lt;!--每天<span class="number">12</span>:<span class="number">00</span>运行一次--&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"cronExpression"</span> value=<span class="string">"0 0 12 * * ?"</span> /&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第四步：配置调度工厂"><a href="#第四步：配置调度工厂" class="headerlink" title="第四步：配置调度工厂"></a>第四步：配置调度工厂</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"triggers"</span>&gt;  </span><br><span class="line">    &lt;list&gt;  </span><br><span class="line">      &lt;ref bean=<span class="string">"cronTrigger"</span> /&gt;  </span><br><span class="line">    &lt;<span class="regexp">/list&gt;  </span></span><br><span class="line"><span class="regexp">  &lt;/</span>property&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p><em>说明：该参数指定的就是之前配置的触发器的名字。</em></p><h5 id="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。"><a href="#第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。" class="headerlink" title="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。"></a>第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。</h5><hr><h4 id="第二种，作业类不继承特定基类。"><a href="#第二种，作业类不继承特定基类。" class="headerlink" title="第二种，作业类不继承特定基类。"></a>第二种，作业类不继承特定基类。</h4><p>Spring能够支持这种方式，归功于两个类：</p><p><code>org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean</code></p><p><code>org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean</code></p><p>这两个类分别对应spring支持的两种实现任务调度的方式，即前文提到到java自带的timer task方式和Quartz方式。这里我只写MethodInvokingJobDetailFactoryBean的用法，使用该类的好处是,我们的任务类不再需要继承自任何类，而是普通的pojo。</p><h5 id="第一步：编写任务类"><a href="#第一步：编写任务类" class="headerlink" title="第一步：编写任务类"></a>第一步：编写任务类</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Job2</span> &#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doJob2</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"不继承QuartzJobBean方式-调度进行中…"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：可以看出，这就是一个普通的类，并且有一个方法。</strong></p><h5 id="第二步：配置作业类"><a href="#第二步：配置作业类" class="headerlink" title="第二步：配置作业类"></a>第二步：配置作业类</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"job2"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.gy.Job2"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"doJob2"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"concurrent"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span><span class="comment">&lt;!-- 作业不并发调度 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>说明：这一步是关键步骤，声明一个MethodInvokingJobDetailFactoryBean，有两个关键属性：targetObject指定任务类，targetMethod指定运行的方法。往下的步骤就与方法一相同了，为了完整，同样贴出。</em></p><h5 id="第三步：配置作业调度的触发方式（触发器）-1"><a href="#第三步：配置作业调度的触发方式（触发器）-1" class="headerlink" title="第三步：配置作业调度的触发方式（触发器）"></a>第三步：配置作业调度的触发方式（触发器）</h5><p>   Quartz的作业触发器有两种，分别是</p><p>   <code>org.springframework.scheduling.quartz.SimpleTriggerBean</code></p><p>   <code>org.springframework.scheduling.quartz.CronTriggerBean</code></p><h6 id="第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："><a href="#第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：" class="headerlink" title="第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："></a>第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SimpleTriggerBean"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span> <span class="attr">ref</span>=<span class="string">"job2"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startDelay"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span><span class="comment">&lt;!-- 调度工厂实例化后，经过0秒开始执行调度 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"repeatInterval"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span><span class="comment">&lt;!-- 每2秒调度一次 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="第二种CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下："><a href="#第二种CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下：" class="headerlink" title="第二种CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下："></a>第二种CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"cronTrigger"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"jobDetail"</span> ref=<span class="string">"job2"</span> /&gt;  </span><br><span class="line">  &lt;!--每天<span class="number">12</span>:<span class="number">00</span>运行一次 --&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"cronExpression"</span> value=<span class="string">"0 0 12 * * ?"</span> /&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p><strong>以上两种调度方式根据实际情况，任选一种即可。</strong></p><h5 id="第四步：配置调度工厂-1"><a href="#第四步：配置调度工厂-1" class="headerlink" title="第四步：配置调度工厂"></a>第四步：配置调度工厂</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"triggers"</span>&gt;  </span><br><span class="line">    &lt;list&gt;  </span><br><span class="line">      &lt;ref bean=<span class="string">"cronTrigger"</span> /&gt;  </span><br><span class="line">    &lt;<span class="regexp">/list&gt;  </span></span><br><span class="line"><span class="regexp">  &lt;/</span>property&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p><em>说明：该参数指定的就是之前配置的触发器的名字。</em></p><h5 id="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。-1"><a href="#第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。-1" class="headerlink" title="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。"></a>第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。</h5><p><strong>到此，spring中Quartz的基本配置就介绍完了，当然了，使用之前，要导入相应的spring的包与Quartz的包，这些就不消多说了。</strong></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">《官网》</a><br><a href="http://sishuok.com/forum/posts/list/405.html" target="_blank" rel="noopener">《Quartz任务调度快速入门》</a><br><a href="http://lavasoft.blog.51cto.com/62575/181907/" target="_blank" rel="noopener">《深入解读Quartz的原理》</a><br><a href="https://blog.csdn.net/u010648555/article/category/6601767" target="_blank" rel="noopener">《Quartz学习-阿飞(dufyun)》</a><br><a href="https://www.cnblogs.com/hongwz/p/5642429.html" target="_blank" rel="noopener">《Spring任务调度之Quartz-独具匠心》</a><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/" target="_blank" rel="noopener">《基于Quartz开发企业级任务调度应用》</a><br><a href="http://blog.csdn.net/tengdazhang770960436/article/details/51019291" target="_blank" rel="noopener">《Quartz 数据库表含义解释》</a><br><a href="https://my.oschina.net/chengxiaoyuan/blog/664833" target="_blank" rel="noopener">《Quartz源码分析》</a><br><a href="http://blog.csdn.net/Evankaka/article/category/3155529" target="_blank" rel="noopener">《Quartz系列》</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring+Quartz的版本问题</title>
      <link href="/2018/08/21/Spring-Quartz%E7%9A%84%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
      <url>/2018/08/21/Spring-Quartz%E7%9A%84%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java<span class="selector-class">.lang</span><span class="selector-class">.IncompatibleClassChangeError</span>: class org<span class="selector-class">.springframework</span><span class="selector-class">.scheduling</span><span class="selector-class">.quartz</span><span class="selector-class">.CronTriggerBean</span> has interface org<span class="selector-class">.quartz</span><span class="selector-class">.CronTrigger</span> as superclass</span><br></pre></td></tr></table></figure><a id="more"></a><p>原因是Spring 3.0版本中内置的Quartz版本是&lt;2.0的，在使用最新的Quartz包(&gt;2.0)之后，接口不兼容。</p><p>解决办法有三种：</p><p>1.降低Quartz版本，降到1.X去。</p><p>2.升级Spring版本到3.1+，根据Spring的建议，将原来的<strong>TriggerBean替换成</strong>TriggerFactoryBean，例如CronTriggerBean 就可以替换成 CronTriggerFactoryBean。替换之后问题解决。</p><p>3.如果不在xml配置文件中引用 Spring 3.0 是支持 Quartz2.2.1(目前最新版本)，直接在程序中调用即可。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python骚操作：微信远程控制电脑</title>
      <link href="/2018/08/20/Python%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BE%AE%E4%BF%A1%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/"/>
      <url>/2018/08/20/Python%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BE%AE%E4%BF%A1%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/</url>
      
        <content type="html"><![CDATA[<p>今天带给大家一个非常有意思的 python 程序，基于 itchat 实现微信控制电脑。你可以通过在微信发送命令，来拍摄当前电脑的使用者，然后图片会发送到你的微信上。甚至你可以发送命令来远程关闭电脑。</p><a id="more"></a><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/374660489816441329_%E7%9C%8B%E5%9B%BE%E7%8E%8B.jpg?x-oss-process=style/w200" alt=""></p><p><strong>应用场景</strong></p><p>你可爱又迷人的女朋友，在看到这篇教程之后，非常的开心。在你的电脑上部署了这个脚本，并且在你不知情的情况下，默默的登录上。随后跟你说我出去跟闺蜜逛街啦，今天就不陪你了。要记得不准吃鸡。</p><p>你心想老子终于可以放松一天了！开心的吃鸡！口上说着：“好的！亲爱的玩得开心！”等着女朋友出门以后，你就开启了吃鸡模式，在绝地求生里大开杀戒。</p><p>你的女朋友早已对你了如指掌，通过脚本，先让电脑截图留下现场证据，随后再打电话质问你是否在吃鸡，你如果撒谎就把电脑远程关机。</p><p>最后你想了下不对我没有女朋友啊，随后你转头微笑地看着你的室友。</p><p><strong>程序思路</strong></p><p>此次程序使用的环境是 python3.7 + windows7，在运行程序之前请先确保你已经安装好了 opencv-python 和 matplotlib。通过 pip install 即可安装。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> opencv-python</span><br><span class="line">pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure><p>程序主要是通过使用 itchat 库来登录到微信网页端，然后通过 itchat 来发送消息和接收消息。并通过 opencv 来调用电脑的摄像头，把当前使用电脑的用户拍照下来，发送到你的微信上。至于远程关机是通过调用 os 库，发送 cmd 命名即可实现。</p><p><strong>程序源码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/8/20 11:12</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : wechat_control_computer.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">sendMsg = <span class="string">u"&#123;消息助手&#125;：暂时无法回复"</span></span><br><span class="line">usageMsg = <span class="string">u"使用方法：\n1.运行CMD命令：cmd xxx (xxx为命令)\n"</span> \</span><br><span class="line">           <span class="string">u"-例如关机命令:\ncmd shutdown -s -t 0 \n"</span> \</span><br><span class="line">           <span class="string">u"2.获取当前电脑用户：cap\n3.启用消息助手(默认关闭)：ast\n"</span> \</span><br><span class="line">           <span class="string">u"4.关闭消息助手：astc"</span></span><br><span class="line">flag = <span class="number">0</span>  <span class="comment"># 消息助手开关</span></span><br><span class="line">nowTime = time.localtime()</span><br><span class="line">filename = str(nowTime.tm_mday) + str(nowTime.tm_hour) + str(nowTime.tm_min) + str(nowTime.tm_sec) + <span class="string">".txt"</span></span><br><span class="line">myfile = open(filename, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register('Text')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    message = msg[<span class="string">'Text'</span>]</span><br><span class="line">    fromName = msg[<span class="string">'FromUserName'</span>]</span><br><span class="line">    toName = msg[<span class="string">'ToUserName'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> toName == <span class="string">"filehelper"</span>:</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">"cap"</span>:</span><br><span class="line">            cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">            ret, img = cap.read()</span><br><span class="line">            cv2.imwrite(<span class="string">"weixinTemp.jpg"</span>, img)</span><br><span class="line">            itchat.send(<span class="string">'@img@%s'</span> % <span class="string">u'weixinTemp.jpg'</span>, <span class="string">'filehelper'</span>)</span><br><span class="line">            cap.release()</span><br><span class="line">        <span class="keyword">if</span> message[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">"cmd"</span>:</span><br><span class="line">            os.system(message.strip(message[<span class="number">0</span>:<span class="number">4</span>]))</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">"ast"</span>:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            itchat.send(<span class="string">"消息助手已开启"</span>, <span class="string">"filehelper"</span>)</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">"astc"</span>:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            itchat.send(<span class="string">"消息助手已关闭"</span>, <span class="string">"filehelper"</span>)</span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="number">1</span>:</span><br><span class="line">        itchat.send(sendMsg, fromName)</span><br><span class="line">        myfile.write(message)</span><br><span class="line">        myfile.write(<span class="string">"\n"</span>)</span><br><span class="line">        myfile.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    itchat.auto_login()</span><br><span class="line">    itchat.send(usageMsg, <span class="string">"filehelper"</span>)</span><br><span class="line">    itchat.run()</span><br></pre></td></tr></table></figure><p>程序并不复杂，定义了一些发送的消息，然后通过调用 itchat 和 cv2 相关库的操作，即可实现。关于 itchat 库的一些操作，可以去网上找相关的文档。</p><p><strong><strong>使用教程</strong></strong></p><p>获取源代码，然后在你的电脑上运行。随后会弹出一个微信网页登录的二维码。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180820122055.png?x-oss-process=style/w200" alt=""></p><p>使用你的手机微信扫描登录，等待一会儿，微信文件助手就会收到相应操作信息。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/374660489816441329_%E7%9C%8B%E5%9B%BE%E7%8E%8B.jpg?x-oss-process=style/w200" alt=""></p><p>发送消息「cmd shutdown -s -t 0」即可让当前的电脑关闭。</p><p>发送消息「cap」即可调用电脑摄像头拍摄当前用户，然后把图片发送到微信上。</p><p>当然 cmd 命名还可以做更多有趣的事，大家可以自己去网上搜索下。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python中深拷贝与浅拷贝的区别</title>
      <link href="/2018/08/18/Python%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/08/18/Python%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><div class="note default">在Python中对象的赋值其实就是对象的引用。当创建一个对象，把它赋值给另一个变量的时候，python并没有拷贝这个对象，只是拷贝了这个对象的引用而已。<p></p></div><p><br></p><div class="note primary">浅拷贝：拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已。也就是，把对象复制一遍，但是该对象中引用的其他对象我不复制<p></p></div><div class="note primary">深拷贝：外围和内部元素都进行了拷贝对象本身，而不是引用。也就是，把对象复制一遍，并且该对象中引用的其他对象我也复制。<p></p></div><h3 id="几个术语的解释："><a href="#几个术语的解释：" class="headerlink" title="几个术语的解释："></a>几个术语的解释：</h3><div class="note default">1，变量：是一个系统表的元素，拥有指向对象的连接空间<br>2，对象：被分配的一块内存，存储其所代表的值<br>3，引用：是自动形成的从变量到对象的指针<br>4，注意：类型（int类型，long类型(python3已去除long类型，只剩下int类型的数据)）属于对象，不是变量<br>5，不可变对象：一旦创建就不可修改的对象，包括字符串、元组、数字<br>6，可变对象：可以修改的对象，包括列表、字典。<p></p></div><h3 id="应用的范围："><a href="#应用的范围：" class="headerlink" title="应用的范围："></a>应用的范围：</h3><div class="note default">1，切片可以应用于：列表、元组、字符串，但不能应用于字典。<br>2，深浅拷贝，既可应用序列（列表、元组、字符串），也可应用字典。<p></p></div><h3 id="深浅拷贝的作用："><a href="#深浅拷贝的作用：" class="headerlink" title="深浅拷贝的作用："></a>深浅拷贝的作用：</h3><div class="note default">1，减少内存的使用<br>2，以后在做数据的清洗、修改或者入库的时候，对原数据进行复制一份，以防数据修改之后，找不到原数据。<p></p></div><h3 id="对于不可变对象的深浅拷贝："><a href="#对于不可变对象的深浅拷贝：" class="headerlink" title="对于不可变对象的深浅拷贝："></a>对于不可变对象的深浅拷贝：</h3><div class="note warning">不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。<br>一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。<p></p></div><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a=(1,2,3)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====第一种=号浅拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=a</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====另一种copy浅拷贝==="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.copy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====深拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.deepcopy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">=====浅拷贝=====</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">2814522335952</span><br><span class="line">2814522335952</span><br><span class="line">=====另一种浅拷贝===</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">2814522335952</span><br><span class="line">2814522335952</span><br><span class="line">=====深拷贝=====</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">2814522335952</span><br><span class="line">2814522335952</span><br></pre></td></tr></table></figure><h1 id="对于可变对象深浅拷贝"><a href="#对于可变对象深浅拷贝" class="headerlink" title="对于可变对象深浅拷贝:"></a>对于可变对象深浅拷贝:</h1><div class="note info"><p>=浅拷贝：值相等，地址相等<br>copy浅拷贝：值相等，地址不相等<br>deepcopy深拷贝：值相等，地址不相等</p></div><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2,3]</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====第一种=号浅拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=a</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====另一种copy浅拷贝==="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.copy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====深拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.deepcopy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="comment">#结果如下：</span></span><br><span class="line">=====浅拷贝=====</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">2007696321544</span><br><span class="line">2007696321544</span><br><span class="line">=====另一种copy浅拷贝===</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">2007696321544</span><br><span class="line">2007695909960</span><br><span class="line">=====深拷贝=====</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">2007696321544</span><br><span class="line">2007696319560</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><div class="note default"><p>1，深浅拷贝都是对源对象的复制，占用不同的内存空间。<br>2，不可变类型的对象，对于深浅拷贝毫无影响，最终的地址值和值都是相等的。<br>3，可变类型：<br>=浅拷贝： 值相等，地址相等<br>copy浅拷贝：值相等，地址不相等<br>deepcopy深拷贝：值相等，地址不相等</p></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（使用图床）</title>
      <link href="/2018/08/17/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%EF%BC%89/"/>
      <url>/2018/08/17/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>图片作为互联网服务中最基础的资源之一，随着互联网基础服务越来越专业化，图片的存储、处理、分发也发展成了一项独立的基础服务。试想一下，如果每家互联网公司都要花费大量人力物力去做图片相关的技术研发，哪还有时间去做自己的业务。专业的事情还是要交给专业的人来做。<br><a id="more"></a></p><p>图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。</p><p>当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生。我就经历过云服务商机房被雷劈，网站都挂掉的情况。支付宝光缆不也被挖断过吗？不过，对于我们个人用户来说，要求也没那么高，图床已经完全能满足我们的需求了。</p><hr><p>目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。  </p><h2 id="公共图床"><a href="#公共图床" class="headerlink" title="公共图床"></a>公共图床</h2><h3 id="微博图床"><a href="#微博图床" class="headerlink" title="微博图床"></a>微博图床</h3><p>由于微博本身就是面向公众提供服务，每个人发微博基本都得带上几张图片，以微博的体量，每天的新增图片数也不是个小数字。但是微博对于图片上传服务也没有接口说明文档，上传的接口还是在开发者们从微博产品里找出来的，可能微博只希望上传的图片仅仅用于微博产品本身吧。</p><p>微博图床的特点是免费，没有容量限制，全网 CDN 加速，支持 HTTPS，到哪里都很快。但是免费的服务也有不足的地方，上传的图片会被转成 jpg，图片中可能加上了肉眼难以识别的水印，另外微博的图片鉴别服务也可能会随时删除你的图片。</p><p>相关链接：</p><ul><li><p><a href="http://weibo.com/minipublish" target="_blank" rel="noopener">微博图床上传地址</a>：从这里直接上传图片比较麻烦，你可以使用下面介绍的一些图床工具，上传起来更方便。  </p></li><li><p><a href="http://picupload.service.weibo.com/interface/" target="_blank" rel="noopener">微博图床 API</a>：用浏览器当然是不能访问的，只提供图片上传。  </p></li></ul><h3 id="Imgur-图床"><a href="#Imgur-图床" class="headerlink" title="Imgur 图床"></a>Imgur 图床</h3><p><img src="https://cdn.sspai.com/2017/08/21/7d56369618ca55b7788a1f2b2469e274.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="Imgur API"></p><p>Imgur API</p><p><a href="https://imgur.com/" target="_blank" rel="noopener">Imgur</a> 是一家国外老牌的图片存储服务商，国外速度很快，口碑不错，支持 HTTPS。但是国内速度很不稳定，所以追求国内速度的同学慎用。</p><p>相关链接：</p><ul><li><a href="https://apidocs.imgur.com/" target="_blank" rel="noopener">Imgur API</a>  </li></ul><h3 id="SM-MS-图床"><a href="#SM-MS-图床" class="headerlink" title="SM.MS 图床"></a>SM.MS 图床</h3><p><img src="https://cdn.sspai.com/2017/08/21/a78e40318ea02f94a0b9e2ea19d8b10e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="sm.ms 图床"></p><p>sm.ms 图床</p><p><a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a> 是由 V2EX @<a href="https://www.v2ex.com/member/Showfom" target="_blank" rel="noopener">Showfom</a> 自建的，无外链限制，无流量限制的图床，支持 HTTPS，速度不错，已经运行两年多了。</p><p>相关链接：</p><ul><li><a href="https://sm.ms/doc/" target="_blank" rel="noopener">sm.ms API</a>  </li></ul><p>其它公共图床还有很多，一搜一大把，不过大部分规模都比较小，要不就是国内访问速度不理想，使用前最好先了解一下。</p><hr><p>目前自建图床方案有两种，一种是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片，另一种是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。</p><h2 id="自建图床：云服务"><a href="#自建图床：云服务" class="headerlink" title="自建图床：云服务"></a>自建图床：云服务</h2><h3 id="七牛"><a href="#七牛" class="headerlink" title="七牛"></a>七牛</h3><p><img src="https://cdn.sspai.com/2017/08/21/2242e610efb14f6d63261547f3e90609.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="七牛云"></p><p>七牛云</p><p><a href="https://portal.qiniu.com/signup?code=3lmd5t4axez4i" target="_blank" rel="noopener">七牛</a> 作为国内领先的云服务商，全网 CDN 加速，全国访问速度都不错，API 很详细，对开发者比较友好。免费用户提供 10GB 存储空间，国内和海外分别提供 10 GB 的 HTTP 免费流量，七牛的 HTTPS 流量是收费的，没有免费额度。此外，七牛还提供了针对图片的各种服务，包括图片裁剪，压缩，鉴黄等等衍生服务。如果你觉得图片尺寸太大，可以在外链后面添加参数，访问的时候七牛会自动根据你的参数对图片进行处理。</p><p>目前我的图片都存在七牛上，使用 HTTPS 外链，每个月支出也就几块钱，就为了博客上那个小绿锁 😆。</p><p>相关链接：</p><ul><li><p><a href="https://developer.qiniu.com/" target="_blank" rel="noopener">七牛云 API 文档</a>  </p></li><li><p><a href="https://www.qiniu.com/prices" target="_blank" rel="noopener">七牛价格</a>  </p></li></ul><h3 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h3><p><img src="https://cdn.sspai.com/2017/08/21/9f1b5842c3ab1b8bc29e5fdbce49a972.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="又拍云"></p><p>又拍云</p><p><a href="https://www.upyun.com/" target="_blank" rel="noopener">又拍云</a> 也算是国内比较有名的云服务商了，国内拥有 200+ 的自建 CDN 节点，国内速度也不错，API 很详细，不过对于普通用户没有免费额度，目前实行的是「按照用户每日实际消耗的 CDN 流量，实行 1:1 的存储空间费免费使用」。</p><p>相关链接：</p><ul><li><p><a href="http://docs.upyun.com/guide/#api" target="_blank" rel="noopener">又拍云 API 文档</a>  </p></li><li><p><a href="https://www.upyun.com/pricing" target="_blank" rel="noopener">又拍云价格</a>  </p></li></ul><h3 id="阿里云-OSS"><a href="#阿里云-OSS" class="headerlink" title="阿里云 OSS"></a>阿里云 OSS</h3><p><img src="https://cdn.sspai.com/2017/08/21/dea389e72df9a46289eaa24b3d88aee4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="阿里云 OSS"></p><p>阿里云 OSS</p><p><a href="https://www.aliyun.com/price/product#/oss/detail" target="_blank" rel="noopener">阿里云 OSS</a>（Object Storage Service），即阿里云对象存储服务，也可以作为图床，速度国内国外都不错，SDK 和 API 都很完善，收费也不算太贵，就是计费方案太复杂，目前费用包括：存储费用+流量费用+接口调用费用+数据处理，而且还分时段，地区，阶梯计费。可以选择包年包月和按量付费，具体价格和文档可以查看下面的官网介绍。</p><p>相关链接：</p><ul><li><p><a href="https://promotion.aliyun.com/ntms/act/ossdoclist.html" target="_blank" rel="noopener">阿里云 OSS 文档</a>  </p></li><li><p><a href="https://www.aliyun.com/price/product#/oss/detail" target="_blank" rel="noopener">阿里云 OSS 价格</a>  </p></li></ul><h2 id="自建图床：开源方案"><a href="#自建图床：开源方案" class="headerlink" title="自建图床：开源方案"></a>自建图床：开源方案</h2><p>如果你有 VPS，并且网络速度 OK 的话，自建图床也是一个不错的选择。</p><h3 id="Lychee"><a href="#Lychee" class="headerlink" title="Lychee"></a>Lychee</h3><p><img src="https://cdn.sspai.com/2017/08/21/5d4f0efa178487d54309f3da47d75e6e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="Lychee"></p><p>Lychee</p><p><a href="https://github.com/electerious/Lychee" target="_blank" rel="noopener">Lychee</a> 是一个开源免费的基于 PHP 的图片管理系统，支持 Docker 部署，可以直接当做图床来用，Lychee 还支持很多扩展。</p><h3 id="树洞外链"><a href="#树洞外链" class="headerlink" title="树洞外链"></a>树洞外链</h3><p><img src="https://cdn.sspai.com/2017/08/21/d916ed36a802e3e878e95d556bd64ef3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="树洞外链"></p><p>树洞外链</p><p><a href="https://yun.aoaoao.me/" target="_blank" rel="noopener">树洞外链</a> 是一款免费开源的 PHP 外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。</p><p>相关链接：</p><ul><li><a href="https://file.aoaoao.me/" target="_blank" rel="noopener">演示站点</a>  </li></ul><h2 id="上传工具"><a href="#上传工具" class="headerlink" title="上传工具"></a>上传工具</h2><p>对普通用户来说，直接使用图床 API 很麻烦，我们可以借助一些工具方便的上传图片，下面就根据 macOS、Windows、Web 分别推荐几款工具。</p><h3 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h3><p><img src="https://cdn.sspai.com/attachment/origin/2016/07/04/336030.png" alt=""></p><h4 id="iPic-1"><a href="#iPic-1" class="headerlink" title="iPic"></a>iPic</h4><p>Mac</p><p><a href="https://sspai.com/app/iPic" target="_blank" rel="noopener">相关文章</a></p><p>下载</p><ul><li><a href="https://itunes.apple.com/cn/app/ipic-tu-chuang-shen-qi/id1101244278?mt=12&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">Mac</a></li></ul><p><a href="https://itunes.apple.com/cn/app/id1101244278?ls=1&amp;mt=12" target="_blank" rel="noopener">iPic</a> 是 macOS 上口碑最好的图床工具，支持 微博图床、七牛、阿里云 OSS、又拍云、Imgur、Flickr 等常见图床，支持拖拽、快捷键、剪贴板上传，支持上传前压缩，上传完毕自动生成 Markdown 并拷贝到剪贴板。如果你想迁移图床，开发者 <a href="https://slarker.me/image-oss/toolinbox.net" target="_blank" rel="noopener">@jason</a> 还做了一款 <a href="https://toolinbox.net/iPic/iPicMover.html" target="_blank" rel="noopener">图床迁移工具 iPic Mover</a> 来帮助你。此外，简洁优雅的 Markdown 工具 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>也内嵌了 iPic 的上传服务，如果你也使用 Typora 的话，能感觉到这俩工具简直是绝配。</p><h3 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h3><p><img src="https://cdn.sspai.com/attachment/origin/2017/01/23/364951.png" alt=""></p><h4 id="MWeb-1"><a href="#MWeb-1" class="headerlink" title="MWeb"></a>MWeb</h4><p>iOS</p><p><a href="https://sspai.com/app/MWeb" target="_blank" rel="noopener">相关文章</a></p><p>下载</p><ul><li><a href="https://itunes.apple.com/cn/app/mweb-pro-markdown-writing/id1183407767?mt=8&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">iOS 通用</a></li><li><a href="https://itunes.apple.com/cn/app/mweb-zhuan-ye-demarkdown-xie/id954188948?mt=12&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">Mac</a></li></ul><p><img src="https://cdn.sspai.com/2017/08/21/a2229ac36e94260816e5423f5ceeba09.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="MWeb 中的图床支持"></p><p>MWeb 中的图床支持</p><p>如果你只是码字的时候才用到图床，那可能 <a href="http://zh.mweb.im/" target="_blank" rel="noopener">MWeb</a> 也能满足你的需求，MWeb 支持七牛、imgur、Google Photos，还支持自定义图床，写作的时候只需要将图片拖进来，写作完成一键上传所有图片，也很方便。</p><h3 id="Dropzone-3"><a href="#Dropzone-3" class="headerlink" title="Dropzone 3"></a>Dropzone 3</h3><p><img src="https://cdn.sspai.com/attachment/origin/2015/12/14/298954.png" alt=""></p><h4 id="Dropzone-3-1"><a href="#Dropzone-3-1" class="headerlink" title="Dropzone 3"></a>Dropzone 3</h4><p>Mac</p><p><a href="https://sspai.com/app/Dropzone 3" target="_blank" rel="noopener">相关文章</a></p><p>下载</p><ul><li><a href="https://itunes.apple.com/cn/app/dropzone-3/id695406827?mt=12&amp;ign-mpt=uo%3D4&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">Mac</a></li></ul><p><a href="https://itunes.apple.com/us/app/dropzone-3/id695406827?mt=12" target="_blank" rel="noopener">Dropzone 3</a> 也可以通过 <a href="https://kyleduo.com/" target="_blank" rel="noopener">七牛插件</a> 来支持上传图片，和 MWeb 类似，具体教程可以看 <a href="https://blog.kyleduo.com/2017/02/27/qiniu-upload-for-dropzone/#more" target="_blank" rel="noopener">这里</a>。</p><h3 id="MPic"><a href="#MPic" class="headerlink" title="MPic"></a>MPic</h3><p><img src="https://cdn.sspai.com/2017/08/21/ff144a6f126b6e608b93b5ba06013e14.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="MPic"></p><p>MPic</p><p><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">MPic</a> 目测是 Windows 上唯一的图床工具了，目前只支持七牛，把图片拖拽到软件窗口中就能上传。</p><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>使用 Web 技术开发的图床工具一抓一大把，大部分都基于七牛和微博图床 API，这里就介绍两个体验不错的吧：</p><ul><li><p><a href="http://yotuku.cn/" target="_blank" rel="noopener">极简图床</a>：默认公共图床使用 sm.ms、微博图床，可以自定义支持七牛，界面简洁美观，支持 <a href="https://chrome.google.com/webstore/detail/heebflcbemenefckkgfnnklbhdbdkagg" target="_blank" rel="noopener">Chrome 插件</a>，注册后还可以同步上传历史。  </p></li><li><p><a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf/reviews" target="_blank" rel="noopener">微博图床 Chroem 扩展</a>：开源的图床工具，只支持微博图床，使用起来也很方便，可以批量上传，管理上传历史。  </p></li></ul><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>如果你对上面推荐的产品不满意，并且你会折腾的话，可以使用这个脚本来完成图片上传：<a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="noopener">Markdown 图片实用工具</a></p><p>该脚本使用 Python 版的七牛 SDK 来实现上传功能，你可以按照相关介绍，搭配 Alfred 来快速完成图片上传。</p><hr><p>图床服务最重要的是稳定性，大厂的云服务也都比较有保障，大家只要考虑下价格和易用性就可以了。就我个人而言，我首先推荐七牛，它的价格比较厚道，免费用户也有一定额度，数据可以自己掌控，另外各大平台的图床工具也基本都支持，易用性很高。其次推荐微博图床，对于不是很重要的图片，都可以存到微博图床，毕竟流量存储都免费，速度也不错。至于图床工具，就看自己的喜好了，只要顺手就行。但是不论选择哪一个服务或者工具，我觉得首先要自己可以掌控数据。</p><p>总之，适合自己的才是最好的。如果你还有其它好用的工具或者图床服务，欢迎留言给我，我会补充进来。</p><hr><p><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">《图床神器》</a></p><p><a href="https://pic.xiaojianjian.net/" target="_blank" rel="noopener">《小贱贱图床》</a></p><p><a href="https://sm.ms/" target="_blank" rel="noopener">《SM.SMb》</a></p><p><a href="https://sspai.com/post/40499" target="_blank" rel="noopener">《嗯，图片就交给它了》</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>InnoDB并发如此高，原因竟然在这？</title>
      <link href="/2018/08/14/InnoDB%E5%B9%B6%E5%8F%91%E5%A6%82%E6%AD%A4%E9%AB%98%EF%BC%8C%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E5%9C%A8%E8%BF%99%EF%BC%9F/"/>
      <url>/2018/08/14/InnoDB%E5%B9%B6%E5%8F%91%E5%A6%82%E6%AD%A4%E9%AB%98%EF%BC%8C%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E5%9C%A8%E8%BF%99%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><span></span><br><a id="more"></a><br>此文摘自微信公众号【架构师之路】</p><p>微信扫一扫<br>关注该公众号</p><p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961431&amp;idx=1&amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;send_time=" alt=""></p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961431&amp;idx=1&amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;chksm=bd2d0d8b8a5a849d8cb5a616c957abde7a6485cd2624372b84a5459eed081bd95429a09572f8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB行锁，如何锁住一条不存在的记录？</a>》埋了一个坑，没想到评论反响剧烈，大家都希望深挖下去。原计划写写InnoDB的锁结束这个case，既然呼声这么高，干脆全盘<strong>系统性</strong>的写写InnoDB的<strong>并发控制</strong>，<strong>锁</strong>，<strong>事务模型</strong>好了。</p><p>体系相对宏大，一篇肯定写不完，容我娓娓道来，通俗地说清楚来龙去脉。</p><p><strong>一、并发控制</strong></p><p><strong>为啥要进行并发控制？</strong></p><p>并发的任务对同一个临界资源进行操作，如果不采取措施，可能导致不一致，故必须进行<strong>并发控制</strong>（Concurrency Control）。</p><p><strong>技术上，通常如何进行并发控制？</strong></p><p>通过并发控制保证数据一致性的常见手段有：</p><ul><li><p>锁（Locking）</p></li><li><p>数据多版本（Multi Versioning）</p></li></ul><p><strong>二、锁</strong></p><p><strong>如何使用普通锁保证一致性？</strong></p><p>普通锁，被使用最多：</p><p>(1)<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">操作数据前，锁住，实施互斥</span>，不允许其他的并发任务操作；</p><p>(2)操作完成后，释放锁，让其他任务执行；</p><p>如此这般，来保证一致性。</p><p><strong>普通锁存在什么问题？</strong></p><p>简单的锁住太过粗暴，连“读任务”也无法并行，任务执行过程本质上是串行的。</p><p>于是出现了<strong>共享锁</strong>与<strong>排他锁</strong>：</p><ul><li><p>共享锁（<span style="color: rgb(255, 76, 0);"><strong><span style="letter-spacing: 1px;font-size: 12px;">S</span></strong></span>hare Locks，记为S锁），读取数据时加S锁</p></li><li><p>排他锁（e<span style="color: rgb(255, 76, 0);"><strong><span style="letter-spacing: 1px;font-size: 12px;">X</span></strong></span>clusive Locks，记为X锁），修改数据时加X锁</p></li></ul><p>共享锁与排他锁的玩法是：</p><ul><li><p><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">共享锁之间不互斥</span>，简记为：<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">读读可以并行</span></p></li><li><p><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">排他锁与任何锁互斥</span>，简记为：<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">写读，写写不可以并行</span></p></li></ul><p>可以看到，一旦写数据的任务没有完成，数据是不能被其他任务读取的，这对并发度有较大的影响。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">对应到数据库，可以理解为，写事务没有提交，读相关数据的</span></span><span style="font-family: 宋体;letter-spacing: 1px;font-size: 12px;">select</span><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">也会被阻塞。</span></em></span></p><p><strong>有没有可能，进一步提高并发呢？</strong></p><p>即使写任务没有完成，其他读任务也可能并发，这就引出了数据多版本。</p><p><strong>三、数据多版本</strong></p><p><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">数据多版本</span>是一种能够进一步提高并发的方法，它的<strong>核心原理</strong>是：</p><p>（1）写任务发生时，将数据克隆一份，以版本号区分；</p><p>（2）写任务操作新克隆的数据，直至提交；</p><p>（3）并发读任务可以继续读取旧版本的数据，不至于阻塞；</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/222481745858779089.jpg" alt=""></p><p>如上图：</p><ol><li><p>最开始数据的版本是V0；</p></li><li><p>T1时刻发起了一个写任务，这是把数据clone了一份，进行修改，版本变为V1，但任务还未完成；</p></li><li><p>T2时刻并发了一个读任务，依然可以读V0版本的数据；</p></li><li><p>T3时刻又并发了一个读任务，依然不会阻塞；</p></li></ol><p>可以看到，数据多版本，通过“读取旧版本数据”能够极大提高任务的并发度。</p><p>提高并发的演进思路，就在如此：</p><ul><li><p><strong>普通锁</strong>，本质是<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">串行</span>执行</p></li><li><p><strong>读写锁</strong>，可以实现<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">读读并发</span></p></li><li><p><strong>数据多版本</strong>，可以实现<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">读写并发</span></p></li></ul><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：这个思路，比整篇文章的其他技术细节更重要，希望大家牢记。</span></em></span></p><p>好，对应到InnoDB上，具体是怎么玩的呢？</p><p><strong>四、redo, undo,**</strong>回滚段**</p><p>在进一步介绍InnoDB如何使用“读取旧版本数据”极大提高任务的并发度之前，有必要先介绍下redo日志，undo日志，回滚段（rollback segment）。</p><p><strong>为什么要有redo**</strong>日志？**</p><p>数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。磁盘<strong>随机写</strong>性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。</p><p>优化方式是，将修改行为先写到redo日志里（此时变成了<strong>顺序写</strong>），再定期将数据刷到磁盘上，这样能极大提高性能。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：这里的架构设计方法是，<strong>随机写优化为顺序写</strong>，思路更重要。</span></em></span></p><p>假如某一时刻，数据库崩溃，还没来得及刷盘的数据，在数据库重启后，会重做redo日志里的内容，以保证已提交事务对数据产生的影响都刷到磁盘上。</p><p><strong>一句话</strong>，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">redo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志</span></span>用于保障，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">已提交事务的</span>ACID<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">特性</span></span>。</p><p><strong>为什么要有undo**</strong>日志？**</p><p>数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，当事务回滚时，或者数据库奔溃时，可以利用undo日志，即旧版本数据，撤销未提交事务对数据库产生的影响。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：更细节的，</span></em></span></p><p><span style="color: rgb(0, 82, 255);"><em><span style="color: rgb(0, 82, 255);font-size: 14px;letter-spacing: 1px;"><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">对于</span><strong>insert<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">操作</span></strong><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，</span>undo<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志记录新数据的</span>PK(ROW_ID)<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，回滚时直接删除；</span></span></em></span></p><p><span style="color: rgb(0, 82, 255);"><em><span style="color: rgb(0, 82, 255);font-size: 14px;letter-spacing: 1px;"><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">对于</span><strong>delete/update<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">操作</span></strong><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，</span>undo<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志记录旧数据</span>row<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，回滚时直接恢复；</span></span></em></span></p><p><span style="color: rgb(0, 82, 255);"><em><span style="color: rgb(0, 82, 255);font-size: 14px;letter-spacing: 1px;"><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">他们分别存放在不同的</span>buffer<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">里。</span></span></em></span></p><p><strong>一句话</strong>，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">undo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志</span></span>用于保障，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">未提交事务不会对数据库的ACID特性</span>产生影响。</p><p><strong>什么是回滚段？</strong></p><p>存储undo日志的地方，是回滚段。</p><p>undo日志和回滚段和InnoDB的MVCC密切相关，这里举个例子展开说明一下。</p><p><strong>栗子</strong>：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">t</span>(<span class="name">id</span> PK, name)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>数据为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, shenjian</span><br><span class="line"><span class="number">2</span>, zhangsan</span><br><span class="line"><span class="number">3</span>, lisi</span><br></pre></td></tr></table></figure></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/854310171767639185.jpg" alt="">  </p><p>此时没有事务未提交，故回滚段是空的。</p><p>接着启动了一个事务：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> trx;</span><br><span class="line"><span class="keyword">delete</span> (<span class="number">1</span>, shenjian);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span>(<span class="number">3</span>, lisi) <span class="keyword">to</span> (<span class="number">3</span>, xxx);</span><br><span class="line"><span class="keyword">insert</span> (<span class="number">4</span>, wangwu);</span><br></pre></td></tr></table></figure></p><p>并且事务处于<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">未提交</span>的状态。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/76916220599096767.jpg" alt=""></p><p>可以看到：</p><p>(1)被<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">删除前</span>的(1, shenjian)作为旧版本数据，进入了回滚段；</p><p>(2)被<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">修改前</span>的(3, lisi)作为旧版本数据，进入了回滚段；</p><p>(3)被<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">插入的</span>数据，PK(4)进入了回滚段；</p><p>接下来，假如事务rollback，此时可以通过回滚段里的undo日志回滚。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-size: 14px;letter-spacing: 1px;"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">画外音：假设事务提交，回滚段里的</span>undo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志可以删除。</span></span></em></span></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/138982544617441980.jpg" alt=""></p><p>可以看到：</p><p>(1)被删除的旧数据恢复了；</p><p>(2)被修改的旧数据也恢复了；</p><p>(3)被插入的数据，删除了；</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/319830267672366053.jpg" alt="">  </p><p>事务回滚成功，一切如故。</p><p><strong>四、InnoDB**</strong>是基于多版本并发控制的存储引擎**</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961428&amp;idx=1&amp;sn=31a9eb967941d888fbd4bb2112e9602b&amp;chksm=bd2d0d888a5a849e7ebaa7756a8bc1b3d4e2f493f3a76383fc80f7e9ce7657e4ed2f6c01777d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">大数据量，高并发量的互联网业务，一定要使用InnoDB</a>》提到，InnoDB是高并发互联网场景最为推荐的存储引擎，根本原因，就是其<strong>多版本并发控制</strong>（Multi Version Concurrency Control, MVCC）。<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">行锁，并发，事务回滚</span>等多种特性都和MVCC相关。</p><p>MVCC就是通过“读取旧版本数据”来降低并发事务的锁冲突，提高任务的并发度。</p><p><strong>核心问题：</strong></p><p><strong>旧版本数据存储在哪里？</strong></p><p><strong>存储旧版本数据，对MySQL**</strong>和InnoDB<strong>**原有架构是否有巨大冲击？</strong></p><p>通过上文<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">undo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志</span></span>和<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">回滚段</span>的铺垫，这两个问题就非常好回答了：</p><p>(1)旧版本数据存储在回滚段里；</p><p>(2)对MySQL和InnoDB原有架构体系冲击不大；</p><p>InnoDB的内核，会对所有row数据增加三个内部属性：</p><p>(1)<strong>DB_TRX_ID</strong>，6字节，记录每一行最近一次修改它的事务ID；</p><p>(2)<strong>DB_ROLL_PTR</strong>，7字节，记录指向回滚段undo日志的指针；</p><p>(3)<strong>DB_ROW_ID</strong>，6字节，单调递增的行ID；</p><p><strong>InnoDB**</strong>为何能够做到这么高的并发？**</p><p>回滚段里的数据，其实是历史数据的<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;color: rgb(255, 76, 0);">快照</span>（snapshot），这些数据是不会被修改，select可以肆无忌惮的并发读取他们。</p><p><strong>快照读</strong>（Snapshot Read），这种<strong>一致性不加锁的读</strong>（Consistent Nonlocking Read），就是<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">InnoDB<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">并发如此之高的核心原因之一</span></span>。</p><p>这里的<strong>一致性</strong>是指，事务读取到的数据，要么是事务开始前就已经存在的数据（当然，是其他已提交事务产生的），要么是事务自身插入或者修改的数据。</p><p><strong>什么样的select**</strong>是快照读？**</p><p>除非显示加锁，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">普通的</span>select<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">语句都是快照读</span></span>，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>这里的<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">显示加锁，非快照读</span>是指：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span> **<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>**;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span> **<span class="keyword">for</span> <span class="keyword">update</span>**;</span><br></pre></td></tr></table></figure></p><p>问题来了，这些显示加锁的读，是什么读？会加什么锁？和事务的隔离级别又有什么关系？</p><p>本节的内容已经够多了，且听下回分解。</p><p><strong>总结</strong></p><p>(1)常见并发控制保证数据一致性的方法有<strong>锁</strong>，<strong>数据多版本</strong>；</p><p>(2)<strong>普通锁</strong><span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);font-family: 宋体;">串行</span>，<strong>读写锁</strong><span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);font-family: 宋体;">读读并行</span>，<strong>数据多版本</strong><span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);font-family: 宋体;">读写并行</span>；</p><p>(3)<strong>redo日志</strong>保证<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">已提交事务的</span>，设计思路是，通过顺序写替代随机写，提高并发；</p><p>(4)<strong>undo日志</strong>用来<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">回滚未提交的事务</span>，它存储在回滚段里；</p><p>(5)InnoDB是基于<strong>MVCC</strong>的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；</p><p>(6)InnoDB之所以并发高，<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">快照读不加锁</span>；</p><p>(7)InnoDB所有<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">普通</span>select<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">都是快照读</span></span>；</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-size: 14px;letter-spacing: 1px;"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">画外音：</span><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">本文的知识点均基于</span>MySQL5.6<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">。</span></span></em></span></p><p>希望大家有收获，下一篇继续深入InnoDB的<strong>锁</strong>。</p><p>希望通俗的技术文被更多人看到，求帮<strong>转</strong>。</p><p>相关文章：</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961428&amp;idx=1&amp;sn=31a9eb967941d888fbd4bb2112e9602b&amp;chksm=bd2d0d888a5a849e7ebaa7756a8bc1b3d4e2f493f3a76383fc80f7e9ce7657e4ed2f6c01777d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB，5项最佳实践，知其所以然？</a>》</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> InnoDB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java8 Lambda表达式</title>
      <link href="/2018/08/13/java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/08/13/java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><p>Java8发布已经有一段时间了，这次发布的改动比较大，很多人将这次改动与Java5的升级相提并论。Java8其中一个很重要的新特性就是lambda表达式，允许我们将行为传到函数中。想想看，在Java8<br>之前我们想要将行为传入函数，仅有的选择就是匿名内部类。Java8发布以后，lambda表达式将大量替代匿名内部类的使用，简化代码的同时，更突出了原来匿名内部类中最重要的那部分包含真正逻辑的代码。尤其是对于做数据的同学来说，当习惯使用类似scala之类的函数式编程语言以后，体会将更加深刻。现在我们就来看看Java8中lambda表达式的一些常见写法。</p><h2 id="1-替代匿名内部类"><a href="#1-替代匿名内部类" class="headerlink" title="1.替代匿名内部类"></a>1.替代匿名内部类</h2><p>毫无疑问，lambda表达式用得最多的场合就是替代匿名内部类，而实现Runnable接口是匿名内部类的经典例子。lambda表达式的功能相当强大，用()-&gt;就可以代替整个匿名内部类！请看代码：</p><p>如果使用匿名内部类：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">oldRunable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The old runable now is using!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而如果使用lambda表达式：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="literal">void</span> runable() &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"It's a lambda function!"</span>))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>最后的输出：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The old runable now <span class="keyword">is</span> <span class="keyword">using</span>!</span><br><span class="line">It<span class="comment">'s a lambda function!</span></span><br></pre></td></tr></table></figure></p><p>是不是强大到可怕？是不是简单到可怕？是不是清晰明了重点突出到可怕？这就是lambda表达式的可怕之处，用极少的代码完成了之前一个类做的事情！</p><h2 id="2-使用lambda表达式对集合进行迭代"><a href="#2-使用lambda表达式对集合进行迭代" class="headerlink" title="2.使用lambda表达式对集合进行迭代"></a>2.使用lambda表达式对集合进行迭代</h2><p>Java的集合类是日常开发中经常用到的，甚至说没有哪个java代码中没有使用到集合类。。。而对集合类最常见的操作就是进行迭代遍历了。请看对比：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> iterTest() &#123;</span><br><span class="line">    List&lt;String&gt; languages = Arrays.<span class="keyword">asList</span>(<span class="string">"java"</span>,<span class="string">"scala"</span>,<span class="string">"python"</span>);</span><br><span class="line">    <span class="comment">//before java8</span></span><br><span class="line">    <span class="keyword">for</span>(String <span class="keyword">each</span>:languages) &#123;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="keyword">each</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//after java8</span></span><br><span class="line">    languages.forEach(x -&gt; System.out.<span class="keyword">println</span>(x));</span><br><span class="line">    languages.forEach(System.out::<span class="keyword">println</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果熟悉scala的同学，肯定对forEach不陌生。它可以迭代集合中所有的对象，并且将lambda表达式带入其中。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">languages</span><span class="selector-class">.forEach</span>(<span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-pseudo">::println)</span>;</span><br></pre></td></tr></table></figure></p><p>这一行看起来有点像c++里面作用域解析的写法，在这里也是可以的。</p><h2 id="3-用lambda表达式实现map"><a href="#3-用lambda表达式实现map" class="headerlink" title="3.用lambda表达式实现map"></a>3.用lambda表达式实现map</h2><p>一提到函数式编程，一提到lambda表达式，怎么能不提map。。。没错，java8肯定也是支持的。请看示例代码：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@Test</span></span><br><span class="line">public void mapTest() &#123;</span><br><span class="line">    List&lt;Double&gt; cost = Arrays.asList(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment">    cost.stream().map(x -&gt; x + x*0.05).forEach(x -&gt; System.out.println(x));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p><p>最后的输出结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10<span class="selector-class">.5</span></span><br><span class="line">21<span class="selector-class">.0</span></span><br><span class="line">31<span class="selector-class">.5</span></span><br></pre></td></tr></table></figure></p><p>map函数可以说是函数式编程里最重要的一个方法了。map的作用是将一个对象变换为另外一个。在我们的例子中，就是通过map方法将cost增加了0,05倍的大小然后输出。</p><h2 id="4-用lambda表达式实现map与reduce"><a href="#4-用lambda表达式实现map与reduce" class="headerlink" title="4.用lambda表达式实现map与reduce"></a>4.用lambda表达式实现map与reduce</h2><p>既然提到了map，又怎能不提到reduce。reduce与map一样，也是函数式编程里最重要的几个方法之一。。。map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个，请看：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="literal">void</span> mapReduceTest() &#123;</span><br><span class="line">    List&lt;Double&gt; cost = Arrays.asList(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>);</span><br><span class="line">    double allCost = cost.stream<span class="function"><span class="params">()</span>.<span class="title">map</span><span class="params">(x -&gt; x+x*<span class="number">0.05</span>)</span>.<span class="title">reduce</span><span class="params">((sum,x) -&gt; sum + x)</span>.<span class="title">get</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(allCost)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>最终的结果为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">63<span class="selector-class">.0</span></span><br></pre></td></tr></table></figure></p><p>如果我们用for循环来做这件事情：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> sumTest() &#123;</span><br><span class="line">    List&lt;<span class="keyword">Double</span>&gt; cost = Arrays.<span class="keyword">asList</span>(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>);</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> <span class="keyword">each</span>:cost) &#123;</span><br><span class="line">        <span class="keyword">each</span> += <span class="keyword">each</span> * <span class="number">0.05</span>;</span><br><span class="line">        sum += <span class="keyword">each</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="keyword">println</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相信用map+reduce+lambda表达式的写法高出不止一个level。</p><h2 id="5-filter操作"><a href="#5-filter操作" class="headerlink" title="5.filter操作"></a>5.filter操作</h2><p>filter也是我们经常使用的一个操作。在操作集合的时候，经常需要从原始的集合中过滤掉一部分元素。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> filterTest() &#123;</span><br><span class="line">    List&lt;<span class="keyword">Double</span>&gt; cost = Arrays.<span class="keyword">asList</span>(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>,<span class="number">40.0</span>);</span><br><span class="line">    List&lt;<span class="keyword">Double</span>&gt; filteredCost = cost.stream().filter(x -&gt; x &gt; <span class="number">25.0</span>).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    filteredCost.forEach(x -&gt; System.out.<span class="keyword">println</span>(x));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30<span class="selector-class">.0</span></span><br><span class="line">40<span class="selector-class">.0</span></span><br></pre></td></tr></table></figure></p><p>将java写出了python或者scala的感觉有没有！是不是帅到爆！</p><h2 id="6-与函数式接口Predicate配合"><a href="#6-与函数式接口Predicate配合" class="headerlink" title="6.与函数式接口Predicate配合"></a>6.与函数式接口Predicate配合</h2><p>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。Predicate接口非常适用于做过滤。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> filterTest(List&lt;<span class="keyword">String</span>&gt; languages, Predicate&lt;<span class="keyword">String</span>&gt; condition) &#123;</span><br><span class="line">    languages.stream().<span class="built_in">filter</span>(x -&gt; condition.test(x)).forEach(x -&gt; System.out.<span class="built_in">println</span>(x + <span class="string">" "</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; languages = Arrays.asList(<span class="string">"Java"</span>,<span class="string">"Python"</span>,<span class="string">"scala"</span>,<span class="string">"Shell"</span>,<span class="string">"R"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Language starts with J: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; x.startsWith(<span class="string">"J"</span>));</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Language ends with a: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; x.endsWith(<span class="string">"a"</span>));</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"All languages: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; <span class="keyword">true</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"No languages: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; <span class="keyword">false</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Language length bigger three: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; x.length() &gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的输出结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Language starts with <span class="keyword">J: </span></span><br><span class="line"><span class="keyword">Java </span></span><br><span class="line"></span><br><span class="line">Language ends with a: </span><br><span class="line"><span class="keyword">Java </span></span><br><span class="line"><span class="keyword">scala </span></span><br><span class="line"></span><br><span class="line">All languages: </span><br><span class="line"><span class="keyword">Java </span></span><br><span class="line">Python </span><br><span class="line"><span class="keyword">scala </span></span><br><span class="line"><span class="keyword">Shell </span></span><br><span class="line">R </span><br><span class="line"></span><br><span class="line">No languages: </span><br><span class="line"></span><br><span class="line">Language length <span class="keyword">bigger </span>three: </span><br><span class="line">Python </span><br><span class="line"><span class="keyword">scala </span></span><br><span class="line"><span class="keyword">Shell</span></span><br></pre></td></tr></table></figure><p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这也是lambda表达式的魔力！</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p>1.<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">《Java8 lambda表达式10个示例》</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk1.8 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（添加网页标题崩溃欺骗搞怪特效）</title>
      <link href="/2018/08/13/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E6%A0%87%E9%A2%98%E5%B4%A9%E6%BA%83%E6%AC%BA%E9%AA%97%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88%EF%BC%89/"/>
      <url>/2018/08/13/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E6%A0%87%E9%A2%98%E5%B4%A9%E6%BA%83%E6%AC%BA%E9%AA%97%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span></span><br><a id="more"></a></p><h1 id="crash-cheat-js"><a href="#crash-cheat-js" class="headerlink" title="crash_cheat.js"></a><a href="#crash-cheat-js" title="crash_cheat.js"></a>crash_cheat.js</h1><p>在<code>next\source\js\src</code>文件夹下创建<code>crash_cheat.js</code>，添加代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--崩溃欺骗--&gt;</span><br><span class="line"><span class="keyword">var</span> OriginTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        $(<span class="string">'[rel="icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/img/TEP.ico"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'╭(°A°`)╮ 页面崩溃啦 ~'</span>;</span><br><span class="line">        clearTimeout(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">'[rel="icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/favicon.ico"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'(ฅ&gt;ω&lt;*ฅ) 噫又好了~'</span> + OriginTitle;</span><br><span class="line">        titleTime = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = OriginTitle;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a><a href="#引用" title="引用"></a>引用</h1><p>在<code>next\layout\_layout.swig</code>文件中，添加引用（注：在swig末尾添加）：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--崩溃欺骗--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/crash_cheat.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端杂记</title>
      <link href="/2018/08/13/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%AE%B0/"/>
      <url>/2018/08/13/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><ol><li><p>正则验证</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regIdNo = /(^\d&#123;<span class="number">15</span>&#125;$)|(^\d&#123;<span class="number">18</span>&#125;$)|(^\d&#123;<span class="number">17</span>&#125;(\d|X|x)$)/; </span><br><span class="line"><span class="keyword">let</span> regtel=/^[<span class="number">1</span>][<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">9</span>&#125;$/;</span><br><span class="line"><span class="keyword">let</span> reglicence = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;<span class="number">1</span>&#125;[A-Z]&#123;<span class="number">1</span>&#125;[A-Z<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">4</span>&#125;[A-Z<span class="number">0</span>-<span class="number">9</span>挂学警港澳]&#123;<span class="number">1</span>&#125;$/;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!regtel.test(<span class="string">'##############'</span>)) &#123;</span><br><span class="line">    alert(<span class="string">'手机号格式有误'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!regIdNo.test(<span class="string">'##############'</span>))&#123;  </span><br><span class="line"> alert(<span class="string">'身份证号填写有误'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!reglicence.test(<span class="string">'##########'</span>))&#123;</span><br><span class="line">alert(<span class="string">'身份证号填写有误'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合快速去除（ES6）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.from(<span class="keyword">new</span> <span class="type">Set</span>(a))</span><br></pre></td></tr></table></figure></li><li><p>获取当前项目的路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> urlRootContext = (function () &#123;</span><br><span class="line">  <span class="selector-tag">var</span> strPath = window<span class="selector-class">.document</span><span class="selector-class">.location</span><span class="selector-class">.pathname</span></span><br><span class="line">  <span class="selector-tag">var</span> postPath = strPath.substring(<span class="number">0</span>, strPath.substr(<span class="number">1</span>).indexOf(<span class="string">'/'</span>) + <span class="number">1</span>)</span><br><span class="line">  return postPath</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5 file API加canvas实现图片前端JS压缩并上传</title>
      <link href="/2018/08/10/HTML5%20file%20API%E5%8A%A0canvas%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%89%8D%E7%AB%AFJS%E5%8E%8B%E7%BC%A9%E5%B9%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2018/08/10/HTML5%20file%20API%E5%8A%A0canvas%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%89%8D%E7%AB%AFJS%E5%8E%8B%E7%BC%A9%E5%B9%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a><br>by <a href="http://www.zhangxinxu.com/" target="_blank" rel="noopener">zhangxinxu</a> from <a href="http://www.zhangxinxu.com/wordpress/?p=6308" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=6308</a><br>本文可全文转载，但需得到原作者书面许可，同时保留原作者和出处，摘要引流则随意。</span></p><h3 id="一、图片上传前端压缩的现实意义"><a href="#一、图片上传前端压缩的现实意义" class="headerlink" title="一、图片上传前端压缩的现实意义"></a>一、图片上传前端压缩的现实意义</h3><p>对于大尺寸图片的上传，在前端进行压缩除了省流量外，最大的意义是极大的提高了用户体验。</p><p>这种体验包括两方面：</p><ol><li>由于上传图片尺寸比较小，因此上传速度会比较快，交互会更加流畅，同时大大降低了网络异常导致上传失败风险。</li><li>最最重要的体验改进点：省略了图片的再加工成本。很多网站的图片上传功能都会对图片的大小进行限制，尤其是头像上传，限制5M或者2M以内是非常常见的。然后现在的数码设备拍摄功能都非常出众，一张原始图片超过2M几乎是标配，此时如果用户想把手机或相机中的某个得意图片上传作为自己的头像，就会遇到因为图片大小限制而不能上传的窘境，不得不对图片进行再处理，而这种体验其实非常不好的。如果可以在前端进行压缩，则理论上对图片尺寸的限制是没有必要的。</li></ol><h3 id="二、图片前端JS压缩并上传功能体验"><a href="#二、图片前端JS压缩并上传功能体验" class="headerlink" title="二、图片前端JS压缩并上传功能体验"></a>二、图片前端JS压缩并上传功能体验</h3><p>特意制作了一个图片前端压缩并上传的完整demo，您可以狠狠的点击这里：<a href="http://www.zhangxinxu.com/study/201707/js-compress-image-before-upload.html" target="_blank" rel="noopener">使用canvas在前端压缩图片并上传demo</a></p><p>进入demo会看到一个相貌平平的文件输入框：</p><p><img src="//image.zhangxinxu.com/image/blog/201707/gutianlle.jpg" alt="相貌平平"></p><p>啊，不对，应该是这张图：</p><p><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_221637.png" alt="相貌平平文件选择框"></p><p>点击文件选择框，我们不妨选一张尺寸比较大的图片，例如下面这种2M多的钓鱼收获照：</p><p><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_221955.png" alt="上传演示使用的图片"></p><p>于是图片歘歘歘地传上去了：<br><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_222424.png" alt="上传相关信息截图"></p><p>此时我们点击最终上传完毕的图片地址，会发现原来2M多3000多像素宽的图片被限制为400像素宽了：<br><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_222714s.jpg" alt="图片缩小后在浏览器中的预览效果图"></p><p>保存到本地会发现图片尺寸已经变成只有70K了：<br><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_223016.jpg" alt="保存到本地显示的图片尺寸"></p><p>以上就是图片前端压缩并上传demo的完整演示。</p><h3 id="三、HTML5-file-API加canvas实现图片前端JS压缩"><a href="#三、HTML5-file-API加canvas实现图片前端JS压缩" class="headerlink" title="三、HTML5 file API加canvas实现图片前端JS压缩"></a>三、HTML5 file API加canvas实现图片前端JS压缩</h3><p>要想使用JS实现图片的压缩效果，原理其实很简单，核心API就是使用<code>canvas</code>的<code>drawImage()</code>方法。</p><p><code>canvas</code>的<code>drawImage()</code>方法API如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">context</span>.drawImage(img, dx, dy)<span class="comment">;</span></span><br><span class="line"><span class="built_in">context</span>.drawImage(img, dx, dy, dWidth, dHeight)<span class="comment">;</span></span><br><span class="line"><span class="built_in">context</span>.drawImage(img, sx, sy, <span class="keyword">sWidth, </span><span class="keyword">sHeight, </span>dx, dy, dWidth, dHeight)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>后面最复杂的语法虽然看上去有9大参数，但不用慌，实际上可以看出就3个参数：</p><p><strong>img</strong></p><p>就是图片对象，可以是页面上获取的DOM对象，也可以是虚拟DOM中的图片对象。</p><p><strong>dx, dy, dWidth, dHeight</strong></p><p>表示在<code>canvas</code>画布上规划处一片区域用来放置图片，<code>dx, dy</code>为canvas元素的左上角坐标，<code>dWidth, dHeight</code>指canvas元素上用在显示图片的区域大小。如果没有指定<code>sx,sy,sWidth,sHeight</code>这4个参数，则图片会被拉伸或缩放在这片区域内。</p><p><strong>sx,sy,swidth,sheight</strong></p><p>这4个坐标是针对图片元素的，表示图片在<code>canvas</code>画布上显示的大小和位置。<code>sx,sy</code>表示图片上<code>sx,sy</code>这个坐标作为左上角，然后往右下角的<code>swidth,sheight</code>尺寸范围图片作为最终在canvas上显示的图片内容。</p><p><code>drawImage()</code>方法有一个非常怪异的地方，大家一定要注意，那就是5参数和9参数里面参数位置是不一样的，这个和一般的API有所不同。一般API可选参数是放在后面。但是，这里的<code>drawImage()</code>9个参数时候，可选参数<code>sx,sy,swidth,sheight</code>是在前面的。如果不注意这一点，有些表现会让你无法理解。</p><p>下图为<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" target="_blank" rel="noopener">MDN</a>上原理示意：<br><img src="//image.zhangxinxu.com/image/blog/201711/Canvas_drawimage.jpg" alt="Canvas drawimage()原理示意"></p><p>对于本文的图片压缩，需要用的是是5个参数语法。举个例子，一张图片（假设图片对象是<code>img</code>）的原始尺寸是4000*3000，现在需要把尺寸限制为400*300大小，很简单，原理如下代码示意：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.createElement('canvas');</span><br><span class="line">var context = canvas.getContext('<span class="number">2</span>d');</span><br><span class="line">canvas.width = <span class="number">400</span>;</span><br><span class="line">canvas.height = <span class="number">300</span>;</span><br><span class="line"><span class="comment">// 核心JS就这个</span></span><br><span class="line">context.drawImage(img,<span class="number">0</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><p>把一张大的图片，直接画在一张小小的画布上。此时大图片就天然变成了小图片，压缩就这么实现了，是不是简单的有点超乎想象。</p><p>当然，若要落地于实际开发，我们还需要做些其他的工作，就是要解决图片来源和图片去向的问题。</p><h4 id="1-如何把系统中图片呈现在浏览器中？"><a href="#1-如何把系统中图片呈现在浏览器中？" class="headerlink" title="1. 如何把系统中图片呈现在浏览器中？"></a>1. 如何把系统中图片呈现在浏览器中？</h4><p>HTML5 file API可以让图片在上传之前直接在浏览器中显示，通常使用<code>FileReader</code>方法，代码示意如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(), img = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="comment">// 读文件成功的回调</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// e.target.result就是图片的base64地址信息</span></span><br><span class="line">  img.src = e.target.result;</span><br><span class="line">&#125;;</span><br><span class="line">eleFile.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span><br><span class="line">    reader.readAsDataURL(event.target.files\[<span class="number">0</span>\]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>于是，包含图片信息的<code>context.drawImage()</code>方法中的<code>img</code>图片就有了。</p><p><strong>2. 如果把canvas画布转换成img图像</strong><br><code>canvas</code>天然提供了2个转图片的方法，一个是：</p><p><strong>canvas.toDataURL()方法</strong></p><p>语法如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span>.toDataURL(mimeType, qualityArgument)</span><br></pre></td></tr></table></figure></p><p>可以把图片转换成base64格式信息，纯字符的图片表示法。</p><p>其中：<br><code>mimeType</code>表示<code>canvas</code>导出来的<code>base64</code>图片的类型，默认是png格式，也即是默认值是<code>&#39;image/png&#39;</code>，我们也可以指定为jpg格式<code>&#39;image/jpeg&#39;</code>或者webp等格式。<code>file</code>对象中的<code>file.type</code>就是文件的mimeType类型，在转换时候正好可以直接拿来用（如果有file对象）。<br><code>qualityArgument</code>表示导出的图片质量，只要导出为<code>jpg</code>和<code>webp</code>格式的时候此参数才有效果，默认值是<code>0.92</code>，是一个比较合理的图片质量输出参数，通常情况下，我们无需再设定。</p><p><strong>canvas.toBlob()方法</strong></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob" target="_blank" rel="noopener">语法</a>如下：</p><p>canvas.toBlob(callback, mimeType, qualityArgument)</p><p>可以把canvas转换成<a href="http://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/" target="_blank" rel="noopener">Blob文件</a>，通常用在文件上传中，因为是二进制的，对后端更加友好。</p><p>和<code>toDataURL()</code>方法相比，<code>toBlob()</code>方法是异步的，因此多了个<code>callback</code>参数，这个<code>callback</code>回调方法默认的第一个参数就是转换好的<code>blob</code>文件信息，本文demo的文件上传就是将<code>canvas</code>图片转换成二进制的<code>blob</code>文件，然后再<code>ajax</code>上传的，代码如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// canvas转为blob并上传</span><br><span class="line">canvas.toBlob(function (blob) &#123;</span><br><span class="line">  // 图片ajax上传</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line">  // 开始上传</span><br><span class="line">  xhr.open(<span class="string">"<span class="keyword">POST</span>"</span>, 'upload.php', true);</span><br><span class="line">  xhr.send(blob);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>于是，经过“图片→canvas压缩→图片”三步曲，我们完成了图片前端压缩并上传的功能。</p><p>更加完整的核心代码请参见<a href="http://www.zhangxinxu.com/study/201707/js-compress-image-before-upload.html" target="_blank" rel="noopener">demo页面</a>的左侧，如果对其他交互代码也敢兴趣，请参考页面源代码。</p><p>下面贴出完整代码：</p><p><strong>HTML代码：</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="attribute">id</span>=<span class="string">"file"</span> <span class="attribute">type</span>=<span class="string">"file"</span>&gt;</span><br></pre></td></tr></table></figure></p><p><strong>JS代码：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eleFile = <span class="built_in">document</span>.querySelector(<span class="string">'#file'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩图片需要的一些元素和对象</span></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(), img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择的文件对象</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放图片需要的canvas</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// base64地址图片加载完毕后</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 图片原始尺寸</span></span><br><span class="line">    <span class="keyword">var</span> originWidth = <span class="keyword">this</span>.width;</span><br><span class="line">    <span class="keyword">var</span> originHeight = <span class="keyword">this</span>.height;</span><br><span class="line">    <span class="comment">// 最大尺寸限制</span></span><br><span class="line">    <span class="keyword">var</span> maxWidth = <span class="number">400</span>, maxHeight = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 目标尺寸</span></span><br><span class="line">    <span class="keyword">var</span> targetWidth = originWidth, targetHeight = originHeight;</span><br><span class="line">    <span class="comment">// 图片尺寸超过400x400的限制</span></span><br><span class="line">    <span class="keyword">if</span> (originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123;</span><br><span class="line">        <span class="keyword">if</span> (originWidth / originHeight &gt; maxWidth / maxHeight) &#123;</span><br><span class="line">            <span class="comment">// 更宽，按照宽度限定尺寸</span></span><br><span class="line">            targetWidth = maxWidth;</span><br><span class="line">            targetHeight = <span class="built_in">Math</span>.round(maxWidth * (originHeight / originWidth));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetHeight = maxHeight;</span><br><span class="line">            targetWidth = <span class="built_in">Math</span>.round(maxHeight * (originWidth / originHeight));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// canvas对图片进行缩放</span></span><br><span class="line">    canvas.width = targetWidth;</span><br><span class="line">    canvas.height = targetHeight;</span><br><span class="line">    <span class="comment">// 清除画布</span></span><br><span class="line">    context.clearRect(<span class="number">0</span>, <span class="number">0</span>, targetWidth, targetHeight);</span><br><span class="line">    <span class="comment">// 图片压缩</span></span><br><span class="line">    context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, targetWidth, targetHeight);</span><br><span class="line">    <span class="comment">// canvas转为blob并上传</span></span><br><span class="line">    canvas.toBlob(<span class="function"><span class="keyword">function</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 图片ajax上传</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="comment">// 文件上传成功</span></span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">// xhr.responseText就是返回的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开始上传</span></span><br><span class="line">        xhr.open(<span class="string">"POST"</span>, <span class="string">'upload.php'</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.send(blob);    </span><br><span class="line">    &#125;, file.type || <span class="string">'image/png'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件base64化，以便获知图片原始尺寸</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    img.src = e.target.result;</span><br><span class="line">&#125;;</span><br><span class="line">eleFile.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    file = event.target.files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 选择的文件是图片</span></span><br><span class="line">    <span class="keyword">if</span> (file.type.indexOf(<span class="string">"image"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        reader.readAsDataURL(file);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h3><p>就在几个月前刚写过一篇文章“<a href="http://www.zhangxinxu.com/wordpress/?p=6165" target="_blank" rel="noopener">使用canvas在前端实现图片水印合成</a>”，实际上所使用的技术和套路和本文是如出一辙的，也是“图片→canvas水印→图片”三步曲，区别在于水印合成是连续执行两次<code>context.drawImage()</code>方法，一次是原图一次水印图片，以及最后转换成图片的时候什么是<code>toDataURL()</code>方法，其他代码逻辑和原理都是一样的。</p><p>由此及彼，利用同样的原理和代码逻辑，我们还可以实现其它很多以前前端不太好实现的功能，比方说图片的真剪裁效果，所谓“真剪裁”指不是使用个<code>overflow:hidden</code>或者<code>clip</code>这些CSS属性的“伪剪裁”，而是真正意义上就这么大区域图片信息。甚至配合一些前端算法，我们可以直接在前端进行人脸识别，图片自动美化等一系列功能再上传等等。</p><p>原理都是一样的，都是利用<code>canvas</code>作为中间媒介进行处理。</p><p>好，以上就是本文的全部内容，感谢阅读，欢迎纠错，欢迎交流！</p><p><img src="//image.zhangxinxu.com/image/blog/201611/14.png" alt=""></p><p>本文为原创文章，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。<br>本文地址：<a href="http://www.zhangxinxu.com/wordpress/?p=6308" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=6308</a></p><p>相关文章</p><ul><li><a href="https://www.zhangxinxu.com/wordpress/2013/11/xmlhttprequest-ajax-localstorage-%e6%96%87%e4%bb%b6%e6%96%ad%e7%82%b9%e7%bb%ad%e4%bc%a0/" target="_blank" rel="noopener">XMLHttpRequest实现HTTP协议下文件上传断点续传</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2015/11/html-input-type-file/" target="_blank" rel="noopener">HTML input type=file文件选择表单元素二三事</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2018/05/js-custom-gif-generate/" target="_blank" rel="noopener">纯前端实现可传图可字幕台词定制的GIF表情生成器</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2018/03/js-parse-text-file/" target="_blank" rel="noopener">小tips: 纯前端JS读取与解析本地文本类文件</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2009/11/ajax-upload%e5%a4%9a%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e6%8f%92%e4%bb%b6%e7%bf%bb%e8%af%91%e5%8f%8a%e4%b8%ad%e6%96%87%e6%bc%94%e7%a4%ba/" target="_blank" rel="noopener">Ajax Upload多文件上传插件翻译及中文演示</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/" target="_blank" rel="noopener">理解DOMString、Document、FormData、Blob、File、ArrayBuffer数据类型</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2011/09/%e5%9f%ba%e4%ba%8ehtml5%e7%9a%84%e5%8f%af%e9%a2%84%e8%a7%88%e5%a4%9a%e5%9b%be%e7%89%87ajax%e4%b8%8a%e4%bc%a0/" target="_blank" rel="noopener">基于HTML5的可预览多图片Ajax上传</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/05/canvas-picture-watermark-synthesis/" target="_blank" rel="noopener">小tips:使用canvas在前端实现图片水印合成</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2018/08/js-base64-atob-btoa-encode-decode/" target="_blank" rel="noopener">原来浏览器原生支持JS Base64编码解码</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/07/js-text-string-download-as-html-json-file/" target="_blank" rel="noopener">小tip:JS前端创建html或json文件并浏览器导出下载</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/08/svg-foreignobject/" target="_blank" rel="noopener">SVG <foreignobject>简介与截图等应用</foreignobject></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> file </tag>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在HTML在线预览PDF、word、xls、ppt等文件</title>
      <link href="/2018/08/09/%E5%9C%A8HTML%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88PDF%E3%80%81word%E3%80%81xls%E3%80%81ppt%E7%AD%89%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/09/%E5%9C%A8HTML%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88PDF%E3%80%81word%E3%80%81xls%E3%80%81ppt%E7%AD%89%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h2 id="html实现pdf文件在线预览功能"><a href="#html实现pdf文件在线预览功能" class="headerlink" title="html实现pdf文件在线预览功能"></a>html实现pdf文件在线预览功能</h2><h3 id="方式一、-lt-a-gt-标签"><a href="#方式一、-lt-a-gt-标签" class="headerlink" title="方式一、&lt;a&gt;标签"></a>方式一、<code>&lt;a&gt;</code>标签</h3><p>pdf文件理论上可以在浏览器直接打开预览但是需要打开新页面。在仅仅是预览pdf文件且UI要求不高的情况下可以直接通过a标签href属性实现预览<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"文档地址"</span>&gt;</span>预览pdf<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="方式二、jquery-media-js"><a href="#方式二、jquery-media-js" class="headerlink" title="方式二、jquery.media.js"></a>方式二、jquery.media.js</h3><p>通过jquery插件<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fmalsup%2Fmedia%2Fblob%2Fmaster%2Fjquery.media.js" target="_blank" rel="noopener">jquery.media.js</a>实现</p><p>这个插件可以实现pdf预览功能（包括其他各种<a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.jb51.net%2Farticle%2F58724.htm" target="_blank" rel="noopener">媒体文件</a>）但是对word等类型的文件无能为力。</p><p>实现方式：</p><p>js代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”</span> <span class="attr">src</span>=<span class="string">”jquery-1.7.1.min.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”</span> <span class="attr">src</span>=<span class="string">”jquery.media.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>html结构：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"handout_wrap_inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>调用方式：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#handout_wrap_inner'</span>).media(&#123;</span><br><span class="line">  <span class="built_in">width</span>: <span class="string">'100%'</span>,</span><br><span class="line">  <span class="built_in">height</span>: <span class="string">'100%'</span>,</span><br><span class="line">  autoplay: <span class="keyword">true</span>,</span><br><span class="line">  src:<span class="string">'http://storage.xuetangx.com/public_assets/xuetangx/PDF/PlayerAPI_v1.0.6.pdf'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="方式三、-lt-iframe-gt-标签"><a href="#方式三、-lt-iframe-gt-标签" class="headerlink" title="方式三、&lt;iframe&gt;标签"></a>方式三、<code>&lt;iframe&gt;</code>标签</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$("<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">'previewUrl'</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">'100%'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>").append($('body'))</span><br></pre></td></tr></table></figure><p>此外还可以在<code>iframe</code>标签之间提供一个提示类似这样<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"previewUrl"</span> width=<span class="string">"100%"</span> height=<span class="string">"100%"</span>&gt;</span><br><span class="line">  This browser does <span class="keyword">not</span> support PDFs. </span><br><span class="line">  Please download <span class="keyword">the</span> PDF <span class="built_in">to</span> view <span class="keyword">it</span>: </span><br><span class="line">  &lt;<span class="keyword">a</span> href=<span class="string">"previewUrl"</span>&gt;Download PDF&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><h3 id="方式四、-lt-embed-gt-标签"><a href="#方式四、-lt-embed-gt-标签" class="headerlink" title="方式四、&lt;embed&gt;标签"></a>方式四、<code>&lt;embed&gt;</code>标签</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;embed <span class="attribute">src</span>=<span class="string">"previewUrl"</span> <span class="attribute">type</span>=<span class="string">"application/pdf"</span> <span class="attribute">width</span>=<span class="string">"100%"</span> <span class="attribute">height</span>=<span class="string">"100%"</span>&gt;</span><br></pre></td></tr></table></figure><p>此标签h5特性中包含四个属性：高、宽、类型、预览文件src！<br>与<code>&lt;iframe&gt;&lt;/iframe&gt;</code>不同，这个标签是自闭合的的，也就是说如果浏览器不支持PDF的嵌入，那么这个标签的内容什么都看不到！</p><h3 id="方式五、-lt-object-gt-标签"><a href="#方式五、-lt-object-gt-标签" class="headerlink" title="方式五、&lt;object&gt;标签"></a>方式五、<code>&lt;object&gt;</code>标签</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;object src=<span class="string">"previewUrl"</span> width=<span class="string">"100%"</span> height=<span class="string">"100%"</span>&gt;</span><br><span class="line">  This browser does <span class="keyword">not</span> support PDFs. </span><br><span class="line">  Please download <span class="keyword">the</span> PDF <span class="built_in">to</span> view <span class="keyword">it</span>: </span><br><span class="line">  &lt;<span class="keyword">a</span> href=<span class="string">"previewUrl"</span>&gt;Download PDF&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line">&lt;/object&gt;</span><br></pre></td></tr></table></figure><div class="note warning"><p>除方式二以外其他都是直接通过标签将内容引入页面实现预览</p></div><h3 id="方式六、PDFObject"><a href="#方式六、PDFObject" class="headerlink" title="方式六、PDFObject"></a>方式六、PDFObject</h3><p>PDFObject实际上也是通过<code>&lt;embed&gt;</code>标签实现的直接上代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Show PDF<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'pdfobject.min.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-id">#pdf_viewer</span>&#123;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="undefined">            margin: 0;</span></span><br><span class="line"><span class="undefined">            padding: 0;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pdf_viewer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(PDFObject.supportsPDFs)&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// PDF嵌入到网页</span></span></span><br><span class="line"><span class="actionscript">        PDFObject.embed(<span class="string">"index.pdf"</span>, <span class="string">"#pdf_viewer"</span> );</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        location.href = <span class="string">"/canvas"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>还可以通过以下代码进行判断是否支持PDFObject预览<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(PDFObject.supportsPDFs)&#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="string">"Yay, this browser supports inline PDFs."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="string">"Boo, inline PDFs are not supported by this browser"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="方式七、PDF-js"><a href="#方式七、PDF-js" class="headerlink" title="方式七、PDF.js"></a>方式七、PDF.js</h3><p>PDF.js可以实现在html下直接浏览pdf文档，是一款开源的pdf文档读取解析插件，非常强大，能将PDF文件渲染成Canvas。PDF.js主要包含两个库文件，一个pdf.js和一个pdf.worker.js，一个负责API解析，一个负责核心解析。</p><h2 id="word、xls、ppt文件在线预览功能"><a href="#word、xls、ppt文件在线预览功能" class="headerlink" title="word、xls、ppt文件在线预览功能"></a>word、xls、ppt文件在线预览功能</h2><p>word、ppt、xls文件实现在线预览的方式比较简单可以直接通过调用微软的在线预览功能实现 (预览前提：资源必须是公共可访问的)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">iframe</span> src=<span class="string">'https://view.officeapps.live.com/op/view.aspx?src=http://storage.xuetangx.com/public_assets/xuetangx/PDF/1.xls'</span> <span class="attribute">width</span>=<span class="string">'100%'</span> height=<span class="string">'100%'</span> frameborder=<span class="string">'1'</span>&gt;</span><br><span class="line">&lt;/iframe</span><br></pre></td></tr></table></figure></p><p>src就是要实现预览的文件地址</p><p>具体文档看这<a href="https://link.jianshu.com?t=https%3A%2F%2Fblogs.office.com%2Fen-us%2F2013%2F04%2F10%2Foffice-web-viewer-view-office-documents-in-a-browser%2F%3Feu%3Dtrue" target="_blank" rel="noopener">微软接口文档</a></p><h2 id="word文件"><a href="#word文件" class="headerlink" title="word文件"></a>word文件</h2><p><a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.xdocin.com%2Fweb.html%23func" target="_blank" rel="noopener">XDOC</a>可以实现预览以<a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fchenjiaxiang520%2Farticle%2Fdetails%2F53891544" target="_blank" rel="noopener">DataURI</a>表示的DOC文档，此外XDOC还可以实现文本、带参数文本、html文本、json文本、公文等在线预览，具体实现方法请看官方文档</p><p>下面这种方式可以实现快速预览word但是对文件使用的编辑器可能会有一些限制<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"http://www.xdocin.com/xdoc?_func=to&amp;amp;_format=html&amp;amp;_cache=1&amp;amp;_xdoc=http://www.xdocin.com/demo/demo.docx"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span> <span class="attribute">rel</span>=<span class="string">"nofollow"</span>&gt;XDOC&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> js </tag>
            
            <tag> office </tag>
            
            <tag> pdf </tag>
            
            <tag> word </tag>
            
            <tag> xls </tag>
            
            <tag> ppt </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（主题内加入动态背景）</title>
      <link href="/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E5%86%85%E5%8A%A0%E5%85%A5%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF%EF%BC%89/"/>
      <url>/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E5%86%85%E5%8A%A0%E5%85%A5%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h4 id="添加静态背景"><a href="#添加静态背景" class="headerlink" title="添加静态背景"></a>添加静态背景</h4><ol><li>打开博客根目录/themes/next/source/css/_custom/custom.styl文件，编辑如下：</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Custom styles.</span></span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line"><span class="attribute">background-image</span>: url(/images/background.png);</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; <span class="comment">// 不随屏幕滚动而滚动</span></span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat; <span class="comment">// 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺</span></span><br><span class="line"><span class="comment">//background-size: contain; // 等比例铺满屏幕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将背景图命名为background.png并放入主题根目录/images下</li></ol><h4 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h4><h1 id="layout-swig"><a href="#layout-swig" class="headerlink" title="_layout.swig"></a><a href="#layout-swig" title="_layout.swig"></a>_layout.swig</h1><p>找到<code>themes\next\layout\_layout.swig</code>文件，添加内容：<br>在<code>&lt;body&gt;</code>里添加：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"bg_content"</span>&gt;</span><br><span class="line">  &lt;canvas id=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>仍是该文件，在末尾添加：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/dynamic_bg.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-bg-js"><a href="#dynamic-bg-js" class="headerlink" title="dynamic_bg.js"></a><a href="#dynamic-bg-js" title="dynamic_bg.js"></a>dynamic_bg.js</h1><p>在<code>themes\next\source\js\src</code>中新建文件<code>dynamic_bg.js</code>，代码链接中可见：<a href="https://github.com/asdfv1929/asdfv1929.github.io/blob/master/js/src/dynamic_bg.js" target="_blank" rel="noopener">dynamic_bg.js</a></p><h1 id="custom-styl"><a href="#custom-styl" class="headerlink" title="custom.styl"></a><a href="#custom-styl" title="custom.styl"></a>custom.styl</h1><p>在<code>themes\next\source\css\_custom\custom.styl</code>文件末尾添加内容：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg_content</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（添加网页音乐播放器功能）</title>
      <link href="/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
      <url>/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%8A%9F%E8%83%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a><br>效果图：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/music01.png" alt=""></span></p><h1 id="download"><a href="#download" class="headerlink" title="download"></a><a href="#download" title="download"></a>download</h1><p>点击访问Aplayer源码：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">GitHub Aplayer</a>。下载到本地，解压后将<code>dist</code>文件夹复制到<code>themes\next\source</code>文件夹下。</p><h1 id="music-js"><a href="#music-js" class="headerlink" title="music.js"></a><a href="#music-js" title="music.js"></a>music.js</h1><p>新建<code>themes\next\source\dist\music.js</code>文件，添加内容：  </p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const ap = new APlayer(&#123;</span><br><span class="line">    <span class="attribute">container</span>: document<span class="variable">.getElementById</span>('aplayer'),</span><br><span class="line">    fixed: true,</span><br><span class="line">    autoplay: false,</span><br><span class="line">    audio: [</span><br><span class="line">&#123;</span><br><span class="line">        name: "canon in d",</span><br><span class="line">        artist: 'Brian Crain',</span><br><span class="line">        url: 'http://pd2tflnys<span class="variable">.bkt</span><span class="variable">.clouddn</span><span class="variable">.com</span>/Brian%20Crain%20-%20canon%20in%20d<span class="variable">.mp</span>3',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/QGb9Vtyw7qHS00uEvPfM6g==/843325418547559<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        name: "Apologize",</span><br><span class="line">        artist: 'Martin Ermen',</span><br><span class="line">        url: 'http://pd2tflnys<span class="variable">.bkt</span><span class="variable">.clouddn</span><span class="variable">.com</span>/Martin%20Ermen%20-%20Apologize<span class="variable">.mp</span>3',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/-_6mcI4VV5IKaiwhUAytbg==/1791104441647901<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        name: "River Flows in You",</span><br><span class="line">        artist: 'Yiruma',</span><br><span class="line">        url: 'http://pd2tflnys<span class="variable">.bkt</span><span class="variable">.clouddn</span><span class="variable">.com</span>/Yiruma%20-%20River%20Flows%20in%20You<span class="variable">.flac</span>',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/8ZRSyI0ZN_4ah8uzsNd1mA==/2324367581169008<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: '惊蛰',</span><br><span class="line">        artist: '音阙诗听/王梓钰',</span><br><span class="line">        url: 'http://www<span class="variable">.ytmp</span>3<span class="variable">.cn</span>/down/48755<span class="variable">.mp</span>3',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/5MmXpaP9r88tNzExPGMI8Q==/109951163370350985<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>源码中对应的参数解释，这边都有： <a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">Aplayer 中文文档</a></p><p><code>audio</code>对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：<a href="http://up.mcyt.net/" target="_blank" rel="noopener">http://up.mcyt.net/</a> ，搜索对应的音乐，然后复制<code>url</code>和右击封面图片链接粘贴到对应的位置上就行了。</p><p>注：由于该外链网站没有歌词链接，我这边没有进行配置，所以播放器在播放音乐时点击歌词是没有显示的。</p><h1 id="layout-swig"><a href="#layout-swig" class="headerlink" title="_layout.swig"></a><a href="#layout-swig" title="_layout.swig"></a>_layout.swig</h1><p>打开<code>themes\next\layout\_layout.swig</code>文件，将<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/dist/APlayer.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/dist/music.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>添加到<code>&lt;body itemscope ...&gt;</code>后面就行，即在<code>&lt;body&gt;&lt;/body&gt;</code>里面。</p><p>重新生成，访问页面，就能看到左下角的音乐播放器了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（添加统计访客量以及文章阅读量）</title>
      <link href="/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%EF%BC%89/"/>
      <url>/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h2 id="不蒜子统计功能"><a href="#不蒜子统计功能" class="headerlink" title="不蒜子统计功能"></a>不蒜子统计功能</h2><p>NexT主题集成了不蒜子统计功能,以下为我的配置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only <span class="keyword">if</span> the other configs are <span class="literal">false</span></span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  # custom uv span <span class="keyword">for</span> the whole site</span><br><span class="line">  site_uv: <span class="literal">true</span></span><br><span class="line">  site_uv_header: &lt;i <span class="attribute">class</span>=<span class="string">"fa fa-user"</span>&gt;&lt;/i&gt;</span><br><span class="line">  site_uv_footer: 人次</span><br><span class="line">  # custom pv span <span class="keyword">for</span> the whole site</span><br><span class="line">  site_pv: <span class="literal">true</span></span><br><span class="line">  site_pv_header: &lt;i <span class="attribute">class</span>=<span class="string">"fa fa-eye"</span>&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span <span class="keyword">for</span> one<span class="built_in"> page </span>only</span><br><span class="line">  page_pv: <span class="literal">true</span></span><br><span class="line">  page_pv_header: &lt;i <span class="attribute">class</span>=<span class="string">"fa fa-file-o"</span>&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure></p><p>当<code>enable: true</code>时，代表开启全局开关。若s<code>ite_uv、site_pv、page_pv</code>的值均为<code>false</code>时，不蒜子仅作记录而不会在页面上显示。<br>当<code>site_uv: true</code>时，代表在页面底部显示站点的UV值。<br>当<code>site_pv: true</code>时，代表在页面底部显示站点的PV值。<br>当<code>page_pv: true</code>时，代表在文章页面的标题下显示该页面的PV值（阅读数）。<br><code>site_uv_header</code>和<code>site_uv_footer</code>这几个为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。 </p><div class="note success"><p>[2018/9/19] 更新</p></div><p>Next主题已经更新至6.X版本,不蒜子统计插件配置有变化</p><figure class="highlight yml"><figcaption><span>文件：主题配置文件_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show Views/Visitors of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_views_icon:</span> <span class="string">eye</span></span><br><span class="line"><span class="attr">  post_views:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure><hr><p>效果图：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/read02.png" alt=""><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/read01.png" alt=""></p><h2 id="LeanCloud阅读次数统计"><a href="#LeanCloud阅读次数统计" class="headerlink" title="LeanCloud阅读次数统计"></a>LeanCloud阅读次数统计</h2><div class="note success"><p>[2018/9/19] 更新</p></div><figure class="highlight cmd"><figcaption><span>安装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-<span class="built_in">time</span> --save</span><br></pre></td></tr></table></figure><figure class="highlight yml"><figcaption><span>文件：站点配置文件_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><figcaption><span>文件：主题配置文件_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_total:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  awl:</span> <span class="number">4</span> <span class="comment"># 平均单词长度（单词的计数）。默认值:4。CN≈2 EN≈5 俄文≈6</span></span><br><span class="line"><span class="attr">  wpm:</span> <span class="number">275</span> <span class="comment"># 每分钟的单词。默认值:275。缓慢≈200 正常≈275 快≈350</span></span><br></pre></td></tr></table></figure><p>更多请<a href="http://theme-next.iissnan.com/third-party-services.html#share-system" target="_blank" rel="noopener">点击这里</a><br>next升级6.X后，页面LeanCloud访问统计提示<code>Counter not initialized! See more at console err msg.</code>的问题，请查看<a href="https://leaferx.online/2018/02/11/lc-security/#5acc7b329f54542bb2384a7e" target="_blank" rel="noopener">《Leancloud访客统计插件重大安全漏洞修复指南》</a></p><hr><p>首先一句话介绍Lean Cloud:</p><blockquote><p><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>（aka. AVOS Cloud）提供一站式后端云服务，从数据存储、实时聊天、消息推送到移动统计，涵盖应用开发的多方面后端需求。</p></blockquote><p>相比不蒜子的统计，LeanCloud的文章阅读量统计更加稳定靠谱，所以本人也把网站的文章内统计改为LeanCloud的了。</p><h3 id="配置LeanCloud"><a href="#配置LeanCloud" class="headerlink" title="配置LeanCloud"></a><a href="#配置LeanCloud" title="配置LeanCloud"></a>配置<a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a></h3><p>在注册完成LeanCloud帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到<code>AppID</code>以及<code>AppKey</code>这两个参数即可正常使用文章阅读量统计的功能了。</p><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a><a href="#创建应用" title="创建应用"></a>创建应用</h4><ul><li>我们新建一个应用来专门进行博客的访问统计的数据操作。首先，打开控制台，如下图所示：</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/open_consoloe.png" alt="" title="打开控制台"></p><ul><li>在出现的界面点击<code>创建应用</code>：</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/create_app.png" alt="" title="创建应用"></p><ul><li>在接下来的页面，新建的应用名称我们可以随意输入，即便是输入的不满意我们后续也是可以更改的:</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/creating_app.png" alt="" title="创建的新应用名称"></p><ul><li>这里为了演示的方便，我新创建一个取名为test的应用。创建完成之后我们点击新创建的应用的名字来进行该应用的参数配置：</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/create_class.png" alt="" title="打开应用参数配置界面"></p><ul><li>在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。点击左侧右上角的齿轮图标，新建Class：<br>在弹出的选项中选择<code>创建Class</code>来新建Class用来专门保存我们博客的文章访问量等数据:<br>点击<code>创建Class</code>之后，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证我们前面对NexT主题的修改兼容，此处的<strong>新建Class名字必须为<code>Counter</code></strong>:</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/creating_class.png" alt="" title="权限配置"></p><ul><li>由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择<code>无限制</code>。</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/open_app_key.png" alt="" title="打开应用设置"></p><p>创建完成之后，左侧数据栏应该会多出一栏名为<code>Counter</code>的栏目，这个时候我们点击顶部的设置，切换到test应用的操作界面:<br>在弹出的界面中，选择左侧的<code>应用Key</code>选项，即可发现我们创建应用的<code>AppID</code>以及<code>AppKey</code>，有了它，我们就有权限能够通过主题中配置好的Javascript代码与这个应用的Counter表进行数据存取操作了:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/opened_app_key.png" alt="" title="获取Appid、Appkey"></p><p>复制<code>AppID</code>以及<code>AppKey</code>并在NexT主题的<code>_config.yml</code>文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span>  </span><br><span class="line"><span class="attr"> enable:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr"> app_id:</span> <span class="string">joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz</span>  </span><br><span class="line"><span class="attr"> app_key:</span> <span class="string">E9UJsJpw1omCHuS22PdSpKoh</span></span><br></pre></td></tr></table></figure><p>这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的<code>发布日期</code>以及<code>文章的标题</code>，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。</p><h3 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a><a href="#后台管理" title="后台管理"></a>后台管理</h3><p>当你配置部分完成之后，初始的文章统计量显示为0，但是这个时候我们LeanCloud对应的应用的<code>Counter</code>表中并没有相应的记录，只是单纯的显示为0而已，当博客文章在配置好阅读量统计服务之后第一次打开时，便会自动向服务器发送数据来创建一条数据，该数据会被记录在对应的应用的<code>Counter</code>表中。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/read03.png" alt="" title="后台管理"></p><p>我们可以修改其中的<code>time</code>字段的数值来达到修改某一篇文章的访问量的目的（博客文章访问量快递提升人气的装逼利器）。双击具体的数值，修改之后回车即可保存。</p><ul><li><code>url</code>字段被当作唯一<code>ID</code>来使用，因此如果你不知道带来的后果的话请不要修改。</li><li><code>title</code>字段显示的是博客文章的标题，用于后台管理的时候区分文章之用，没有什么实际作用。</li><li>其他字段皆为自动生成，具体作用请查阅LeanCloud官方文档，如果你不知道有什么作用请不要随意修改。</li></ul><h3 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a><a href="#Web安全" title="Web安全"></a>Web安全</h3><p>因为AppID以及AppKey是暴露在外的，因此如果一些别用用心之人知道了之后用于其它目的是得不偿失的，为了确保只用于我们自己的博客，建议开启Web安全选项，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。</p><p>选择应用的设置的<code>安全中心</code>选项卡:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/open_safe_center.png" alt="" title="进入安全中心"></p><p>在<code>Web 安全域名</code>中填入我们自己的博客域名，来确保数据调用的安全:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/bind_domain.png" alt="" title="锁定域名"></p><p>如果你不知道怎么填写安全域名而或者填写完成之后发现博客文章访问量显示不正常，打开浏览器调试模式，发现如下图的输出:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/broswer_403.png" alt="" title="Web安全域名填写错误"></p><p>这说明你的安全域名填写错误，导致服务器拒绝了数据交互的请求，你可以更改为正确的安全域名或者你不知道如何修改请在本博文中留言或者放弃设置Web安全域名。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（集成DaoVoice在线联系功能）</title>
      <link href="/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
      <url>/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a><a href="#注册" title="注册"></a>注册</h1><p>首先在<a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a>注册个账号，点击-&gt;<a href="http://dashboard.daovoice.io/get-started?invite_code=b3c7d22e" target="_blank" rel="noopener">邀请码</a>是<code>b3c7d22e</code>。<br><a href="https://s1.ax1x.com/2018/01/21/pW5DRP.png" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/21/pW5DRP.png" alt="pW5DRP.png"></a></p><p>完成后，会得到一个<code>app_id</code>，后面会用到：<br><a href="https://s1.ax1x.com/2018/01/21/pW5yM8.png" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/21/pW5yM8.png" alt="appid"></a></p><h1 id="修改head-swig"><a href="#修改head-swig" class="headerlink" title="修改head.swig"></a><a href="#修改head-swig" title="修改head.swig"></a>修改head.swig</h1><p>修改<code>/themes/next/layout/_partials/head.swig</code>文件，添加内容如下：  </p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.daovoice %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">  (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")</span></span><br><span class="line"><span class="xml">  daovoice('init', &#123;</span></span><br><span class="line"><span class="xml">      app_id: "</span><span class="template-variable">&#123;&#123;theme.daovoice_app_id&#125;&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  daovoice('update');</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>位置贴图：<br><a href="https://imgchr.com/i/pWIwmF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/21/pWIwmF.md.png" alt="pWIwmF.md.png"></a></p><h1 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a><a href="#主题配置文件" title="主题配置文件"></a>主题配置文件</h1><p>在<code>_config.yml</code>文件中添加内容：  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Online contact </span></span><br><span class="line"><span class="attr">daovoice:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">daovoice_app_id:</span> <span class="string">这里输入前面获取的app_id</span></span><br></pre></td></tr></table></figure><h1 id="聊天窗口配置"><a href="#聊天窗口配置" class="headerlink" title="聊天窗口配置"></a><a href="#聊天窗口配置" title="聊天窗口配置"></a>聊天窗口配置</h1><p>附上我的聊天窗口的颜色、位置等设置信息：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice01.png" alt=""></p><p>至此，网页的在线联系功能已经完成，重新<code>hexo d -g</code>上传GitHub后，页面上就能看到效果了。</p><p>效果图：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice02.png?x-oss-process=style/w200" alt=""></p><p>可以关注小程序接收回复消息，很方便</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice03.png?x-oss-process=style/w200" alt=""><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice04.png?x-oss-process=style/w200" alt=""></p><p>现在往右下角看看(～￣▽￣)～ ，欢迎撩我（滑稽）。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（集成LiveRe来必力文章评论功能）</title>
      <link href="/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90LiveRe%E6%9D%A5%E5%BF%85%E5%8A%9B%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
      <url>/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90LiveRe%E6%9D%A5%E5%BF%85%E5%8A%9B%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><a href="#准备" title="准备"></a>准备</h2><ol><li>去<a href="https://livere.com/" target="_blank" rel="noopener">Livere官网</a>注册Livere账号。</li><li>选择City版（免费），安装</li><li>进入管理页面-&gt;代码管理-&gt;一般网站，复制data-uid</li></ol><h2 id="在Hexo中添加Livere"><a href="#在Hexo中添加Livere" class="headerlink" title="在Hexo中添加Livere"></a><a href="#在Hexo中添加Livere" title="在Hexo中添加Livere"></a>在Hexo中添加Livere</h2><p>以下基于主题Next，其他主题做法类似</p><ol><li>打开<code>博客根目录/themes/next/_config.yml</code></li><li><p>将# Third Party Services Settings 栏目下其他评论系统如duoshuo、gentie、youyan、disqus用#注释掉，加入以下内容</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Livere评论系统</span></span><br><span class="line">    livere_uid: 上一步中你获取的<span class="class"><span class="keyword">data</span>-uid</span></span><br></pre></td></tr></table></figure></li><li><p>在博客根目录<code>/themes/layout/_scripts/third-party/comments/</code>目录中新建txt文件，重命名为livere.swig，编辑内容如下：</p></li></ol><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.livere_uid %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">      (function(d, s) &#123;</span></span><br><span class="line"><span class="xml">        var j, e = d.getElementsByTagName(s)[0];</span></span><br><span class="line"><span class="xml">        if (typeof LivereTower === 'function') &#123; return; &#125;</span></span><br><span class="line"><span class="xml">        j = d.createElement(s);</span></span><br><span class="line"><span class="xml">        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';</span></span><br><span class="line"><span class="xml">        j.async = true;</span></span><br><span class="line"><span class="xml">        e.parentNode.insertBefore(j, e);</span></span><br><span class="line"><span class="xml">      &#125;)(document, 'script');</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>在<code>博客根目录/themes/layout/_scripts/third-party/comments.swig</code>文件中追加：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> './comments/livere.swig' %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></li><li><p>在博客根目录<code>/themes/layout/_partials/comments.swig</code>文件中条件最后追加 LiveRe 插件是否引用的判断逻辑：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">elseif</span> theme.livere_uid %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"lv-container"</span> <span class="attr">data-id</span>=<span class="string">"city"</span> <span class="attr">data-uid</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.livere_uid &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></li></ol><p>重新<code>hexo clean、hexo d -g</code>，然后就可以看到来必力评论啦~ </p><p>ps:因为是国外的，评论加载有点慢。 </p><h6 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/liveRe01.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（集成Algolia站内搜索引擎）</title>
      <link href="/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90Algolia%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%89/"/>
      <url>/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90Algolia%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a><br>起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。 注：Algolia搜索在版本<strong> 5.1.0 </strong>中引入，要使用此功能请确保所使用的 NexT 版本在此之后</span></p><h2 id="首先注册Algolia账户"><a href="#首先注册Algolia账户" class="headerlink" title="首先注册Algolia账户"></a>首先注册Algolia账户</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.algolia.com%2Fusers%2Fsign_in" target="_blank" rel="noopener">Algolia 登陆页面https://www.algolia.com/users/sign_in</a> ，可以使用 GitHub 或者 Google 账户直接登录，也可以注册一个新账户。我直接用谷歌账户登陆了，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。</p><p>注册完成后，创建一个新的 Index，这个 index name 之后会用到<br><img src="https://upload-images.jianshu.io/upload_images/3899681-c00f0825ef763c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-algolia --save  <span class="comment"># 目前最新版本是1.2.5，下面的操作都是基于这个版本的文档</span></span><br></pre></td></tr></table></figure></p><h2 id="获取-Key，更新站点根目录配置"><a href="#获取-Key，更新站点根目录配置" class="headerlink" title="获取 Key，更新站点根目录配置"></a>获取 Key，更新站点根目录配置</h2><p><img src="http://www.qingpingshan.com/uploads/allimg/180511/1440043942-0.png" alt=""></p><p>前往站点根目录打开_config.yml添加以下代码<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algolia Search API Key</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line"><span class="attr">  applicationID:</span> <span class="string">'你的Application ID'</span></span><br><span class="line"><span class="attr">  apiKey:</span> <span class="string">'你的Search-Only API Key'</span></span><br><span class="line"><span class="attr">  adminApiKey:</span> <span class="string">'你的Admin API Key'</span></span><br><span class="line"><span class="attr">  indexName:</span> <span class="string">'输入刚才创建index name'</span></span><br><span class="line"><span class="attr">  chunkSize:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure></p><h2 id="修改Algolia搜索ACL（访问控制列表）"><a href="#修改Algolia搜索ACL（访问控制列表）" class="headerlink" title="修改Algolia搜索ACL（访问控制列表）"></a>修改Algolia搜索ACL（访问控制列表）</h2><p><img src="http://www.qingpingshan.com/uploads/allimg/180511/1440041313-1.png" alt=""></p><p>选中后保存。</p><h2 id="操作完成后去你的博客跟路径执行命令"><a href="#操作完成后去你的博客跟路径执行命令" class="headerlink" title="操作完成后去你的博客跟路径执行命令"></a>操作完成后去你的博客跟路径执行命令</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">HEXO_ALGOLIA_INDEXING_KEY</span>=你的Search-Only API Key</span><br></pre></td></tr></table></figure><p>查看是否设置成功如果没有值就设置失败<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo algolia</span></span><br></pre></td></tr></table></figure></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia02.png" alt=""></p><h2 id="成功后修改Next主题配置文件"><a href="#成功后修改Next主题配置文件" class="headerlink" title="成功后修改Next主题配置文件"></a>成功后修改Next主题配置文件</h2><p>更改Next主题配置文件，找到 Algolia Search 配置部分：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Algolia Search</span></span><br><span class="line"><span class="symbol">algolia_search:</span></span><br><span class="line"><span class="symbol">  enable:</span> true</span><br><span class="line"><span class="symbol">  hits:</span></span><br><span class="line"><span class="symbol">    per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">  labels:</span></span><br><span class="line"><span class="symbol">    input_placeholder:</span> 输入关键字</span><br><span class="line"><span class="symbol">    hits_empty:</span> <span class="string">"没有找到与 $&#123;query&#125; 相关的内容"</span></span><br><span class="line"><span class="symbol">    hits_stats:</span> <span class="string">"$&#123;hits&#125;条相关记录，共耗时$&#123;time&#125; ms"</span></span><br></pre></td></tr></table></figure></p><p>将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。这个是我修改的文本。</p><p>最终效果</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia01.png" alt=""></p><h2 id="总结一下集成遇到的BUG"><a href="#总结一下集成遇到的BUG" class="headerlink" title="总结一下集成遇到的BUG"></a>总结一下集成遇到的BUG</h2><h6 id="Please-set-an-HEXO-ALGOLIA-INDEXING-KEY-environment-variable-to-enable-content-indexing"><a href="#Please-set-an-HEXO-ALGOLIA-INDEXING-KEY-environment-variable-to-enable-content-indexing" class="headerlink" title="Please set an HEXO_ALGOLIA_INDEXING_KEY environment variable to enable content indexing."></a>Please set an <code>HEXO_ALGOLIA_INDEXING_KEY</code> environment variable to enable content indexing.</h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia04.png" alt=""></p><p>原因：Algolia Search API Key indexName 错了</p><p>解决方案：看下之前新建index的名字</p><h6 id="Not-enough-rights-to-update-an-object-near-line-1-column-1635"><a href="#Not-enough-rights-to-update-an-object-near-line-1-column-1635" class="headerlink" title="Not enough rights to update an object near line:1 column:1635"></a>Not enough rights to update an object near line:1 column:1635</h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia03.png" alt=""></p><p>原因：没有修改Algolia搜索ACL（访问控制列表）</p><p>解决方案： 按步骤3勾选上就可以</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/fa2354d61e37" title="hexo+next添加algolia搜索" target="_blank" rel="noopener">《hexo+next添加algolia搜索》</a></li></ul><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ul><li><a href="https://www.npmjs.com/package/hexo-algolia" title="《hexo-algolia》" target="_blank" rel="noopener">《hexo-algolia》</a></li></ul><h2 id="更多教程可以来我yufeng-Zhou独立博客里面看到"><a href="#更多教程可以来我yufeng-Zhou独立博客里面看到" class="headerlink" title="更多教程可以来我yufeng.Zhou独立博客里面看到"></a>更多教程可以来我<a href="http://yfzhou.coding.me/">yufeng.Zhou</a>独立博客里面看到</h2><p><strong>转载请注明出处<a href="http://yfzhou.coding.me/">http://yfzhou.coding.me/</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（托管到Github和Coding）</title>
      <link href="/2018/08/07/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%89%98%E7%AE%A1%E5%88%B0Github%E5%92%8CCoding%EF%BC%89/"/>
      <url>/2018/08/07/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%89%98%E7%AE%A1%E5%88%B0Github%E5%92%8CCoding%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇很详细的独立博客搭建教程，意在帮助小白们能快速入门，拥有自己的独立博客。作者已在window平台已搭建成功，博客效果请点<a href="https://yfzhou.coding.me/">链接</a>查看。  </p><h3 id="为什么用Hexo搭建独立博客？"><a href="#为什么用Hexo搭建独立博客？" class="headerlink" title="为什么用Hexo搭建独立博客？"></a>为什么用Hexo搭建独立博客？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="Github和Coding又是什么？"><a href="#Github和Coding又是什么？" class="headerlink" title="Github和Coding又是什么？"></a>Github和Coding又是什么？</h3><ul><li>Github是国外免费的Git代码托管平台。利用Github Page服务可以免费创建一个静态网站。</li><li>Coding则是国内Git代码托管平台。国内首个Git代码托管平台GitCafe已被Coding收购。也提供page服务。</li></ul><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/02.png" alt="GitCafe"></p><h3 id="为什么用两个代码托管平台？"><a href="#为什么用两个代码托管平台？" class="headerlink" title="为什么用两个代码托管平台？"></a>为什么用两个代码托管平台？</h3><p>很多人都把hexo托管到github上，因为github大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问coding比github是要快不少的。还可以利用域名解析实现国内的走coding，海外的走github，分流网站的访问。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><div class="note info"><p>Git是什么？<br>Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br>了解更多，参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">git教程</a></p></div></p><ul><li><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">点击下载</a>，然后按默认选项安装即可。<img src="http://7xs5l8.com1.z0.glb.clouddn.com/00.png" alt="Bash"></li><li>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</li></ul><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/0.jpg" alt="命令窗口"></p><ul><li>安装完成后，还需要最后一步设置，在命令行输入<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></li></ul><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p><p><strong>注意</strong><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="将博客托管到Github和Coding上"><a href="#将博客托管到Github和Coding上" class="headerlink" title="将博客托管到Github和Coding上"></a>将博客托管到Github和Coding上</h3><h4 id="托管到github"><a href="#托管到github" class="headerlink" title="托管到github"></a>托管到github</h4><ul><li>注册github帐号<br>访问<a href="https://github.com/" target="_blank" rel="noopener">官网</a>注册,你的username和邮箱十分重要，GitHub上很多通知都是通过邮箱的。比如你的主页上传并构建成功会通过邮箱通知，更重要的是，如果构建失败的话也会在邮件中说明原因。</li><li>创建项目仓库<br>注册并登陆Github官网成功后，点击页面右上角的+，选择New repository。<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan20163281.png" alt="+"><br>在Repository name中填写Github账号名.github.io<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE02.png" alt="创建仓库"><br>点击Create repository，完成创建。</li></ul><h4 id="托管到coding"><a href="#托管到coding" class="headerlink" title="托管到coding"></a>托管到coding</h4><ul><li>注册coding帐号<br>访问<a href="https://coding.net/" target="_blank" rel="noopener">官网</a>注册并登录</li><li>创建仓库<br>点+创建项目<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE04.png" alt="+"><br>填写项目名称描述创建即可,<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan1637925-3cbdade49c4ed7ba.png" alt="创建"></li></ul><h4 id="配置SHH"><a href="#配置SHH" class="headerlink" title="配置SHH"></a>配置SHH</h4><p>配置shh key是让本地git项目与远程的github建立联系  </p><ul><li><p>检查是否已经有SSH Key，打开Git Bash，输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure></li><li><p>如果没有.ssh这个目录，则生成一个新的SSH，输入</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"your e-mail"</span></span><br></pre></td></tr></table></figure></li></ul><p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」  </p><ul><li>接下来几步都直接按回车键,然后系统会要你输入密码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="xml"><span class="tag">&lt;<span class="name">输入加密串</span>&gt;</span></span></span><br><span class="line"><span class="xml">Enter same passphrase again:<span class="tag">&lt;<span class="name">再次输入加密串</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><p>这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。<br>注意：输入密码的时候没有*字样的，你直接输入就可以了。  </p><ul><li>最后看到这样的界面，就成功设置ssh key了<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhanssh%20key.jpg" alt="ssh key"></li></ul><h4 id="添加-SSH-Key-到-GitHub和Coding"><a href="#添加-SSH-Key-到-GitHub和Coding" class="headerlink" title="添加 SSH Key 到 GitHub和Coding"></a>添加 SSH Key 到 GitHub和Coding</h4><ul><li><p>打开Git Bash，然后输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure></li><li><p>进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE05.png" alt=""></p></li><li>输入cat命令，打开id_rsa.pub文件<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cat</span> <span class="selector-tag">id_rsa</span><span class="selector-class">.pub</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE06.png" alt="">  </p><ul><li>再鼠标全选中右击复制  </li><li>再配置到GitHub和Coding的SSH中<br>进入Github官网，点击+旁边的头像，再按settings进入设置<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE07.png" alt=""><br>在点击New SSH key创建<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE08.png" alt=""><br>title输入邮箱，key里面粘贴刚才右击复制的内容,再点Add SSH key<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE10.png" alt=""><br>同样进入coding,点击账户，在点SSH公钥设置即可<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE11.png" alt=""></li></ul><h4 id="测试SSH是否配置成功"><a href="#测试SSH是否配置成功" class="headerlink" title="测试SSH是否配置成功"></a>测试SSH是否配置成功</h4><ul><li><p>打开Git Bash，然后输入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-T</span> <span class="selector-tag">git</span>@<span class="keyword">github</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure></li><li><p>如配置了密码则要输入密码,输完按回车<br>如果显示以下内容，则说明Github中的ssh配置成功。</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username<span class="comment">! You've successfully authenticated, but GitHub does not</span></span><br><span class="line"><span class="keyword">provide</span> shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure></li><li><p>再输入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-T</span> <span class="selector-tag">git</span>@<span class="keyword">git</span>.<span class="keyword">coding</span>.<span class="keyword">net</span></span><br></pre></td></tr></table></figure></li></ul><p>如果显示以下则说明coding中的ssh配置成功<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello username You've connected <span class="keyword">to</span> Coding.net <span class="keyword">by</span> SSH successfully!</span><br></pre></td></tr></table></figure></p><h4 id="创建Github-Pages和Coding-Pages-服务"><a href="#创建Github-Pages和Coding-Pages-服务" class="headerlink" title="创建Github Pages和Coding Pages 服务"></a>创建Github Pages和Coding Pages 服务</h4><ul><li>GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">更多</a></li><li>官网点击代码再点击Coding Pages 服务开启。分支和github分支写一样，填写master<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE13.png" alt=""></li></ul><h4 id="将博客网站上传到GitHub和Coding中"><a href="#将博客网站上传到GitHub和Coding中" class="headerlink" title="将博客网站上传到GitHub和Coding中"></a>将博客网站上传到GitHub和Coding中</h4><ul><li>打开D:\blog文件夹中的_config.yml文件，找到如下位置，填写</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span></span><br><span class="line"><span class="symbol">      github:</span> git@github.com:yourname/yourname.github.io.git,master</span><br><span class="line"><span class="symbol">      coding:</span> git@git.coding.net:yourname/yourname.git,master</span><br></pre></td></tr></table></figure><p><strong>注：</strong> (1) 其中yourname替换成你的Github账户名;(2)注意在yml文件中，:后面都是要带空格的。<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE14.png" alt="">  </p><ul><li>在<strong>blog文件夹</strong>中空白处右击打开Git Bash输入<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure></li></ul><p>此时，通过访问<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a>和<a href="http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。" target="_blank" rel="noopener">http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。</a></p><h4 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h4><p>本网站使用的是Next主题。该主题简洁易用，在移动端也表现不错。  </p><ul><li><p>下载主题<br>在<strong>blog文件夹</strong>中空白处右击打开Git Bash输入</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure></li><li><p>修改网站的主题为Next<br>打开D:\blog下的_config.yml文件，找到theme字段，将其修改为next</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: http://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: http://hexo.io/themes/</span></span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></li><li><p>验证主题是否可用<br>输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo</span> s <span class="comment">#启动服务，调试用</span></span><br></pre></td></tr></table></figure></li></ul><p>再在浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>确认网站主题是否切换为Next.  </p><ul><li>博客blog根目录下的_config.yml配置网站信息<br>_config.yml配置请点<a href="https://github.com/xirong/hexo-theme-next/blob/master/_config_root.yml" target="_blank" rel="noopener">参考</a></li></ul><h3 id="注册及绑定自己的域名地址"><a href="#注册及绑定自己的域名地址" class="headerlink" title="注册及绑定自己的域名地址"></a>注册及绑定自己的域名地址</h3><h4 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h4><p>推荐选择国内的万网或者国外的Goddady进行域名的注册，注册完还需改下绑定DNS服务商</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>如果你选择的是万网注册的域名，可以使用其自带的域名解析服务。<br>也可以选择免费的<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a>  </p><ul><li>域名解析填写如下图<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan1637925-bc9fbfb9af5e3b77.png" alt="">  </li><li>打开blog文件夹下的source文件夹，新建CNAME文件,内容填写自己的域名<br>CNAME文件设置的目的是，通过访问 yourname.github.io 可以跳转到你所注册的域名上。<br>github是直接项目里面加CNAME文件。coding是直接在项目主页设置的，去coding项目主页添加CNAME，绑定域名。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要按照上面步骤一步步设置，相信你也可以拥有自己的独立博客。希望此文对还在搭建hexo独立博客的小伙伴有所帮助。主题相关配置查看下面的，hexo和next帮助文档。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.jeyzhang.com/hexo-github-blog-building.html" target="_blank" rel="noopener">《Hexo+Github: 搭建属于自己的静态博客》</a></li><li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool" target="_blank" rel="noopener">《hexo你的博客》</a></li><li><a href="http://blog.shijinrong.cn/2016/01/03/2016-01-03-how-to-build-blog/" target="_blank" rel="noopener">《如何使用10个小时搭建出个人域名而又Geek的独立博客？》</a></li><li><a href="http://tengj.top/2016/03/06/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding/" target="_blank" rel="noopener">《将hexo博客同时托管到github和coding》</a></li><li><a href="https://segmentfault.com/q/1010000004557073?_ea=651524" target="_blank" rel="noopener">《个人域名如何同时绑定 github 和 coding 上的博客》</a></li><li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785/" target="_blank" rel="noopener">《如何搭建一个独立博客——简明Github Pages与Hexo教程》</a></li><li><a href="http://mousycoder.com/2015/10/19/classic-tutorial-of-hexo-blog/" target="_blank" rel="noopener">《「搭建Hexo博客」简明教程》</a></li><li><a href="http://www.ixirong.com/2015/05/17/how-to-build-ixirong-blog/" target="_blank" rel="noopener">《使用 github Pages 服务建立 ixirong.com 独立博客全过程》</a></li><li><a href="http://shenshanlaoyuan.com/" target="_blank" rel="noopener">深山老猿</a></li></ul><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">《Hexo文档》</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">《Next使用文档》</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《Git教程》</a></li><li><a href="https://help.github.com/" target="_blank" rel="noopener">《Github帮助文档》</a></li><li><a href="https://coding.net/help/" target="_blank" rel="noopener">《Coding帮助文档》</a></li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">《Markdown 语法说明》</a></li></ul><h2 id="更多教程可以来我yufeng-Zhou独立博客里面看到"><a href="#更多教程可以来我yufeng-Zhou独立博客里面看到" class="headerlink" title="更多教程可以来我yufeng.Zhou独立博客里面看到"></a>更多教程可以来我<a href="http://yfzhou.coding.me/">yufeng.Zhou</a>独立博客里面看到</h2><p><strong>转载请注明出处<a href="http://yfzhou.coding.me/">http://yfzhou.coding.me/</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo-Next搭建个人博客（安装与部署）</title>
      <link href="/2018/08/07/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%89/"/>
      <url>/2018/08/07/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的静态站点生成框架，它基于 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 。 它有以下特点：</p><ul><li><h6 id="超快速度"><a href="#超快速度" class="headerlink" title="  超快速度"></a><i class="fa fa-bolt"></i>  超快速度</h6><p><i>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</i></p></li><li><h6 id="支持Markdown"><a href="#支持Markdown" class="headerlink" title="  支持Markdown"></a><i class="fa fa-pencil"></i>  支持Markdown</h6><p> <i>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 </i></p></li><li><h6 id="一键部署"><a href="#一键部署" class="headerlink" title=" 一键部署"></a><i class="fa fa-cloud-upload"></i> 一键部署</h6> <i>只需一条指令即可部署到Github Pages，或其他网站 </i></li><li><h6 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title=" 丰富的插件"></a><i class="fa fa-cog"></i> 丰富的插件</h6> <i>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 </i></li></ul><p>通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件</a> 来快速的插入特定形式的内容。</p><p>基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 因其 精于心，简于形 的风格，一直被广大用户所喜爱。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a><a href="#安装前提" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序:</p><div class="note default"><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a><p></p></div><p>如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><div class="note primary"><p><strong>Mac 用户</strong><br>您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></div><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a><a href="#安装-Git" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载安装 git 。 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Download Now</a></li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>，<a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装</li><li>Linux（Ubuntu，Debian）：<code>sudo apt-get install git-core</code></li><li>Linux（Fedora，Red Hat，CentOS）：<code>sudo yum install git-core</code></li></ul><div class="note primary"><p><strong>Windows 用户</strong><br>由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p></div><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a><a href="#安装-Node-js" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。（nvm：Node Version Manager）<br>windows 下使用 nvm 请看这里： <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a> ，首先需要下载安装 nvm 。 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">Download Now</a><br>windows下安装完nvm以后，我们可以打开命令行中执行命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nvm  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvm install latest</span></span><br></pre></td></tr></table></figure></p><p>执行完以后，重启命令行，执行命令 <code>node -v</code> ，如果出现版本号，那么 <code>Node.js</code> 就安装成功了。</p><p>如果没有安装成功，那可能就是墙的原因。建议下载 <code>Node.js</code> 直接安装。 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Download Now</a></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a><a href="#安装-Hexo" title="安装 Hexo"></a>安装 Hexo</h2><p>有了 Node.js ，我们可以使用 npm 安装 Hexo。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure></p><p>安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。<code>D:\blog</code> ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure></p><p>等待安装，安装完成后，指定文件夹 的目录如下：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.  </span><br><span class="line">├── <span class="variable">_config</span>.yml  </span><br><span class="line">├── package.json  </span><br><span class="line">├── scaffolds  </span><br><span class="line">├── source  </span><br><span class="line">|   ├── <span class="variable">_drafts</span>  </span><br><span class="line">|   └── <span class="variable">_posts</span>  </span><br><span class="line">└──</span><br></pre></td></tr></table></figure></p><p>我们继续执行命令  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s --debug</span></span><br></pre></td></tr></table></figure><p>Hexo 将 source 文件夹中除 <em>posts 文件夹之外，开头命名为</em> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。<br>这个时候，我们在浏览器中访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，就可以看到基于 Hexo 的默认主题的原型</p><h2 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a><a href="#安装-NexT-主题" title="安装 NexT 主题"></a>安装 NexT 主题</h2><h3 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a><a href="#下载-NexT-主题" title="下载 NexT 主题"></a>下载 NexT 主题</h3><p>依旧是在当前目录下，使用 Git checkout 代码：  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>等待下载完成。</p><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>我们约定，将前者称为 <span id="inline-blue">站点配置文件</span>，后者称为 <span id="inline-purple">主题配置文件</span></p><h3 id="启用-NexT-主题"><a href="#启用-NexT-主题" class="headerlink" title="启用 NexT 主题"></a><a href="#启用-NexT-主题" title="启用 NexT 主题"></a>启用 NexT 主题</h3><p>打开 <span id="inline-blue">站点配置文件</span>文件 ，找到 theme 字段，并将其值更改为 next 。<br>到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a><a href="#验证主题" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示：</p><p>INFO  Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.  </p><p>此时即可使用浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，检查站点是否正确运行。</p><p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p><p>现在，我们已经成功安装并启用了 NexT 主题。  </p><p>关于更多基本操作和基础知识，请查阅 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 与 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 官方文档.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#总结" title="总结"></a>总结</h1><h2 id="本地调试步骤"><a href="#本地调试步骤" class="headerlink" title="本地调试步骤"></a><a href="#本地调试步骤" title="本地调试步骤"></a>本地调试步骤</h2><p>三部曲：  </p><div class="note info"><p>$ hexo clean<br>$ hexo g<br>$ hexo s –debug  </p></div><p>这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。</p><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a><a href="#部署步骤" title="部署步骤"></a>部署步骤</h2><p>三部曲：  </p><div class="note info"><p>$ hexo clean<br>$ hexo g<br>$ hexo d  </p></div><p>当然在部署之前，需要先配置好配置文件中的 deploy。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><a href="#常用命令" title="常用命令"></a>常用命令</h2><div class="note info"><p>$ hexo new “postName”  #新建文章<br>$ hexo new page “pageName” # 新建页面<br>$ hexo generate # 生成静态页面至public目录<br>$ hexo server # 开启预览访问端口(默认端口4000，’ctrl+c’关闭server)<br>$ hexo deploy # 项目部署<br>$ hexo help # 查看帮助<br>$ hexo version # 查看Hexo的版本  </p></div><h2 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a><a href="#简写命令" title="简写命令"></a>简写命令</h2><div class="note info"><p>$ hexo new == hexo n<br>$ hexo generate == hexo g<br>$ hexo server == hexo s<br>$ hexo deploy == hexo d<br>$ hexo generate + $ hexo server == $ hexo s -g<br>$ hexo generate + $ hexo deploy == $ hexo d -g</p></div><h2 id="常见问题1"><a href="#常见问题1" class="headerlink" title="常见问题1"></a><a href="#常见问题1" title="常见问题1"></a>常见问题1</h2><p>在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：<br>错误的设置：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">author</span>:yufeng.Zhou</span><br><span class="line"><span class="attribute">email</span>:<span class="number">18851200889</span><span class="variable">@163</span>.com</span><br><span class="line"><span class="attribute">language</span>:zh-CN</span><br></pre></td></tr></table></figure></p><p>正确的设置：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">author</span>: yufeng.Zhou</span><br><span class="line"><span class="attribute">email</span>: <span class="number">18851200889</span><span class="variable">@163</span>.com</span><br><span class="line"><span class="attribute">language</span>: zh-CN</span><br></pre></td></tr></table></figure></p><h2 id="常见问题2"><a href="#常见问题2" class="headerlink" title="常见问题2"></a><a href="#常见问题2" title="常见问题2"></a>常见问题2</h2><p>关于 Git 提交中用户名和 Email 的设置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"Your name"</span>  </span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"Your email"</span></span><br></pre></td></tr></table></figure></p><h2 id="常见问题3"><a href="#常见问题3" class="headerlink" title="常见问题3"></a><a href="#常见问题3" title="常见问题3"></a>常见问题3</h2><p>Hexo 中的图标使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。<br><i class="fa fa-github"></i><code>&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-lg"></i><code>&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-2x"></i><code>&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FreeMarker笔记</title>
      <link href="/2018/08/01/FreeMarker%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/FreeMarker%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h5 id="FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html-web-页面-和-代码自动生成工具来快速了解FreeMarker。"><a href="#FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html-web-页面-和-代码自动生成工具来快速了解FreeMarker。" class="headerlink" title="FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html web 页面 和 代码自动生成工具来快速了解FreeMarker。"></a>FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html web 页面 和 代码自动生成工具来快速了解FreeMarker。</h5><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>FreeMarker是一款用java语言编写的模版引擎，它虽然不是web应用框架，但它很合适作为web应用框架的一个组件。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>==轻量级==模版引擎，不需要Servlet环境就可以很轻松的嵌入到应用程序中</li><li>能生成各种文本，如html，xml，java，等</li><li>入门==简单==，它是用java编写的，很多语法和java相似</li></ol><h3 id="FreeMarker-程序"><a href="#FreeMarker-程序" class="headerlink" title="FreeMarker 程序"></a>FreeMarker 程序</h3><p>这里通过模拟简单的代码自动生产工具来感受第一个FreeMarker程序。</p><h6 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h6><p><img src="https://note.youdao.com/yws/api/personal/file/7F3E305ECC7C4D43B3723E432DABD9F5?method=download&amp;shareKey=871330817cb4fa023023ff95f9c3a3de" alt="image"></p><h6 id="eclipse安装freemarker插件"><a href="#eclipse安装freemarker插件" class="headerlink" title="eclipse安装freemarker插件"></a>eclipse安装freemarker插件</h6><div class="note default no-icon"><p>Help –&gt; Install New Software<br>点add，再出来的对话框中的Location中输入：<a href="http://download.jboss.org/jbosstools/updates/stable/indigo/" target="_blank" rel="noopener">http://download.jboss.org/jbosstools/updates/stable/indigo/</a><br>name随便取一个即可。然后会列出来所有可用的插件，<br>JBoss Application Development 下找到 FreeMarker IDE选中 点击Next<br>安装好重启eclipse就可以了。<br>过程可能有点慢，请==耐心等待==。</p></div><h6 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hello.ftl模板(部分)<br><img src="https://note.youdao.com/yws/api/personal/file/65DD084F98E647AB86F1D08C5440559F?method=download&amp;shareKey=78c42c5bd58a114675064cd0e0386924" alt="image"></p><p>FreeMarkerDemo.java 核心方法，使用 FreeMarker 模版引擎。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.freemarker.hello.templates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.freemarker.hello.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最常见的问题： java.io.FileNotFoundException: xxx does not exist. 解决方法：要有耐心</span></span><br><span class="line"><span class="comment"> * FreeMarker jar 最新的版本（2.3.23）提示 Configuration 方法被弃用 代码自动生产基本原理： 数据填充</span></span><br><span class="line"><span class="comment"> * freeMarker 占位符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> TEMPLATE_PATH = <span class="string">"src/main/java/com/freemarker/hello/templates"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> CLASS_PATH = <span class="string">"src/main/java/com/freemarker/hello"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;User&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">User u1 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"1"</span>, <span class="number">22</span>, <span class="string">"迟到峰"</span>);</span><br><span class="line">User u2 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"2"</span>, <span class="number">23</span>, <span class="string">"要饭楚"</span>);</span><br><span class="line">User u3 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"3"</span>, <span class="number">27</span>, <span class="string">"BUG李"</span>);</span><br><span class="line">User u4 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"4"</span>, <span class="number">25</span>, <span class="string">"删库冬"</span>);</span><br><span class="line">User u5 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"5"</span>, <span class="number">29</span>, <span class="string">"瓜子军"</span>);</span><br><span class="line">User u6 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"6"</span>, <span class="number">28</span>, <span class="string">"老韩"</span>);</span><br><span class="line">User u7 = <span class="keyword">new</span> <span class="type">User</span>(<span class="literal">null</span>, <span class="number">25</span>, <span class="literal">null</span>);</span><br><span class="line">users.add(u1);</span><br><span class="line">users.add(u2);</span><br><span class="line">users.add(u3);</span><br><span class="line">users.add(u4);</span><br><span class="line">users.add(u5);</span><br><span class="line"><span class="comment">//users.add(null);</span></span><br><span class="line">users.add(u6);</span><br><span class="line"><span class="comment">//users.add(u7);</span></span><br><span class="line"><span class="comment">//users.clear();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">// step1 创建freeMarker配置实例</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> <span class="type">Configuration</span>(Configuration.VERSION_2_3_23);</span><br><span class="line">Writer out = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// step2 获取模版路径</span></span><br><span class="line">configuration.setDirectoryForTemplateLoading(<span class="keyword">new</span> <span class="type">File</span>(TEMPLATE_PATH));</span><br><span class="line"><span class="comment">// step3 创建数据模型</span></span><br><span class="line">Map&lt;<span class="keyword">String</span>, Object&gt; dataMap = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, Object&gt;();</span><br><span class="line">dataMap.put(<span class="string">"classPath"</span>, <span class="string">"com.freemarker.hello"</span>);</span><br><span class="line">dataMap.put(<span class="string">"htmlName"</span>, <span class="string">"使用FreeMarker生成html模板"</span>);</span><br><span class="line">dataMap.put(<span class="string">"helloWorld"</span>, <span class="string">"通过简单的 &lt;代码自动生产程序&gt; 演示 FreeMarker的HelloWorld！"</span>);</span><br><span class="line">dataMap.put(<span class="string">"author"</span>, <span class="string">"周宇峰"</span>);</span><br><span class="line">dataMap.put(<span class="string">"github"</span>, <span class="string">"github.com/542869246"</span>);</span><br><span class="line">dataMap.put(<span class="string">"name"</span>, <span class="string">"abcdefg"</span>);</span><br><span class="line">dataMap.put(<span class="string">"dateTime"</span>,<span class="keyword">new</span> <span class="type">Date</span>());</span><br><span class="line">dataMap.put(<span class="string">"users"</span>, users);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step4 加载模版文件</span></span><br><span class="line">Template template = configuration.getTemplate(<span class="string">"hello.ftl"</span>);</span><br><span class="line"><span class="comment">// step5 生成数据</span></span><br><span class="line">File docFile = <span class="keyword">new</span> <span class="type">File</span>(CLASS_PATH + <span class="string">"\\"</span> + <span class="string">"hello.html"</span>);</span><br><span class="line">out = <span class="keyword">new</span> <span class="type">BufferedWriter</span>(<span class="keyword">new</span> <span class="type">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(docFile)));</span><br><span class="line"><span class="comment">// step6 输出文件</span></span><br><span class="line">template.process(dataMap, out);</span><br><span class="line">System.out.println(<span class="string">"文件创建成功 !"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != out) &#123;</span><br><span class="line">out.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">e2.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序后刷新项目，会发现多了一个hello.html文件。</p><h2 id="语法详解"><a href="#语法详解" class="headerlink" title="语法详解"></a>语法详解</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h6 id="和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。"><a href="#和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。" class="headerlink" title="和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。"></a>和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。</h6><p>字符串： value = “xxxx” 。 单引号和双引号是一样的。字符串中可以使用转义字符”\”。如果字符串内有大量的特殊字符，则可以在引号的前面加上一个字母r，则字符串内的所有字符都将直接输出。string = r”xxxx”。</p><p>数值：value = 1.2。数值可以直接等于，但是不能用科学计数法。</p><p>布尔值：true or false。</p><p>List集合：list = [1,2,3] ; list=[1..100] 表示 1 到 100 的集合，反之亦然。</p><p>Map集合：map = {“key” : “value” , “key2” : “value2”}，key 必须是字符串</p><p>时间对象:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="built_in">put</span>(<span class="string">"date1"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">$&#123;date1?<span class="keyword">string</span>(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)&#125;</span><br></pre></td></tr></table></figure><p>JaveBean：Freemarker中对于javabean的处理跟EL表达式一致，类型可自动转化！非常方便！</p><h6 id="注释：-lt-–-abcd-–-gt"><a href="#注释：-lt-–-abcd-–-gt" class="headerlink" title="注释：&lt;#– abcd –&gt;"></a>注释：&lt;#– abcd –&gt;</h6><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h6 id="声明变量和输出"><a href="#声明变量和输出" class="headerlink" title="声明变量和输出:"></a>声明变量和输出:</h6><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign name=<span class="string">"zyf"</span>&gt;         <span class="comment">//声明一个变量值为zyf的变量name</span></span><br><span class="line">$&#123;name&#125;                      <span class="comment">//输出name  结果为zyf</span></span><br><span class="line">&lt;#assign cname=<span class="string">r"特殊字符完成输出(https://github.com/542869246)"</span>&gt;</span><br><span class="line">$&#123;cname&#125;</span><br></pre></td></tr></table></figure><h5 id="字符串连接："><a href="#字符串连接：" class="headerlink" title="字符串连接："></a>字符串连接：</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用嵌套或者+ 进行字符串连接操作</span></span><br><span class="line"><span class="symbol">$</span>&#123;<span class="string">"Hello $&#123;name&#125; !"</span>&#125; / <span class="symbol">$</span>&#123;<span class="string">"Hello "</span> + name + <span class="string">" !"</span>&#125;</span><br><span class="line"><span class="comment">//输出：Hello zyf ! / Hello zyf !</span></span><br></pre></td></tr></table></figure><h5 id="字符串截取："><a href="#字符串截取：" class="headerlink" title="字符串截取："></a>字符串截取：</h5><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign a=<span class="string">"abcdefg"</span>&gt;</span><br><span class="line">$&#123;a[<span class="number">1</span>]&#125;                     <span class="comment">//b</span></span><br><span class="line">$&#123;a[<span class="number">1.</span><span class="number">.5</span>]&#125;                  <span class="comment">//bcdef</span></span><br><span class="line">$&#123;a?substring(<span class="number">3</span>)&#125;           <span class="comment">//efg</span></span><br><span class="line">$&#123;a?substring(<span class="number">3</span>,<span class="number">2</span>)&#125;         <span class="comment">//ef</span></span><br></pre></td></tr></table></figure><div class="note default"><p>string[index]。index 可以是一个值，也可以是形如 0..2 表示下标从0开始，到下标为2结束。一共是三个数。<br>substring（start,end）从一个字符串中截取子串。<br>start:截取子串开始的索引，start必须大于等于0，小于等于end。<br>end: 截取子串的长度，end必须大于等于0，小于等于字符串长度，如果省略该参数，默认为字符串长度。</p></div><h3 id="算数运算："><a href="#算数运算：" class="headerlink" title="算数运算："></a>算数运算：</h3><p>支持”+”、”－”、”*”、”/“、”%”运算符</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="attr">#assign number1</span>=<span class="number">10</span> <span class="symbol">number2</span>=<span class="number">5</span> &gt;</span><br><span class="line"><span class="string">"+"</span>:$&#123;<span class="symbol">number1</span> + <span class="symbol">number2</span> &#125;       <span class="comment">//15</span></span><br><span class="line"><span class="string">"-"</span>:$&#123;<span class="symbol">number1</span> - <span class="symbol">number2</span> &#125;       <span class="comment">//5</span></span><br><span class="line"><span class="string">"*"</span>:$&#123;<span class="symbol">number1</span> * <span class="symbol">number2</span> &#125;       <span class="comment">//50</span></span><br><span class="line"><span class="string">"/"</span>:$&#123;<span class="symbol">number1</span> / <span class="symbol">number2</span> &#125;       <span class="comment">//2</span></span><br><span class="line"><span class="string">"%"</span>:$&#123;<span class="symbol">number1</span> <span class="meta">%</span> <span class="symbol">number2</span> &#125;       <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>表达式中支持的比较运算符有如下几种：</p><ol><li>=（或者==）：判断两个值是否相等；</li><li>!=：判断两个值是否不相等；<br>注： =和!=可以用作字符串、数值和日期的比较，但两边的数据类型必须相同。而且FreeMarker的比较是精确比较，==不会忽略大小写及空格==。</li><li>>（或者gt）：大于</li><li>>=（或者gte）：大于等于</li><li>&lt;（或者lt）：小于</li><li>&lt;=（或者lte）：小于等于</li><li><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="attr">#if number1</span> + <span class="symbol">number2</span> gte <span class="number">12</span> || <span class="symbol">number1</span> - <span class="symbol">number2</span> <span class="keyword">lt</span> <span class="number">6</span>&gt;</span><br><span class="line"><span class="string">"*"</span> : $&#123;<span class="symbol">number1</span> * <span class="symbol">number2</span>&#125;</span><br><span class="line">&lt;<span class="attr">#else&gt;</span></span><br><span class="line"><span class="attr">"/" : $&#123;number1</span> / <span class="symbol">number2</span>&#125;</span><br><span class="line">&lt;/<span class="attr">#if&gt;</span></span><br></pre></td></tr></table></figure></li></ol><div class="note info"><p>上面这些比较运算符可以用于数字和日期，但不能用于字符串。大部分时候，使用==gt比&gt;有更好的效果==，因为FreeMarker会把&gt;解释成标签的结束字符。可以使用括号来避免这种情况，如：&lt;#if (x&gt;y)&gt;。</p></div><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>&amp;&amp;：逻辑与；</li><li>||：逻辑或；</li><li>!：逻辑非<div class="note info"><p>逻辑运算符只能用于布尔值。</p></div></li></ol><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><div class="note info"><p>FreeMarker还提供了一些内建函数来转换输出,可以在任何变量后紧跟?,?后紧跟内建函数,就可以通过内建函数来轮换输出变量.下面是常用的内建的字符串函数</p></div><h5 id="字符串相关常用的内建函数："><a href="#字符串相关常用的内建函数：" class="headerlink" title="字符串相关常用的内建函数："></a>字符串相关常用的内建函数：</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign data = <span class="string">"abcd1234"</span>&gt;</span><br><span class="line">html：对字符串进行HTML编码，将字符串中的&lt;、&gt;、&amp;和“替换为对应得&amp;lt;&amp;gt;&amp;quot:&amp;amp</span><br><span class="line"></span><br><span class="line">cap_first：使字符串第一个字母大写 <span class="variable">$&#123;data</span>?cap_first&#125;</span><br><span class="line"></span><br><span class="line">lower_case：将字符串转成小写 <span class="variable">$&#123;data</span>?lower_case&#125;</span><br><span class="line"></span><br><span class="line">upper_case：将字符串转成大写 <span class="variable">$&#123;data</span>?upper_case&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trim</span>:去掉字符串前后的空白字符 <span class="variable">$&#123;data</span>?<span class="keyword">trim</span>&#125;</span><br><span class="line"></span><br><span class="line">length:返回字符串的长度 $&#123;<span class="string">"string"</span>?length&#125;</span><br><span class="line"></span><br><span class="line">index_of(substring,start)在字符串中查找某个子串，返回找到子串的第一个字符的索引，如果没有找到子串，则返回-1。</span><br><span class="line">Start参数用于指定从字符串的那个索引处开始搜索，start为数字值。</span><br><span class="line">如果start大于字符串长度，则start取值等于字符串长度，如果start小于0， 则start取值为0。</span><br><span class="line">$&#123;<span class="string">"string"</span>?index_of(<span class="string">"in"</span>) 结果为3</span><br><span class="line">$&#123;<span class="string">"string"</span>?index_of(<span class="string">"ab"</span>) 结果为-1</span><br><span class="line"></span><br><span class="line"><span class="keyword">replace</span>用于将字符串中的一部分从左到右替换为另外的字符串。</span><br><span class="line">$&#123;<span class="string">"strabg"</span>?<span class="keyword">replace</span>(<span class="string">"ab"</span>,<span class="string">"in"</span>)&#125; 结果为<span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">split</span>使用指定的分隔符将一个字符串拆分为一组字符串</span><br><span class="line">&lt;#<span class="keyword">list</span> <span class="string">"This|is|split"</span>?<span class="keyword">split</span>(<span class="string">"|"</span>") <span class="keyword">as</span> s&gt;</span><br><span class="line"><span class="variable">$&#123;s&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">结果为:</span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="keyword">split</span></span><br></pre></td></tr></table></figure><h5 id="集合相关常用的内建函数："><a href="#集合相关常用的内建函数：" class="headerlink" title="集合相关常用的内建函数："></a>集合相关常用的内建函数：</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>：获得集合中元素的个数 $&#123;users?<span class="built_in">size</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="数字值相关常用的内建函数："><a href="#数字值相关常用的内建函数：" class="headerlink" title="数字值相关常用的内建函数："></a>数字值相关常用的内建函数：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#assign floatData = 12.34&gt;</span></span><br><span class="line"><span class="keyword">int</span>：取得数字的整数部分 $&#123;floatData?<span class="keyword">int</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;(users?size <span class="literal">gt</span> <span class="number">15</span>)?<span class="built_in">string</span>(<span class="string">'a'</span>,<span class="string">'b'</span>) &#125;</span><br><span class="line">&lt;#assign theValue = (temp == <span class="string">"default"</span>)?<span class="built_in">string</span>(<span class="string">'true'</span>,<span class="string">'false'</span>) /&gt;</span><br></pre></td></tr></table></figure><h3 id="空值处理运算符"><a href="#空值处理运算符" class="headerlink" title="空值处理运算符"></a>空值处理运算符</h3><div class="note default no-icon"><p>FreeMarker对空值的处理非常严格,==FreeMarker的变量必须有值==,没有被赋值的变量就会抛出异常,因为FreeMarker未赋值的变量强制出错可以杜绝很多潜在的错误,如缺失潜在的变量命名,或者其他变量错误.这里所说的空值,实际上也包括那些并不存在的变量,对于一个Java的 null值而言,我们认为这个变量是存在的,只是它的值为null,但对于FreeMarker模板而言,它无法理解null值,null值和不存在的变量完全相同。</p></div><h6 id="FreeMarker提供两个运算符来避免空值"><a href="#FreeMarker提供两个运算符来避免空值" class="headerlink" title="FreeMarker提供两个运算符来避免空值"></a>FreeMarker提供两个运算符来避免空值</h6><ol><li>!：指定缺失变量的默认值</li><li>??：判断变量是否存在</li></ol><div class="note default no-icon"><p>!运算符有两种用法：variable!或variable!defaultValue。第一种用法不给变量指定默认值，表明默认值是空字符串、长度为0的集合、或长度为0的Map对象。==使用!运算符指定默认值并不要求默认值的类型和变量类型相同==。</p></div><div class="note default no-icon"><p>??运算符返回布尔值，如：variable??，如果变量存在，返回true，否则返回false。</p></div><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#<span class="meta-keyword">if</span> user??&gt;</span></span><br><span class="line">    $&#123;user.<span class="built_in">name</span>!<span class="string">"变量为空则给一个默认值"</span>&#125;</span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">else</span>&gt;</span></span><br><span class="line">    users为空</span><br><span class="line">&lt;/<span class="meta">#<span class="meta-keyword">if</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><div class="note default no-icon"><p>FreeMarker的FTL指令也是模板的重要组成部分,这些指令可实现对数据模型所包含数据的抚今迭代,分支控制.除此之外,还有一些重要的功能,也是通过FTL指令来实现的. </p></div><h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><p>这是一个典型的分支控制指令,该指令的作用完全类似于Java语言中的if,if指令的语法格式如下<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#assign age=23&gt; </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">if</span> (age&gt;60)&gt;老年人 </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">elseif</span> (age&gt;40)&gt;中年人 </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">elseif</span> (age&gt;20)&gt;青年人 </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">else</span>&gt; 少年人 </span></span><br><span class="line">&lt;/<span class="meta">#<span class="meta-keyword">if</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="switch-case指令"><a href="#switch-case指令" class="headerlink" title="switch case指令"></a>switch case指令</h4><p>switch（expr）,其中expr只能是字符串、基本类型int或者包装类Integer，也包括不同的长度整型，例如short<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#switch being.size&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#case "small"&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> small  </span><br><span class="line">          &lt;<span class="comment">#break&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#case "medium"&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> medium  </span><br><span class="line">          &lt;<span class="comment">#break&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#case "large"&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> large  </span><br><span class="line">          &lt;<span class="comment">#break&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#default&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> neither  </span><br><span class="line">&lt;/<span class="comment">#switch&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h4><div class="note default no-icon"><p>list指令是一个迭代输出指令,用于迭代输出数据模型中的集合<br>sequence是集合(collection)的表达式，item是循环变量的名字，不能是表达式。<br>当在遍历sequence时，会将遍历变量的值保存到item中</p></div><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">&lt;#<span class="keyword">list</span> sequence <span class="keyword">as</span> item&gt;    </span><br><span class="line">  <span class="variable">$&#123;item&#125;</span>   </span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历users集合 获取user对象属性</span></span><br><span class="line">&lt;#<span class="keyword">list</span> users <span class="keyword">as</span> user&gt;    </span><br><span class="line">  <span class="variable">$&#123;user</span>.id&#125;--<span class="variable">$&#123;user</span>.age&#125;--&#123;user.name&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><h6 id="List指令还隐含了两个循环变量："><a href="#List指令还隐含了两个循环变量：" class="headerlink" title="List指令还隐含了两个循环变量："></a>List指令还隐含了两个循环变量：</h6><p>item_index:当前迭代项在所有迭代项中的位置，是数字值。</p><p>item_has_next:用于判断当前迭代项是否是所有迭代项中的最后一项。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">users</span> <span class="attr">as</span> <span class="attr">user</span>&gt;</span>    </span></span><br><span class="line"><span class="xml">  $</span><span class="template-variable">&#123;user_index&#125;</span><span class="xml">--$</span><span class="template-variable">&#123;user.id&#125;</span><span class="xml">--$</span><span class="template-variable">&#123;user.age&#125;</span><span class="xml">--</span><span class="template-variable">&#123;user.name&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#if</span> !<span class="attr">user_has_next</span>&gt;</span></span></span><br><span class="line"><span class="xml">        共有$</span><span class="template-variable">&#123;users?size&#125;</span><span class="xml">最后一个用户是:$</span><span class="template-variable">&#123;user.name&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">#if</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h6 id="对List进行排序"><a href="#对List进行排序" class="headerlink" title="对List进行排序"></a>对List进行排序</h6><div class="note default no-icon"><p>通常我们的排序操作都是通过DAO层来实现的，如果我们想随时更改我们的排序，那么就必须修改我们的DAO层代码，确实不方便。但Freemarker为我们提供了这样的排序方法，解决了这个问题。</p></div><ol><li>sort升序排序函数<br>sort对序列(sequence)进行排序，要求序列中的变量必须是：字符串（按首字母排序）,数字，日期值。</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> <span class="keyword">list</span>?<span class="keyword">sort</span> <span class="keyword">as</span> <span class="keyword">l</span>&gt;…&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>sort_by函数<br>sort_by有一个参数,该参数用于指定想要排序的子变量，排序是按照变量对应的值进行排序,如：</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list users?sort_by(<span class="string">"age"</span>) <span class="keyword">as</span> user&gt;…&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>age是User对象的属性，排序是按age的值进行的。</p><ol start="3"><li>reverse降序排序函数</li></ol><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="built_in">list</span> <span class="built_in">list</span>? reverse <span class="keyword">as</span> l&gt;…&lt;/#<span class="built_in">list</span>&gt;。</span><br></pre></td></tr></table></figure><p>reverse使用同sort相同。reverse还可以同sort_by一起使用<br>如：想让用户按年龄降序排序，那么可以这个样写</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list users?sort_by(<span class="string">"age"</span>)?reverse <span class="keyword">as</span> user&gt;…&lt;/#list&gt;</span><br></pre></td></tr></table></figure><h5 id="使用list指令遍历map"><a href="#使用list指令遍历map" class="headerlink" title="使用list指令遍历map"></a>使用list指令遍历map</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个map,注意在freemarker中,map的key只能是字符串来作为key</span></span><br><span class="line">&lt;#assign userMap=&#123;<span class="string">"1"</span>,<span class="string">"刘德华"</span>,<span class="string">"2"</span>:<span class="string">"张学友"</span>&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取map中的值</span></span><br><span class="line"><span class="variable">$&#123;userMap</span>[<span class="string">"1"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取map的keys</span></span><br><span class="line">&lt;#assign  keys=userMap?keys/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历map 首选获取key的集合</span></span><br><span class="line">&lt;#<span class="keyword">list</span> keys <span class="keyword">as</span> key&gt;</span><br><span class="line">  key:<span class="variable">$&#123;key&#125;</span>-value:<span class="variable">$&#123;userMap</span>[<span class="string">"$&#123;key&#125;"</span>]&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接遍历map的第二种方式</span></span><br><span class="line">&lt;#<span class="keyword">list</span> userMap?keys <span class="keyword">as</span> key&gt;</span><br><span class="line">  key:<span class="variable">$&#123;key&#125;</span>--value:<span class="variable">$&#123;userMap</span>[<span class="string">"$&#123;key&#125;"</span>]&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接遍历map的values</span></span><br><span class="line">&lt;#<span class="keyword">list</span> userMap?values <span class="keyword">as</span> value&gt;</span><br><span class="line"> <span class="variable">$&#123;value&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><p>include指令的作用类似于JSP的包含指令,用于包含指定页</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">现在有hello.ftl、inc1.ftl与inc2<span class="selector-class">.ftl</span> <span class="number">3</span>个模板</span><br><span class="line">在inc1.ftl与inc2.ftl中的内容分别是:</span><br><span class="line">&lt;<span class="selector-id">#assign</span> username=<span class="string">"刘德华"</span>&gt;与&lt;<span class="selector-id">#assign</span> username=<span class="string">"张学友"</span>&gt;</span><br><span class="line"></span><br><span class="line">接着在hello.ftl模版中用include将inc1.ftl包含进来</span><br><span class="line">&lt;<span class="selector-id">#include</span> <span class="string">"/inc/inc1.ftl"</span>&gt;</span><br><span class="line">$&#123;username&#125;</span><br><span class="line">此刻获取的结果是:刘德华</span><br><span class="line"></span><br><span class="line">接着我们在hello.ftl用include将inc1.ftl与inc2.ftl同时进行包含进来</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-id">#include</span> <span class="string">"/inc/inc1.ftl"</span>&gt;</span><br><span class="line">&lt;<span class="selector-id">#include</span> <span class="string">"/inc/inc2.ftl"</span>&gt;</span><br><span class="line">$&#123;username&#125;</span><br><span class="line"></span><br><span class="line">此刻获取的值是:张学友</span><br></pre></td></tr></table></figure><h6 id="总结：出现这种情况，在-两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖-，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入"><a href="#总结：出现这种情况，在-两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖-，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入" class="headerlink" title="总结：出现这种情况，在==两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖==，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入"></a>总结：出现这种情况，在==两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖==，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入</h6><h4 id="import指令"><a href="#import指令" class="headerlink" title="import指令"></a>import指令</h4><p>该指令用于导入FreeMarker模板中的所有变量,并将该变量放置在指定的Map对象中</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接着上面</span><br><span class="line">在hello.ftl用<span class="keyword">import</span>指令将inc1.ftl与inc2.ftll模板文件中的所有变量,同时导入进来</span><br><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/inc/inc1.ftl"</span> <span class="keyword">as</span> inc1&gt;</span><br><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/inc/inc2.ftl"</span> <span class="keyword">as</span> inc2&gt;</span><br><span class="line"></span><br><span class="line">$&#123;inc1.username&#125;    <span class="comment">//刘德华</span></span><br><span class="line">$&#123;inc2.username&#125;    <span class="comment">//张学友</span></span><br></pre></td></tr></table></figure><h4 id="noparse指令"><a href="#noparse指令" class="headerlink" title="noparse指令"></a>noparse指令</h4><p>noparse指令指定FreeMarker不处理该指定里包含的内容,该指令的语法格式如下</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#noparse</span>&gt;</span>...<span class="tag">&lt;/<span class="name">#noparse</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">看如下的例子: </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#noparse</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">books</span> <span class="attr">as</span> <span class="attr">book</span>&gt;</span> </span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$</span><span class="template-variable">&#123;book.name&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>作者:$</span><span class="template-variable">&#123;book.author&#125;</span><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#noparse</span>&gt;</span> </span></span><br><span class="line"><span class="xml">输出如下: </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">books</span> <span class="attr">as</span> <span class="attr">book</span>&gt;</span> </span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$</span><span class="template-variable">&#123;book.name&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>作者:$</span><span class="template-variable">&#123;book.author&#125;</span><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="assign指令"><a href="#assign指令" class="headerlink" title="assign指令"></a>assign指令</h4><div class="note default no-icon"><p>assign指令在前面已经使用了多次,它用于为该模板页面创建或替换一个顶层变量,assign指令的用法有多种,包含创建或替换一个顶层变量, 或者创建或替换多个变量等,它的最简单的语法如下:&lt;#assign name=value [in namespacehash]&gt;,这个用法用于指定一个名为name的变量,该变量的值为value,此外,FreeMarker允许在使用 assign指令里增加in子句,in子句用于将创建的name变量放入namespacehash命名空间中<br>assign指令还有如下用法:</p></div><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign name1=value1 name2=value2 ... nameN=valueN [<span class="keyword">in</span> namespacehash]&gt;</span><br><span class="line">这个语法可以同时创建或替换多个顶层变量,此外,还有一种复杂的用法,如果需要创建或替换的变量值是一个复杂的表达式,则可以使用如下语法格式:</span><br><span class="line">&lt;#assign name [<span class="keyword">in</span> namespacehash]&gt;capture this&lt;/#assign&gt;</span><br><span class="line">在这个语法中,是指将assign指令的内容赋值给name变量.如下例子:</span><br><span class="line">&lt;#assign x&gt; </span><br><span class="line">&lt;#list [<span class="string">"星期一"</span>, <span class="string">"星期二"</span>, <span class="string">"星期三"</span>, <span class="string">"星期四"</span>, <span class="string">"星期五"</span>, <span class="string">"星期六"</span>, <span class="string">"星期天"</span>] <span class="keyword">as</span> n&gt; </span><br><span class="line">$&#123;n&#125; </span><br><span class="line">&lt;/#list&gt; </span><br><span class="line">&lt;/#assign&gt; </span><br><span class="line">$&#123;x&#125; </span><br><span class="line">上面的代码将产生如下输出:星期一 星期二 星期三 星期四 星期五 星期六 星期天</span><br></pre></td></tr></table></figure><h6 id="虽然assign指定了这种复杂变量值的用法-但是我们也不要滥用这种用法-如下例子"><a href="#虽然assign指定了这种复杂变量值的用法-但是我们也不要滥用这种用法-如下例子" class="headerlink" title="虽然assign指定了这种复杂变量值的用法,但是我们也不要滥用这种用法,如下例子:"></a>虽然assign指定了这种复杂变量值的用法,但是我们也不要滥用这种用法,如下例子:</h6><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">x</span>&gt;</span>Hello $</span><span class="template-variable">&#123;user&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">#assign</span>&gt;</span></span></span><br><span class="line"><span class="xml">以上代码改为如下写法更合适:</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">x</span>=<span class="string">"Hello $</span></span></span><span class="template-variable">&#123;user&#125;</span><span class="xml"><span class="tag"><span class="string">!"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="setting指令"><a href="#setting指令" class="headerlink" title="setting指令"></a>setting指令</h4><p>该指令用于设置FreeMarker的运行环境,该指令的语法格式如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#setting</span> <span class="attr">name</span>=<span class="string">value</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个格式中,name的取值范围包含如下几个：</p><p>locale:该选项指定该模板所用的国家/语言选项 </p><p>number_format:指定格式化输出数字的格式</p><p>boolean_format:指定两个布尔值的语法格式,默认值是true,false </p><p>date_format,time_format,datetime_format:指定格式化输出日期的格式 </p><p>time_zone:设置格式化输出日期时所使用的时区</p><h4 id="自定义指令-macro指令-宏"><a href="#自定义指令-macro指令-宏" class="headerlink" title="自定义指令(macro指令)(宏)"></a>自定义指令(macro指令)(宏)</h4><p>语法：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro name param1 param2 ... paramN&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#nested loopvar1, loopvar2, ..., loopvarN&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#return&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure><p>用例：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义名为test的指令</span></span><br><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">test</span> foo bar=<span class="string">"Bar"</span> baaz=-1&gt;</span><br><span class="line">这是自定义指令: <span class="variable">$&#123;foo&#125;</span>, <span class="variable">$&#123;bar&#125;</span>, <span class="variable">$&#123;baaz&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用test指令</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> bar=<span class="string">"b"</span> baaz=5*5-2/&gt; <span class="comment">//这是自定义指令: a, b, 23</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> bar=<span class="string">"b"</span>/&gt;            <span class="comment">//这是自定义指令: a, b, -1</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> baaz=5*5-2/&gt;         <span class="comment">//这是自定义指令: a, Bar, 23</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span>/&gt;                    <span class="comment">//这是自定义指令: a, Bar, -1</span></span><br></pre></td></tr></table></figure><div class="note default no-icon"><p>可以提前返回，比如&lt;#return/&gt; 但是不能&lt;#return 1&gt;， ==A macro cannot return a value==<br>==宏主要作用是拼接内容，把宏内部的字符串展示出来，return返回值没有意义==。</p></div><h4 id="function指令-函数"><a href="#function指令-函数" class="headerlink" title="function指令(函数)"></a>function指令(函数)</h4><p>用例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">#function</span> <span class="attr">buildPageUrl</span> <span class="attr">url</span> <span class="attr">pageNum</span> <span class="attr">data</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">pageUrl</span> = <span class="string">"$</span></span></span><span class="template-variable">&#123;url&#125;</span><span class="xml"><span class="tag"><span class="string">?pageNum=$</span></span></span><span class="template-variable">&#123;pageNum&#125;</span><span class="xml"><span class="tag"><span class="string">&amp;pageSize=$</span></span></span><span class="template-variable">&#123;data.pageSize&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#return</span> <span class="attr">pageUrl</span>/&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#function</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;buildPageUrl(url2,page.pageNum+1,page)&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><div class="note default no-icon"><p>与宏的调用方式不同，直接 ${buildPageUrl(url2,page.pageNum+1,page)}执行函数。==返回值才是最关键的结果，不是为了显示函数内部的字符串内容==。</p></div><h3 id="参考文章（特别鸣谢）："><a href="#参考文章（特别鸣谢）：" class="headerlink" title="参考文章（特别鸣谢）："></a>参考文章（特别鸣谢）：</h3><p><a href="https://blog.csdn.net/qq_34129814/article/details/76218863" target="_blank" rel="noopener">https://blog.csdn.net/qq_34129814/article/details/76218863</a></p><p><a href="https://segmentfault.com/a/1190000011768799" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011768799</a></p><p><a href="https://blog.csdn.net/fhx007/article/details/7902040/" target="_blank" rel="noopener">https://blog.csdn.net/fhx007/article/details/7902040/</a></p><p><a href="https://www.cnblogs.com/qitian1/p/6463098.html" target="_blank" rel="noopener">https://www.cnblogs.com/qitian1/p/6463098.html</a></p><hr><h4 id="源码地址："><a href="#源码地址：" class="headerlink" title="源码地址："></a>源码地址：</h4><h6 id="github-https-github-com-542869246-myfreemarker"><a href="#github-https-github-com-542869246-myfreemarker" class="headerlink" title="github: https://github.com/542869246/myfreemarker"></a>github: <a href="https://github.com/542869246/myfreemarker" target="_blank" rel="noopener">https://github.com/542869246/myfreemarker</a></h6><h6 id="码云-https-gitee-com-zyf542869246-myfreemarker"><a href="#码云-https-gitee-com-zyf542869246-myfreemarker" class="headerlink" title="码云: https://gitee.com/zyf542869246/myfreemarker"></a>码云: <a href="https://gitee.com/zyf542869246/myfreemarker" target="_blank" rel="noopener">https://gitee.com/zyf542869246/myfreemarker</a></h6><hr><h6 id="Author-周宇峰"><a href="#Author-周宇峰" class="headerlink" title="Author:周宇峰"></a>Author:周宇峰</h6><h6 id="Github-https-github-com-542869246"><a href="#Github-https-github-com-542869246" class="headerlink" title="Github:https://github.com/542869246"></a>Github:<a href="https://github.com/542869246" target="_blank" rel="noopener">https://github.com/542869246</a></h6><h6 id="码云-https-gitee-com-zyf542869246"><a href="#码云-https-gitee-com-zyf542869246" class="headerlink" title="码云:https://gitee.com/zyf542869246"></a>码云:<a href="https://gitee.com/zyf542869246" target="_blank" rel="noopener">https://gitee.com/zyf542869246</a></h6><h6 id="Time-2018-5-14-1-45-11"><a href="#Time-2018-5-14-1-45-11" class="headerlink" title="Time:2018/5/14 1:45:11"></a>Time:2018/5/14 1:45:11</h6>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> FreeMarker </tag>
            
            <tag> 模板引擎 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>My New Project</title>
      <link href="/2018/07/30/My-New-Project/"/>
      <url>/2018/07/30/My-New-Project/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><p>写啥好呢？</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/29/hello-world/"/>
      <url>/2018/07/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p><span><br><a id="more"></a><br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[< !DOCTYPE html><html lang="en"><head>     <meta charset="UTF-8">     <title>404页面</title></head><body><script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homepageurl="http://yfzhou.coding.me" homepagename="回到我的主页"></script></body></html>]]></content>
      
    </entry>
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>About</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<div class="about-page"><br><div class="note default no-icon"><p>🍀 基础信息</p></div><ul><li>☯微信☯：ZYF542869246 (网站底部扫描二维码)</li><li>🐧QQ🐧：<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=542869246&website=www.oicqzone.com" target="_blank" rel="noopener">542869246</a></li><li>📧E-mail📧：<a href="mailto:18851200889@163.com" target="_blank" rel="noopener">18851200889@163.com</a></li><li>😤GitHub😤: <a href="http://github.com/542869246" title="github.com/542869246" target="_blank" rel="noopener">github.com/542869246</a></li><li>😔码云😔： <a href="https://gitee.com/zyf542869246" title="gitee.com/zyf542869246" target="_blank" rel="noopener">gitee.com/zyf542869246</a></li><li>🚀坐标🚀：南京</li><li>行业：互联网💻</li><li>岗位：IT开发🐵</li></ul><p><hr></p><div class="note default no-icon"><p>🍀 专业技能&amp;热衷方向</p></div><ul><li>Java☕</li><li>SQL</li><li>H5C3</li><li>Python</li></ul><p><hr></p><div class="note default no-icon"><p>个人兴趣</p></div><ul><li>吃🍗</li><li>喝🍹</li><li>拉💩</li><li>撒🙀</li><li>睡💤</li></ul><p><hr></p><div class="note default no-icon"><p>博客简介</p></div><blockquote class="blockquote-center"><p><br><br>此Blog诞生纯属意外，完全是自己一时心血来潮的产物，若有瑕疵，请别bb，我会骂你。😎😎<br><br><br><br></p></blockquote><hr><div class="note default no-icon"><p>我的公众号</p></div><blockquote class="blockquote-center"><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/cli_500px.png" alt=""><br>此公众号诞生也是纯属意外 😏😏</p></blockquote><hr><div class="note default no-icon"><p>更新日志</p></div><div class="note success"><p>[2018/11/28] 更新</p></div><ul><li>注册了个公众号，有兴趣的可以关注一波哦~😤，在关于页面</li></ul><div class="note success"><p>[2018/10/26] 更新</p></div><ul><li>更换Blog背景动态样式<a href="https://github.com/JoanClaret/html5-canvas-animation" title="https://github.com/JoanClaret/html5-canvas-animation" target="_blank" rel="noopener">html5-canvas-animation</a>,关于移动端不能拖动的bug，请<a href="https://github.com/JoanClaret/html5-canvas-animation/issues/10#issuecomment-433308298" title="https://github.com/JoanClaret/html5-canvas-animation/issues/10#issuecomment-433308298" target="_blank" rel="noopener">点击这里</a>查看我的评论。😫</li><li>感谢来自深圳的一名用户反馈背景过于花哨，伤眼。移除<a href="https://github.com/JoanClaret/html5-canvas-animation" title="https://github.com/JoanClaret/html5-canvas-animation" target="_blank" rel="noopener">html5-canvas-animation</a>背景，改用原<a href="https://www.zhihu.com/signup" target="_blank" rel="noopener">知乎登录页面</a>背景+粒子效果。😤</li></ul><div class="note success"><p>[2018/10/20] 更新</p></div><ul><li>更换百度分享插件为<a href="https://github.com/theme-next/theme-next-needmoreshare2" target="_blank" rel="noopener">needmoreshare2</a>。😇</li><li>Blog添加后台管理插件<a href="https://jaredforsyth.com/hexo-admin/" target="_blank" rel="noopener">hexo-admin</a>。😊</li></ul><div class="note success"><p>[2018/10/15] 更新</p></div><ul><li>解决不蒜子插件不显示bug，<a href="https://blog.csdn.net/stormdony/article/details/82980320" title="查看解决方案" target="_blank" rel="noopener">查看解决方案</a> 😎</li></ul><div class="note success"><p>[2018/10/08] 更新</p></div><ul><li>原博客使用的<a href="https://www.algolia.com/" target="_blank" rel="noopener">Algolia</a>站内搜索插件账户过期了，继续使用需要35美金。弃坑，使用自带的<a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">local_search</a>。😒</li></ul><div class="note success"><p>[2018/9/20] 更新</p></div><ul><li>修复<a href="https://yfzhou.coding.me/top/">TopX标签</a>页title不显示的bug。😫</li><li><a href="https://yfzhou.coding.me/top/">TopX标签</a>增加排名序号，随机颜色。😖</li></ul><div class="note success"><p>[2018/9/18] 更新</p></div><ul><li>hexo主题升级 v5-&gt;v6,升级一堆坑😭☠😠</li><li>提升性能，页面打开更快😎</li><li>增加<a href="https://yfzhou.coding.me/top/">TopX标签</a>😎</li><li>全新的页面排版，大幅度修改页面样式😊</li></ul><div class="note success"><p>[2018/9/17] 更新</p></div><ul><li>关闭博客右下角的萌妹子，十个看我Blog的有九个问我怎么弄的，喧宾夺主。😒</li><li>移除浏览器标签搞怪效果，理由同上。😒</li><li>新增<a href="https://yfzhou.coding.me/2018/09/17/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%EF%BC%89/">Hexo-Next搭建个人博客（Hexo博客备份）</a></li><li><a href="https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/">Hexo-Next搭建个人博客（主题优化）</a>更新<span class="label info">11.好玩的写作样式</span></li><li>左侧站点概览新增我的<a href="https://www.zhihu.com/people/yu-sui-58/activities" target="_blank" rel="noopener">知乎</a>和<a href="https://music.163.com/#/user/home?id=343583524" target="_blank" rel="noopener">网易云音乐</a>入口，欢迎互关哦~😤</li></ul><div class="note success"><p>[2018/9/10] 更新</p></div><ul><li>备份博客至<a href="https://github.com/542869246" target="_blank" rel="noopener">Github</a>，麻麻再也不怕我博客数据丢失啦。😏</li></ul><div class="note success"><p>[2018/8/31] 更新</p></div><ul><li>修改主页文章列表显示方式，支持配图😍</li><li>优化文章内应用样式</li><li>优化文章标签样式</li><li>优化标签页</li><li>优化分类页</li><li>优化归档页</li><li>优化博客大部分字体</li></ul><div class="note success"><p>[2018/8/25] 更新</p></div><ul><li>SEO优化，百度收录。☺</li><li>优化主页顶部加载条样式</li><li>优化header部分背景颜色及选中效果</li><li>优化footer部分样式</li><li>回到顶部优化，显示百分比</li></ul><div class="note success"><p>[2018/8/15] 更新</p></div><ul><li>添加各种功能😉</li><li>部分js使用CDN加速</li><li>footer添加时间</li><li>代码块复制</li></ul><div class="note success"><p>[2018/7/29] 更新</p></div><ul><li><a href="https://yfzhou.coding.me/">博客</a>搭建😇</li></ul><p></p></div><p></p>]]></content>
      
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>TopX</title>
      <link href="/top/index.html"/>
      <url>/top/index.html</url>
      
        <content type="html"><![CDATA[<p><div id="top"></div></p><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("4DkhRkq5CadWFisToA3zFrop-gzGzoHsz", "xihAA2ETGTdekJFloguCmmgq");</script><script type="text/javascript">  var time=0  var title=""  var url=""  var query = new AV.Query('Counter');  query.notEqualTo('id',0);  query.descending('time');  query.limit(1000);  query.find().then(function (todo) {    for (var i=0;i<1000;i++){      var result=todo[i].attributes;      time=result.time;      title=result.title;      url=result.url;      var r = parseInt(Math.random()*255,10)+1      var g = parseInt(Math.random()*255,10)+1      var b = parseInt(Math.random()*255,10)+1      var content="<span style='background-color:rgb("+r+", "+g+", "+b+",0.5)' id='inline-toc'>"+(1+i)+".</span>"+"<a href='"+"https://yfzhou.coding.me"+url+"'>"+title+"</a>"+"<br />"+"<font color='#555'>"+"阅读次数：<sapn style='border-radius: 11px;padding: 1px 7px;background-image: linear-gradient(120deg, rgba(247, 149, 51, 0.5) 0%, rgba(243, 112, 85, 0.5) 21%, rgba(239, 78, 123, 0.5) 30%, rgba(161, 102, 171, 0.5) 44%, rgba(80, 115, 184, 0.5) 58%, rgba(16, 152, 173, 0.5) 72%, rgba(7, 179, 155, 0.5) 86%, rgba(109, 186, 130, 0.5) 100%);color: black;'>"+time+"</span></font>"+"<br /><br />";      document.getElementById("top").innerHTML+=content    }  }, function (error) {    console.log("error");  });</script><p><style>.post-description { display: none; }<style></p></style></p>]]></content>
      
    </entry>
    
  
</search>
