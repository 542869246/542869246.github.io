<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yufeng.Zhou&#39;s Blog</title>
  
  <subtitle>卑鄙，是卑鄙者通行证，高尚，是高尚者墓志铭。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yfzhou.coding.me/"/>
  <updated>2018-08-27T11:44:40.723Z</updated>
  <id>https://yfzhou.coding.me/</id>
  
  <author>
    <name>yufeng.Zhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo-Next搭建个人博客（代码块复制功能）</title>
    <link href="https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/27/Hexo-Next搭建个人博客（代码块复制功能）/</id>
    <published>2018-08-27T11:15:55.000Z</published>
    <updated>2018-08-27T11:44:40.723Z</updated>
    
    <content type="html"><![CDATA[<p>为了提高博客代码块的用户体验，仅仅代码高亮还不行，最好还能一键复制代码。故此文将讲述Hexo NexT主题博客的代码块复制功能配置。</p><a id="more"></a><h2 id="下载-clipboard-js"><a href="#下载-clipboard-js" class="headerlink" title="下载 clipboard.js"></a>下载 clipboard.js</h2><p>三方插件 clipboardjs ，相关介绍和兼容性我就不赘述了，去它<a href="https://clipboardjs.com/" target="_blank" rel="noopener">主页</a>或<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">github</a>上看。</p><p><strong>下载地址：</strong></p><ul><li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.js" target="_blank" rel="noopener">clipboard.js</a></li><li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js" target="_blank" rel="noopener">clipboard.min.js</a> <strong>推荐</strong></li></ul><p>保存文件<code>clipboard.js / clipboard.min.js</code> ，目录如下：<br><code>.\themes\next\source\js\src</code></p><h2 id="clipboardjs-使用"><a href="#clipboardjs-使用" class="headerlink" title="clipboardjs 使用"></a>clipboardjs 使用</h2><p>也是在<code>.\themes\next\source\js\src</code>目录下，创建<code>clipboard-use.js</code>，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*页面载入完成后，创建复制按钮*/</span></span><br><span class="line">  !<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> copyHtml = <span class="string">''</span>;</span><br><span class="line">      copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">      <span class="comment">//fa fa-globe可以去字体库替换自己想要的图标</span></span><br><span class="line">copyHtml += <span class="string">'  &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'</span>;</span><br><span class="line">      copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">      $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">      <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">          target: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    initCopyCode();</span><br><span class="line">  &#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>在<code>.\themes\next\source\css\_custom\custom.styl</code>样式文件中添加下面代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码块复制按钮</span></span><br><span class="line">.highlight&#123;</span><br><span class="line">  <span class="comment">//方便copy代码按钮（btn-copy）的定位</span></span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    background-color: #eee;</span><br><span class="line">    background-image: linear-gradient(#fcfcfc,#eee);</span><br><span class="line">    border: 1px solid #d5d5d5;</span><br><span class="line">    border-radius: <span class="number">3</span>px;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">    -webkit-appearance: none;</span><br><span class="line">    font-size: <span class="number">13</span>px;</span><br><span class="line">    font-weight: <span class="number">700</span>;</span><br><span class="line">    line-height: <span class="number">20</span>px;</span><br><span class="line">    color: #333;</span><br><span class="line">    -webkit-transition: opacity <span class="number">.3</span>s ease-<span class="keyword">in</span>-out;</span><br><span class="line">    -o-transition: opacity <span class="number">.3</span>s ease-<span class="keyword">in</span>-out;</span><br><span class="line">    transition: opacity <span class="number">.3</span>s ease-<span class="keyword">in</span>-out;</span><br><span class="line">    padding: <span class="number">2</span>px <span class="number">6</span>px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: <span class="number">5</span>px;</span><br><span class="line">    top: <span class="number">5</span>px;</span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy span &#123;</span><br><span class="line">    margin-left: <span class="number">5</span>px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight:hover .btn-copy&#123;</span><br><span class="line">  opacity: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在<code>.\themes\next\layout\_layout.swig</code>文件中，添加引用（注：在 swig 末尾或 body 结束标签（<code>&lt;/body&gt;</code>）之前添加）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>  </span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard-use.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>效果的可以去<a href="http://yfzhou.coding.me">我博客</a>看</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>懂代码的也可以将<code>clipboard.min.js</code>和<code>clipboard-use.js</code>合并为一个文件，再在<code>.\themes\next\layout\_layout.swig</code>文件中使用。当然<code>clipboard.min.js</code>也可以直接用三方cdn的方式引入也行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了提高博客代码块的用户体验，仅仅代码高亮还不行，最好还能一键复制代码。故此文将讲述Hexo NexT主题博客的代码块复制功能配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（主题优化）</title>
    <link href="https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/27/Hexo-Next搭建个人博客（主题优化）/</id>
    <published>2018-08-27T08:33:30.000Z</published>
    <updated>2018-08-27T11:45:41.457Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Hexo版本是3.7.1</li><li>NexT.Pisces v5.1.4</li></ul><a id="more"></a><h4 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h4><ul><li>Hexo的命令极简单，安装后只需要记住四个常用的即可。执行命令需要Git当前处于blog文件夹根目录下。</li><li>generate 生成静态文件。<br><code>hexo g</code></li><li>server 启动服务器。<br><code>hexo s</code></li><li>deploy 部署网站。部署网站前，需要预先生成静态文件。<br><code>hexo d</code></li><li>clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br><code>hexo clean</code></li><li>卸载Hexo<br><code>npm uninstall hexo-cli -g</code></li></ul><h4 id="2-更换主题-以Next主题为例"><a href="#2-更换主题-以Next主题为例" class="headerlink" title="2.更换主题,以Next主题为例"></a>2.更换主题,以Next主题为例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> your-hexo-site</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>Hexo 站点</code>目录下的<code>_config.yml</code>的主题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><h4 id="3-站点初始设置"><a href="#3-站点初始设置" class="headerlink" title="3.站点初始设置"></a>3.站点初始设置</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Site</span></span><br><span class="line"><span class="symbol">title:</span> Hexo <span class="meta">#网站标题</span></span><br><span class="line"><span class="symbol">subtitle:</span> <span class="meta">#网站副标题</span></span><br><span class="line"><span class="symbol">description:</span> <span class="meta">#网站描述</span></span><br><span class="line"><span class="symbol">author:</span> author <span class="meta">#您的名字</span></span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-Hans <span class="meta">#网站使用的语言</span></span><br><span class="line"><span class="symbol">timezone:</span> Asia/Shanghai <span class="meta">#网站时区。Hexo 默认使用您电脑的时区。</span></span><br></pre></td></tr></table></figure><ul><li>打开<code>Hexo 站点</code>目录下的<code>_config.yml</code>修改内容如下</li></ul><h4 id="4-设置主题风格"><a href="#4-设置主题风格" class="headerlink" title="4.设置主题风格"></a>4.设置主题风格</h4><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>scheme</code>关键字，将你需用启用的<code>scheme</code> 前面注释 # 去除即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Scheme Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Schemes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Muse <span class="comment"># 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Mist <span class="comment"># Muse 的紧凑版本，整洁有序的单栏外观</span></span></span><br><span class="line">scheme: Pisces # 双栏 Scheme，小家碧玉似的清新</span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Gemini <span class="comment"># 类似 Pisces</span></span></span><br></pre></td></tr></table></figure><h4 id="5-设置菜单项的显示文本和图标"><a href="#5-设置菜单项的显示文本和图标" class="headerlink" title="5.设置菜单项的显示文本和图标"></a>5.设置菜单项的显示文本和图标</h4><ul><li>更新说明：NexT.Pisces v5.1.3, 版本更换了修改菜单图标方式。<a href="https://link.jianshu.com?t=https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">参看详细信息</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1157148-aff23889b39e52b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/244/format/webp" alt=""></p><ul><li>NexT 使用的是 <a href="https://link.jianshu.com?t=http://fontawesome.io/icons/" target="_blank" rel="noopener">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</li></ul><h6 id="5-1设置菜单项的显示文本："><a href="#5-1设置菜单项的显示文本：" class="headerlink" title="5.1设置菜单项的显示文本："></a><strong>5.1设置菜单项的显示文本</strong>：</h6><ul><li>打开<code>themes/next/languages</code>下的<code>zh-Hans.yml</code>文件,搜索 <code>menu</code>关键字，修改对应中文或者新增</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> 首页</span><br><span class="line"><span class="symbol">  archives:</span> 归档</span><br><span class="line"><span class="symbol">  categories:</span> 分类</span><br><span class="line"><span class="symbol">  tags:</span> 标签</span><br><span class="line"><span class="symbol">  about:</span> 关于</span><br><span class="line"><span class="symbol">  search:</span> 搜索</span><br><span class="line"><span class="symbol">  schedule:</span> 日程表</span><br><span class="line"><span class="symbol">  sitemap:</span> 站点地图</span><br><span class="line"><span class="symbol">  commonweal:</span> 公益<span class="number">404</span></span><br><span class="line">  <span class="meta"># 新增menu</span></span><br><span class="line"><span class="symbol">  catalogue:</span> 目录</span><br></pre></td></tr></table></figure><h6 id="5-2设定菜单项的图标"><a href="#5-2设定菜单项的图标" class="headerlink" title="5.2设定菜单项的图标"></a><strong>5.2设定菜单项的图标</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>menu_icons</code>关键字，修改对应<code>图标名称</code>或者新增对应<code>menu</code>的图标</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="comment"># Icon Mapping:</span></span><br><span class="line"><span class="comment">#   Map a menu item to a specific FontAwesome icon name.</span></span><br><span class="line"><span class="comment">#   Key is the name of menu item and value is the name of FontAwesome icon. Key is case-senstive.</span></span><br><span class="line"><span class="comment">#   When an question mask icon presenting up means that the item has no mapping icon.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">calendar</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  sitemap:</span> <span class="string">sitemap</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">heartbeat</span></span><br><span class="line">  <span class="comment">#新增menu_icon</span></span><br><span class="line"><span class="attr">  catalogue:</span> <span class="string">th-list</span></span><br></pre></td></tr></table></figure><h6 id="5-3设置菜单项对应的文件目录"><a href="#5-3设置菜单项对应的文件目录" class="headerlink" title="5.3设置菜单项对应的文件目录"></a><strong>5.3设置菜单项对应的文件目录</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>menu</code>关键字，以<code>#</code>注释原有的菜单项，或者新增新的菜单项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Menu Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When running the site <span class="keyword">in</span> a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span></span><br><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories/</span><br><span class="line"><span class="meta">  #</span><span class="bash">about: /about/</span></span><br><span class="line">  archives: /archives/</span><br><span class="line"><span class="meta">  #</span><span class="bash">tags: /tags/</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">新增menu</span></span><br><span class="line">  catalogue: /catalogues/</span><br></pre></td></tr></table></figure><ul><li>除了<code>home</code>，<code>archives</code>,<code>/</code>后面都需要手动创建这个页面</li></ul><h6 id="5-4创建菜单项对应文件目录-以分类为例"><a href="#5-4创建菜单项对应文件目录-以分类为例" class="headerlink" title="5.4创建菜单项对应文件目录,以分类为例"></a><strong>5.4创建菜单项对应文件目录,以<code>分类</code>为例</strong></h6><ul><li>在终端窗口下，定位到 <code>Hexo 站点</code>目录下。使用 <code>hexo new page</code> 新建一个页面，命名为 categories ：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ hexo new<span class="built_in"> page </span>categories</span><br></pre></td></tr></table></figure><h6 id="5-5编辑刚新建的页面-设置分类"><a href="#5-5编辑刚新建的页面-设置分类" class="headerlink" title="5.5编辑刚新建的页面,设置分类"></a><strong>5.5编辑刚新建的页面,设置分类</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="bullet">-12</span><span class="bullet">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Testing</span> <span class="comment">#分类名</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h4 id="6-头像设置"><a href="#6-头像设置" class="headerlink" title="6.头像设置"></a>6.头像设置</h4><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180827165555.png" alt=""></p><h6 id="6-1添加头像"><a href="#6-1添加头像" class="headerlink" title="6.1添加头像"></a><strong>6.1添加头像</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件，搜索 <code>Sidebar Avatar</code>关键字，去掉<code>avatar</code>前面的<code>#</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Sidebar Avatar</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> theme directory(<span class="built_in">source</span>/images): /images/avatar.jpg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> site  directory(<span class="built_in">source</span>/uploads): /uploads/avatar.jpg</span></span><br><span class="line">avatar: http://example.com/avatar.png</span><br></pre></td></tr></table></figure><ul><li>或者使用本地图片,把图片放入<code>themes/next/source/images</code>下,修改<code>avatar</code></li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">avatar:</span> <span class="meta-keyword">/images/</span>blogLogo.png</span><br></pre></td></tr></table></figure><h6 id="6-2设置头像边框为圆形框"><a href="#6-2设置头像边框为圆形框" class="headerlink" title="6.2设置头像边框为圆形框"></a><strong>6.2设置头像边框为圆形框</strong></h6><ul><li>打开位于<code>themes/next/source/css/_common/components/sidebar/</code>下的<code>sidebar-author.syl</code>文件,修改如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"> <span class="comment">// 修改头像边框</span></span><br><span class="line">  border-radius: <span class="number">50</span>%;</span><br><span class="line">  -webkit-border-radius: <span class="number">50</span>%;</span><br><span class="line">  -moz-border-radius: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="6-3特效：鼠标放置头像上旋转"><a href="#6-3特效：鼠标放置头像上旋转" class="headerlink" title="6.3特效：鼠标放置头像上旋转"></a><strong>6.3特效：鼠标放置头像上旋转</strong></h6><p><img src="https://upload-images.jianshu.io/upload_images/1157148-675a29f5238a55cf.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/240/format/webp" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"> <span class="comment">// 修改头像边框</span></span><br><span class="line">  border-radius: <span class="number">50</span>%;</span><br><span class="line">  -webkit-border-radius: <span class="number">50</span>%;</span><br><span class="line">  -moz-border-radius: <span class="number">50</span>%;</span><br><span class="line">  <span class="comment">// 设置旋转</span></span><br><span class="line">  transition: <span class="number">1.4</span>s all;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可旋转的圆形头像,`hover`动作</span></span><br><span class="line">.site-author-image:hover &#123;</span><br><span class="line">    -webkit-transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">    -moz-transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">    -ms-transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">    -transform: rotate(<span class="number">360</span>deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-浏览页面的时候显示当前浏览进度"><a href="#7-浏览页面的时候显示当前浏览进度" class="headerlink" title="7.浏览页面的时候显示当前浏览进度"></a>7.浏览页面的时候显示当前浏览进度</h4><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827170432.png" alt=""></p><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>,搜索关键字<code>scrollpercent</code>,把<code>false</code>改为<code>true</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr"> scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>如果想把<code>top</code>按钮放在<code>侧边栏</code>,打开<code>themes/next</code>下的<code>_config.yml</code>,搜索关键字<code>b2t</code>,把<code>false</code>改为<code>true</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Back to top in sidebar</span></span><br><span class="line"><span class="attr"> b2t:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr"> scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827170416.png" alt=""></p><h4 id="8-文章创建和删除"><a href="#8-文章创建和删除" class="headerlink" title="8.文章创建和删除"></a>8.文章创建和删除</h4><ul><li>创建文章</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">   $</span><span class="bash"> <span class="built_in">cd</span> you-site</span></span><br><span class="line"><span class="meta">   $</span><span class="bash"> hexo new post <span class="string">"you title"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用n代替new</span></span><br></pre></td></tr></table></figure><ul><li><p>文章目录<br><code>you-site/source/_posts</code></p></li><li><p>删除文章</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line">在/source/_posts/中直接删除了相应的.md文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br></pre></td></tr></table></figure><h4 id="9-标签设置"><a href="#9-标签设置" class="headerlink" title="9.标签设置"></a>9.标签设置</h4><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827171116.png" alt=""></p><h6 id="9-1创建标签目录"><a href="#9-1创建标签目录" class="headerlink" title="9.1创建标签目录"></a><strong>9.1创建标签目录</strong></h6><ul><li>hexo初始是没有<code>标签</code>目录的需要自己创建</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd you-site</span><br><span class="line">$ hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure><ul><li>创建完成后,打开<code>you-site/source/tags</code>的<code>index.md</code>,修改如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span>  <span class="comment">#页面主题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-08</span><span class="bullet">-18</span> <span class="number">15</span><span class="string">:00:55</span> <span class="comment">#当前创建文件时间</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span> <span class="comment"># 设置页面类型</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><ul><li>得到如下界面</li></ul><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827171000.png" alt=""></p><h6 id="9-2设置标签云"><a href="#9-2设置标签云" class="headerlink" title="9.2设置标签云"></a><strong>9.2设置标签云</strong></h6><ul><li>标签云的生成:是根据你创建的文章，设定标签类型，自定生成的。某个标签下的 文章越多则，标签越高大</li><li>设置文章标签:打开<code>you-site/source/_posts</code>的<code>you title.md</code>,默认<code>tags:</code>为空,后面加上标签名即可</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">layout</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签1</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-08</span><span class="bullet">-18</span> <span class="number">15</span><span class="string">:41:18</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">标签1</span> <span class="comment">#此文章在`标签1 `标签下</span></span><br><span class="line"><span class="comment">#tags: [标签1,标签2] #此文章在`标签1,标签2`下</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h4 id="10侧边栏设置"><a href="#10侧边栏设置" class="headerlink" title="10侧边栏设置"></a>10侧边栏设置</h4><h6 id="10-1-设置侧边栏社交链接"><a href="#10-1-设置侧边栏社交链接" class="headerlink" title="10.1 设置侧边栏社交链接"></a><strong>10.1 设置侧边栏社交链接</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件,搜索关键字<code>social</code>,然后添加社交站点名称与地址即可。</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Social links</span></span><br><span class="line"><span class="symbol">social:</span></span><br><span class="line"><span class="symbol">  GitHub:</span> https:<span class="comment">//github.com/your-user-name</span></span><br><span class="line"><span class="symbol">  Twitter:</span> https:<span class="comment">//twitter.com/your-user-name</span></span><br><span class="line"><span class="symbol">  Weibo:</span> https:<span class="comment">//weibo.com/your-user-name</span></span><br><span class="line"><span class="symbol">  douban:</span> https:<span class="comment">//douban.com/people/your-user-name</span></span><br><span class="line"><span class="symbol">  zhihu:</span> https:<span class="comment">//www.zhihu.com/people/your-user-name</span></span><br><span class="line">  <span class="meta"># 等等</span></span><br></pre></td></tr></table></figure><h6 id="10-2-设置侧边栏社交图标"><a href="#10-2-设置侧边栏社交图标" class="headerlink" title="10.2 设置侧边栏社交图标"></a><strong>10.2 设置侧边栏社交图标</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件,搜索关键字<code>social_icons</code>，添加社交站点名称（注意大小写）图标，<a href="https://link.jianshu.com?t=http://fontawesome.io/icons/" target="_blank" rel="noopener">Font Awesome图标地址</a></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mappings.</span></span><br><span class="line">  <span class="comment"># KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  Twitter:</span> <span class="string">twitter</span></span><br><span class="line"><span class="attr">  Weibo:</span> <span class="string">weibo</span></span><br><span class="line"><span class="attr">  Linkedin:</span> <span class="string">linkedin</span></span><br></pre></td></tr></table></figure><h6 id="10-3RSS"><a href="#10-3RSS" class="headerlink" title="10.3RSS"></a><strong>10.3RSS</strong></h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827171615.png" alt=""></p><ul><li>在你<code>Hexo 站点</code>目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-feed --save</span></span><br></pre></td></tr></table></figure><ul><li>打开<code>Hexo 站点</code>下的_config.yml,添加如下配置</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># feed</span></span><br><span class="line"><span class="meta"># Dependencies: https:<span class="comment">//github.com/hexojs/hexo-generator-feed</span></span></span><br><span class="line"><span class="symbol">feed:</span></span><br><span class="line"><span class="symbol">  type:</span> atom</span><br><span class="line"><span class="symbol">  path:</span> atom.xml</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">20</span></span><br><span class="line"><span class="symbol">  hub:</span></span><br><span class="line"><span class="symbol">  content:</span></span><br></pre></td></tr></table></figure><h6 id="10-4友情链接"><a href="#10-4友情链接" class="headerlink" title="10.4友情链接"></a><strong>10.4友情链接</strong></h6><ul><li>打开<code>themes/next</code>下的<code>_config.yml</code>文件,搜索关键字<code>Blog rolls</code></li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Blog rolls</span></span><br><span class="line"><span class="symbol">links_title:</span> 友情链接 <span class="meta">#标题</span></span><br><span class="line"><span class="symbol">links_layout:</span> block <span class="meta">#布局，一行一个连接</span></span><br><span class="line"><span class="meta">#links_layout: inline</span></span><br><span class="line"><span class="symbol">links:</span> <span class="meta">#连接</span></span><br><span class="line"><span class="symbol">  baidu:</span> http:<span class="comment">//example.com/</span></span><br><span class="line"><span class="symbol">  google:</span> http:<span class="comment">//example.com/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Hexo版本是3.7.1&lt;/li&gt;
&lt;li&gt;NexT.Pisces v5.1.4&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 生成二维码</title>
    <link href="https://yfzhou.coding.me/2018/08/27/%E4%BD%BF%E7%94%A8-Python-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>https://yfzhou.coding.me/2018/08/27/使用-Python-生成二维码/</id>
    <published>2018-08-27T02:22:03.000Z</published>
    <updated>2018-08-27T06:16:52.875Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;新时代，人们有人信新的追求，自然而然会有新发明的诞生。去年，在“一带一路”国际合作高峰论坛举行期间，20国青年投票选出中国的“新四大发明”：高铁、扫码支付、共享单车和网购。其中扫码支付指手机通过扫描二维码跳转到支付页面，再进行付款。这种新的支付方式，造就二维码满天飞的现象。那么让我们来扒一扒如何使用 Python 来生成二维码图片。</p><a id="more"></a><h3 id="1-二维码"><a href="#1-二维码" class="headerlink" title="1 二维码"></a>1 二维码</h3><p>二维码（2-dimensional bar code），是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的。它能将数字、英文字母、汉字、日文字母、特殊符号(如空格，%，/ 等)、二进制等信息记录到一个正方形的图片中。</p><p>因此，在转换的过程中，离不开编码压缩方式。在许多种类的二维条码中，常用的码制有：Data Matrix, Maxi Code, Aztec, QR Code, Vericode, PDF417, Ultracode, Code 49, Code 16K等。</p><p>二维码在现实生活中的应用越来与普遍，归于功于 QR code 码制的流行。我们常说的二维码就是它。所以，二维码又被称为 QR code。</p><p>QR code 是一种矩阵式二维条码（又称棋盘式二维条码）。它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。在矩阵相应元素位置上，<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制的“0”，点的排列组合确定了矩阵式二维条码所代表的意义</strong>。</p><h3 id="2-二维码结构"><a href="#2-二维码结构" class="headerlink" title="2 二维码结构"></a>2 二维码结构</h3><p>我们的目的是要使用 Python 生成 QR 码，那我们需要先了解二维码(QR 码)的结构。根据标准（ISO/IEC 18004），我们可以了解到 QR 码结构如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM截图20180827141504.png" alt=""></p><p>图片来源网络</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">1) 功能图形</strong><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">功能图形</strong>是不参与编码数据的区域。它包含<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">空白区</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形分隔符</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">定位图形</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">校正图形</strong>五大模块。</p><ul><li>空白区</li></ul><p>空白区顾名思义就是要留空白。因此，这里不能有任何图样或标记。这样才能保证 QR 能被识别。</p><ul><li>位置探测图形</li></ul><p>这个有点类似中文的“回”字。在 QR 码中有个这样的标识，它分别的左上、右上和左下角。作用是协助扫描软件定位 QR 码并转换坐标系。我们在扫描二维码的时候，不管是竖着扫、横着扫、斜着扫都能识别出内容，主要是它的功劳。</p><ul><li>位置探测图形分隔符</li></ul><p>主要作用是区分功能图形和编码区域。</p><ul><li>定位图形</li></ul><p>它由黑白间隔的各自各自组成的线条。主要用于指示标识密度和确定坐标系。原因是 QR 码一种有 40 个版本，也就是说有 40 种尺寸。每种二维码的尺寸越大，扫描的距离就越远。</p><ul><li>校正图形</li></ul><p>只有 Version 2 及以上的QR码有校正标识。校正标识用于进一步校正坐标系。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">2) 编码区域</strong><br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">编码区域是数据进行编码存储的区域。它由<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">格式信息</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">版本信息</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">数据和纠错码字</strong>三部分构成。</p><ul><li>格式信息</li></ul><p>所有尺寸的二维码都有该信息。它存放一些格式化数据的信息，例如容错级别、数据掩码，和额外的自身 BCH 容错码。</p><ul><li>版本信息</li></ul><p>版本信息是规定二维码的规格。前面讲到 QR 码一共有 40 种规格的矩阵（一般为黑白色），从21x21（版本1），到177x177（版本40），每一版本符号比前一版本 每边增加4个模块。</p><ul><li>数据和纠错码</li></ul><p>主要是存储实际数据以及用于纠错码字。</p><h3 id="3-二维码的绘制过程"><a href="#3-二维码的绘制过程" class="headerlink" title="3 二维码的绘制过程"></a>3 二维码的绘制过程</h3><p>二维码已经是有一套国际标准，绘制二维码过程的严格按照标准来执行。这个过程是比较复杂，我自己也是看了大概，然后总结出大致绘制过程。如果你想深入了解绘制细节，可以阅读标准。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);">二维码的绘制大概过程如下：<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">1）在二维码的左上角、左下角、右上角绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形</strong>。位置探测图形一定是一个 7x7 的矩阵。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">2）绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">校正图形</strong>。校正图形一定是一个 5x5 的矩阵。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">3）绘制两条连接三个<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">位置探测图形</strong>的<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">定位图形</strong>。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">4）在上述图片的基础上，继续绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">格式信息</strong>。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">5）接着绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">版本信息</strong>。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">6）填充<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">数据码</strong>和<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">纠错码</strong>到二维码图中。<br style="max-width: 100%;box-sizing: border-box !important;overflow-wrap: break-word !important;">7）最后是绘制<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">蒙版图案</strong>。因为按照上述方式填充内容，可能会出现大面积的空白或黑块的情况，导致扫描识别会十分困难。所以需要对整个图像与蒙版进行蒙版操作(Masking)，蒙版操作即为异或 XOR 操作。在这一步，我们可以将数据排列成各种图片。</p><h3 id="4-二维码的生成"><a href="#4-二维码的生成" class="headerlink" title="4 二维码的生成"></a>4 二维码的生成</h3><p>我们既然已经了解二维码原理，那么可以利用 Python 生成二维码。然而网络上高人比比皆是。已经有大神编写了 Python 生成二维码的第三方库，所以我们不需要重复造轮子, 使用现成的库即可。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);">我就推荐两个库：<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong>&nbsp;和&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">python-qrcode</strong>。</p><ul><li><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong></li></ul><p><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong> 运行在 Python 3 版本上，它可以玩出很多花样。例如能生成以下三种二维码图片：普通二维码、带图片的艺术二维码（黑白与彩色）、动态二维码（黑白与彩色）。它比较适合直接用于生成二维码图片的场景。</p><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);">安装 qrcode 库可以使用 pip 方式。但是该库依赖&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">pillow</strong>、<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">numpy</strong>&nbsp;和&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">imageio</strong>。因此，我们需要先安装依赖库，再安装 qrcode。最后的安装命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐一安装</span></span><br><span class="line">pip <span class="keyword">install</span> pillow</span><br><span class="line">pip <span class="keyword">install</span> numpy</span><br><span class="line">pip <span class="keyword">install</span> imageio</span><br><span class="line">pip <span class="keyword">install</span> myqr</span><br></pre></td></tr></table></figure><p>该库生成带图片的艺术二维码算是一大亮点，具体用法如下:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myqr <span class="string">https:</span><span class="comment">//github.com -p github.jpg -c</span></span><br></pre></td></tr></table></figure><p>上述命令作用是将 github 主页写到彩色二维码中。  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/642.webp" alt=""></p><p>该库还支持生成 gif 的彩色二维码图片，具体用法如下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myqr http<span class="variable">s:</span>//github.<span class="keyword">com</span> -<span class="keyword">p</span> github.gif -<span class="keyword">c</span> -<span class="keyword">con</span> <span class="number">1.5</span> -bri <span class="number">1.6</span></span><br></pre></td></tr></table></figure></p><p>效果图如下：  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/640.gif" alt=""></p><p>最后补上该库的 Github 地址：<a href="https://github.com/sylnsfar/qrcode" target="_blank" rel="noopener">https://github.com/sylnsfar/qrcode</a></p><ul><li><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">python-qrcode</strong></li></ul><p style="margin-top: 1.5em;margin-bottom: 1.5em;max-width: 100%;min-height: 1em;color: rgb(89, 89, 89);"><strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">python-qrcode</strong>&nbsp;相比&nbsp;<strong style="max-width: 100%;color: rgb(255, 107, 123);box-sizing: border-box !important;overflow-wrap: break-word !important;">qrcode</strong>&nbsp;要稍微逊色一点。不过它也有自己的特色。它支持生成矢量图，而且比较适合在代码中生成二维码的场景。</p><p>安装 python-qrcode 同样建议使用 pip 方式，安装命令如下：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> qrcode</span><br></pre></td></tr></table></figure></p><p>在 Python 代码中，最简单的用法是这样。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qrcodeimg = qrcode.make('https://github.com')</span><br></pre></td></tr></table></figure></p><p>它也支持自定义二维码的信息，具体用法如下：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> qrcode</span><br><span class="line"><span class="attr">qr</span> = qrcode.QRCode(</span><br><span class="line">    <span class="attr">version=1,</span></span><br><span class="line">    <span class="attr">error_correction=qrcode.constants.ERROR_CORRECT_L,</span></span><br><span class="line">    <span class="attr">box_size=10,</span></span><br><span class="line">    <span class="attr">border=4,</span></span><br><span class="line">)</span><br><span class="line">qr.add_data('https://github.com')</span><br><span class="line">qr.make(<span class="attr">fit=True)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">img</span> = qr.make_image(<span class="attr">fill_color="black",</span> <span class="attr">back_color="white")</span></span><br></pre></td></tr></table></figure></p><p>如果你想深入了解该库，可以到 Github 仓库阅读相关的文档。<br>Github 地址是：<a href="https://github.com/lincolnloop/python-qrcode" target="_blank" rel="noopener">https://github.com/lincolnloop/python-qrcode</a></p><p><br></p><p><center><br>此文摘自微信公众号【Python中文社区】<br>微信扫一扫<br>关注该公众号<br></center><br><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000005&amp;size=102&amp;__biz=MzAxMjUyNDQ5OA==&amp;mid=2653557161&amp;idx=1&amp;sn=e6b0e7656e7e700e41a33a7142cf38b6&amp;send_time=" alt="Python中文社区"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;新时代，人们有人信新的追求，自然而然会有新发明的诞生。去年，在“一带一路”国际合作高峰论坛举行期间，20国青年投票选出中国的“新四大发明”：高铁、扫码支付、共享单车和网购。其中扫码支付指手机通过扫描二维码跳转到支付页面，再进行付款。这种新的支付方式，造就二维码满天飞的现象。那么让我们来扒一扒如何使用 Python 来生成二维码图片。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://yfzhou.coding.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://yfzhou.coding.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>都是套路：高并发系统的降级特技</title>
    <link href="https://yfzhou.coding.me/2018/08/26/%E9%83%BD%E6%98%AF%E5%A5%97%E8%B7%AF%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%99%8D%E7%BA%A7%E7%89%B9%E6%8A%80/"/>
    <id>https://yfzhou.coding.me/2018/08/26/都是套路：高并发系统的降级特技/</id>
    <published>2018-08-26T13:03:11.000Z</published>
    <updated>2018-08-26T13:12:33.923Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在开发高并发<a href="http://www.yunweipai.com/archives/8269.html" target="_blank" rel="noopener">系统</a>时有三把利器用来保护系统：缓存、降级和限流。之前已经有一些文章介绍过缓存和限流了。本文将详细聊聊降级。</p><a id="more"></a><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。</p><p>系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。本文将介绍一些笔者在实际工作中遇到的或见到过的一些降级方案供大家参考。</p><p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><h2 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h2><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p><strong>一般：</strong>比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p><strong>警告：</strong>有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p><strong>错误：</strong>比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p><strong>严重错误：</strong>比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><h4 id="降级的类别"><a href="#降级的类别" class="headerlink" title="降级的类别"></a>降级的类别</h4><ul><li>降级按照是否自动化可分为：自动开关降级和人工开关降级。</li><li>降级按照功能可分为：读服务降级、写服务降级。</li><li>降级按照处于的系统层次可分为：多级降级。</li></ul><h3 id="降级的功能点"><a href="#降级的功能点" class="headerlink" title="降级的功能点"></a>降级的功能点</h3><p>降级的功能点主要从服务端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级：</p><p><strong>页面降级：</strong>在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；</p><p><strong>页面片段降级：</strong>比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；</p><p><strong>页面异步请求降级：</strong>比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；</p><p><strong>服务功能降级：</strong>比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；</p><p><strong>读降级：</strong>比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；</p><p><strong>写降级：</strong>比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</p><p><strong>爬虫降级：</strong>在大促活动时，可以将爬虫流量导向静态页或者返回空数据从而降级保护后端稀缺资源。</p><h2 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h2><h3 id="1、自动开关降级"><a href="#1、自动开关降级" class="headerlink" title="1、自动开关降级"></a>1、自动开关降级</h3><p>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。</p><h4 id="超时降级"><a href="#超时降级" class="headerlink" title="超时降级"></a>超时降级</h4><p>当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；</p><blockquote><p>比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；</p></blockquote><p>对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。</p><p>之前总结过一些的文章《使用httpclient必须知道的参数设置及代码写法、存在的风险》和《dbcp配置及jdbc超时设置总结》。在实际场景用一定主要配置好超时时间和超时重试次数和机制。</p><h4 id="统计失败次数降级"><a href="#统计失败次数降级" class="headerlink" title="统计失败次数降级"></a>统计失败次数降级</h4><p>有时候依赖一些不稳定的API，比如调用外部机票服务，当失败调用次数达到一定阀值自动降级；然后通过异步线程去探测服务是否恢复了，则取消降级。</p><h4 id="故障降级"><a href="#故障降级" class="headerlink" title="故障降级"></a>故障降级</h4><p>比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。</p><p><strong>降级后的处理方案有：</strong></p><blockquote><p>默认值（比如库存服务挂了，返回默认现货）</p><p>兜底数据（比如广告挂了，返回提前准备好的一些静态页面）</p><p>缓存（之前暂存的一些缓存数据）</p></blockquote><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><p>当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；</p><p><strong>降级后的处理方案可以是：</strong></p><blockquote><p>排队页面（将用户导流到排队页面等一会重试）</p><p>无货（直接告知用户没货了）</p><p>错误页（如活动太火爆了，稍后重试）</p></blockquote><h3 id="2、人工开关降级"><a href="#2、人工开关降级" class="headerlink" title="2、人工开关降级"></a>2、人工开关降级</h3><blockquote><ul><li>在大促期间通过监控发现线上的一些服务存在问题，这个时候需要暂时将这些服务摘掉；</li><li>还有有时候通过任务系统调用一些服务，但是服务依赖的数据库可能存在：网卡被打满了、挂掉了或者很多慢查询，此时需要暂停下任务系统让服务方进行处理；</li><li>还有发现突然调用量太大，可能需要改变处理方式（比如同步转换为异步）；</li></ul></blockquote><p>此时就可以<strong>使用开关来完成降级</strong>。</p><p>开关可以存放到配置文件、存放到数据库、存放到Redis/ZooKeeper；如果不是存放在本地，可以定期同步开关数据（比如1秒同步一次）。然后通过判断某个KEY的值来决定是否降级。</p><p>另外对于新开发的服务想上线进行灰度测试；但是不太确定该服务的逻辑是否正确，此时就需要设置开关，当新服务有问题可以通过开关切换回老服务。</p><p>还有多机房服务，如果某个机房挂掉了，此时需要将一个机房的服务切到另一个机房，此时也可以通过开关完成切换。</p><p>还有一些是因为功能问题需要暂时屏蔽掉某些功能，比如商品规格参数数据有问题，数据问题不能用回滚解决，此时需要开关控制降级。</p><h3 id="3、读服务降级"><a href="#3、读服务降级" class="headerlink" title="3、读服务降级"></a>3、读服务降级</h3><p><strong>对于读服务降级一般采用的策略有：</strong></p><blockquote><p>暂时切换读（降级到读缓存、降级到走静态化）</p><p>暂时屏蔽读（屏蔽读入口、屏蔽某个读服务）</p></blockquote><p>在《应用多级缓存模式支撑海量读服务》中曾经介绍过<strong>读服务</strong>，即：</p><blockquote><p>接入层缓存→应用层本地缓存→分布式缓存→RPC服务/DB</p></blockquote><p>我们会在接入层、应用层设置开关，当分布式缓存、RPC服务/DB有问题自动降级为不调用。当然这种情况适用于对读一致性要求不高的场景。</p><p>页面降级、页面片段降级、页面异步请求降级都是读服务降级，目的是丢卒保帅（比如因为这些服务也要使用核心资源、或者占了带宽影响到核心服务）或者因数据问题暂时屏蔽。</p><p>还有一种是页面静态化场景：</p><p><strong>动态化降级为静态化：</strong>比如平时网站可以走动态化渲染商品详情页，但是到了大促来临之际可以将其切换为静态化来减少对核心资源的占用，而且可以提升性能；其他还有如列表页、首页、频道页都可以这么玩；可以通过一个程序定期的推送静态页到缓存或者生成到磁盘，出问题时直接切过去；</p><p><strong>静态化降级为动态化：</strong>比如当使用静态化来实现商品详情页架构时，平时使用静态化来提供服务，但是因为特殊原因静态化页面有问题了，需要暂时切换回动态化来保证服务正确性。</p><p>以上都保证出问题了有预案，用户还是可以使用网站，不影响用户购物。</p><h3 id="4、写服务降级"><a href="#4、写服务降级" class="headerlink" title="4、写服务降级"></a>4、写服务降级</h3><p>写服务在大多数场景下是不可降级的，不过可以通过一些迂回战术来解决问题。比如将同步操作转换为异步操作，或者限制写的量/比例。</p><p>比如扣减库存一般这样操作：</p><h4 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h4><p>a、扣减DB库存；</p><p>b、扣减成功后更新Redis中的库存；</p><h4 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a><strong>方案2：</strong></h4><p>a、扣减Redis库存；</p><p>b、同步扣减DB库存，如果扣减失败则回滚Redis库存；</p><p>前两种方案非常依赖DB，假设此时DB性能跟不上则扣减库存就会遇到问题；因此我们可以想到<strong>方案3：</strong></p><p>a、扣减Redis库存：</p><p>b、正常同步扣减DB库存，性能扛不住时降级为发送一条扣减DB库存的消息，然后异步进行DB库存扣减实现最终一致即可；</p><p>这种方式发送扣减DB库存消息也可能成为瓶颈；这种情况我们可以考虑<strong>方案4：</strong></p><p>a、扣减Redis库存；</p><p>b、正常同步扣减DB库存，性能扛不住时降级为写扣减DB库存消息到本机，然后本机通过异步进行DB库存扣减来实现最终一致性。</p><p>也就是说正常情况可以同步扣减库存，在性能扛不住时降级为异步；另外如果是秒杀场景可以直接降级为异步，从而保护系统。</p><p>还有如下单操作可以在大促时暂时降级将下单数据写入Redis，然后等峰值过去了再同步回DB，当然也有更好的解决方案，但是更复杂，不是本文的重点。</p><p>还有如用户评价，如果评价量太大，也可以把评价从同步写降级为异步写。当然也可以对评价按钮进行按比例开放（比如一些人的看不到评价操作按钮）。比如评价成功后会发一些奖励，在必要的时候降级同步到异步。</p><h3 id="5、多级降级"><a href="#5、多级降级" class="headerlink" title="5、多级降级"></a>5、多级降级</h3><p>缓存是离用户最近越高效；而降级是离用户越近越能对系统保护的好。因为业务的复杂性导致越到后端QPS/TPS越低。</p><p><strong>页面JS降级开关：</strong>主要控制页面功能的降级，在页面中通过JS脚本部署功能降级开关，在适当时机开启/关闭开关；</p><p><strong>接入层降级开关</strong>：主要控制请求入口的降级，请求进入后会首先进入接入层，在接入层可以配置功能降级开关，可以根据实际情况进行自动/人工降级；</p><p>这个可以参考《京东商品详情页服务闭环实践》，尤其在后端应用服务出问题时，通过接入层降级从而给应用服务有足够的时间恢复服务；</p><p><strong>应用层降级开关：</strong>主要控制业务的降级，在应用中配置相应的功能开关，根据实际业务情况进行自动/人工降级。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>降级能保障系统在大促中活下来，而不是死去，达到丢卒保帅的作用。对用户提供有损服务，总比不服务要好。根据自己的场景设计相应的降级策略，保障系统在危机时刻能通过降级手段平稳度过。</p><p><a href="https://blog.csdn.net/enweitech" target="_blank" rel="noopener">EnweiTech</a>原创作品。转载请注明出处<a href="https://blog.csdn.net/enweitech" target="_blank" rel="noopener">https://blog.csdn.net/enweitech</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在开发高并发&lt;a href=&quot;http://www.yunweipai.com/archives/8269.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统&lt;/a&gt;时有三把利器用来保护系统：缓存、降级和限流。之前已经有一些文章介绍过缓存和限流了。本文将详细聊聊降级。&lt;/p&gt;
    
    </summary>
    
      <category term="高并发" scheme="https://yfzhou.coding.me/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="高并发" scheme="https://yfzhou.coding.me/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</title>
    <link href="https://yfzhou.coding.me/2018/08/26/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <id>https://yfzhou.coding.me/2018/08/26/缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题/</id>
    <published>2018-08-26T10:48:23.000Z</published>
    <updated>2018-08-26T12:21:36.649Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;前面一节说到了《<a href="http://yfzhou.coding.me/2018/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8ARedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%81/#more">为什么说Redis是单线程的以及Redis为什么这么快！</a>》，今天给大家整理一篇关于Redis经常被问到的问题：缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等概念的入门及简单解决方案。</p><a id="more"></a><h2 id="一、缓存雪崩"><a href="#一、缓存雪崩" class="headerlink" title="一、缓存雪崩"></a>一、缓存雪崩</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存雪崩我们可以简单的理解为：<strong>由于原有缓存失效，新缓存未到期间</strong>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p><p>缓存正常从Redis中获取，示意图如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180312200437182.png" alt="这里写图片描述"></p><p>缓存失效瞬间示意图如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180312200640916.png" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存失效时的雪崩效应对底层系统的冲击非常可怕！大多数系统设计者考虑用<strong>加锁</strong>或者<strong>队列</strong>的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p>以下简单介绍两种实现方式的伪代码：</p><p>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是<strong>加锁排队</strong>，伪代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">public</span> object GetProductListNew() &#123;</span><br><span class="line">    <span class="built_in">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">String</span> cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    <span class="keyword">String</span> lockKey = cacheKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">String</span> cacheValue = CacheHelper.<span class="built_in">get</span>(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockKey) &#123;</span><br><span class="line">            cacheValue = CacheHelper.<span class="built_in">get</span>(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cacheValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里一般是sql查询数据</span></span><br><span class="line">                cacheValue = GetProductListFromDB(); </span><br><span class="line">                CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p><p>（2）还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">public</span> object GetProductListNew() &#123;</span><br><span class="line">    <span class="built_in">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">String</span> cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    <span class="comment">//缓存标记</span></span><br><span class="line">    <span class="keyword">String</span> cacheSign = cacheKey + <span class="string">"_sign"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">String</span> sign = CacheHelper.Get(cacheSign);</span><br><span class="line">    <span class="comment">//获取缓存值</span></span><br><span class="line">    <span class="keyword">String</span> cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (sign != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue; <span class="comment">//未过期，直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHelper.Add(cacheSign, <span class="string">"1"</span>, cacheTime);</span><br><span class="line">        ThreadPool.QueueUserWorkItem((arg) -&gt; &#123;</span><br><span class="line">            <span class="comment">//这里一般是 sql查询数据</span></span><br><span class="line">            cacheValue = GetProductListFromDB(); </span><br><span class="line">            <span class="comment">//日期设缓存时间的2倍，用于脏读</span></span><br><span class="line">            CacheHelper.Add(cacheKey, cacheValue, cacheTime * <span class="number">2</span>);                 </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><p>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p><p>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">GetProductListNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    String cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line"></span><br><span class="line">    String cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//数据库查询不到，为空</span></span><br><span class="line">        cacheValue = GetProductListFromDB();</span><br><span class="line">        <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果发现为空，设置个默认值，也缓存起来</span></span><br><span class="line">            cacheValue = <span class="keyword">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p><h2 id="三、缓存预热"><a href="#三、缓存预热" class="headerlink" title="三、缓存预热"></a>三、缓存预热</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p>解决思路：</p><p>1、直接写个缓存刷新页面，上线时手工操作下；</p><p>2、数据量不大，可以在项目启动的时候自动进行加载；</p><p>3、定时刷新缓存；</p><h2 id="四、缓存更新"><a href="#四、缓存更新" class="headerlink" title="四、缓存更新"></a>四、缓存更新</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>（1）定时去清理过期的缓存；</p><p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h2 id="五、缓存降级"><a href="#五、缓存降级" class="headerlink" title="五、缓存降级"></a>五、缓存降级</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这些都是实际项目中，可能碰到的一些问题，也是面试的时候经常会被问到的知识点，实际上还有很多很多各种各样的问题，文中的解决方案，也不可能满足所有的场景，相对来说只是对该问题的入门解决方法。一般正式的业务场景往往要复杂的多，应用场景不同，方法和解决方案也不同，由于上述方案，考虑的问题并不是很全面，因此并不适用于正式的项目开发，但是可以作为概念理解入门，具体解决方案要根据实际情况来确定！</p><hr><p>参考文章：</p><p>1、<a href="http://www.cnblogs.com/zhangweizhong/p/6258797.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangweizhong/p/6258797.html</a><br>2、<a href="http://www.cnblogs.com/zhangweizhong/p/5884761.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangweizhong/p/5884761.html</a><br>3、<a href="http://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">http://blog.csdn.net/zeb_perfect/article/details/54135506</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前面一节说到了《&lt;a href=&quot;http://yfzhou.coding.me/2018/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8ARedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%81/#more&quot;&gt;为什么说Redis是单线程的以及Redis为什么这么快！&lt;/a&gt;》，今天给大家整理一篇关于Redis经常被问到的问题：缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等概念的入门及简单解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="https://yfzhou.coding.me/categories/redis/"/>
    
    
      <category term="redis" scheme="https://yfzhou.coding.me/tags/redis/"/>
    
      <category term="缓存" scheme="https://yfzhou.coding.me/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="集群分布式" scheme="https://yfzhou.coding.me/tags/%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>为什么说Redis是单线程的以及Redis为什么这么快！</title>
    <link href="https://yfzhou.coding.me/2018/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A5%E5%8F%8ARedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%81/"/>
    <id>https://yfzhou.coding.me/2018/08/26/为什么说Redis是单线程的以及Redis为什么这么快！/</id>
    <published>2018-08-26T10:48:09.000Z</published>
    <updated>2018-08-26T12:07:02.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;近乎所有与Java相关的面试都会问到缓存的问题，基础一点的会问到什么是“二八定律”、什么是“热数据和冷数据”，复杂一点的会问到缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题，这些看似不常见的概念，都与我们的缓存服务器相关，一般常用的缓存服务器有Redis、Memcached等，而笔者目前最常用的也只有Redis这一种。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你在以前面试的时候还没有遇到过面试官问你《为什么说Redis是单线程的以及Redis为什么这么快！》，那么你看到这篇文章的时候，你应该觉得是一件很幸运的事情！如果你刚好是一位高逼格的面试官，你也可以拿这道题去面试对面“望穿秋水”般的小伙伴，测试一下他的掌握程度。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;好啦！步入正题！我们先探讨一下Redis是什么，Redis为什么这么快、然后在探讨一下为什么Redis是单线程的？</p><h2 id="二、Redis简介"><a href="#二、Redis简介" class="headerlink" title="二、Redis简介"></a>二、Redis简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis是一个开源的内存中的数据结构存储系统，它可以用作：<strong>数据库、缓存和消息中间件</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。<strong>其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p><p>（1）硬盘数据库的工作模式：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20170307142145648.png" alt="这里写图片描述"><br>（2）内存数据库的工作模式：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20170307142210929.png" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;看完上述的描述，对于一些常见的Redis相关的面试题，是否有所认识了，例如：什么是Redis、Redis常见的数据结构类型有哪些、Redis是如何进行持久化的等。</p><h2 id="三、Redis到底有多快"><a href="#三、Redis到底有多快" class="headerlink" title="三、Redis到底有多快"></a>三、Redis到底有多快</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis采用的是基于内存的采用的是<strong>单进程单线程</strong>模型的 <strong>KV 数据库</strong>，<strong>由C语言编写</strong>，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差！有兴趣的可以参考官方的基准程序测试《<a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">How fast is Redis？</a>》（<a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">https://redis.io/topics/benchmarks</a>）</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/2018030715491722.png" alt="这里写图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>横轴是连接数，纵轴是QPS</strong>。此时，这张图反映了一个数量级，希望大家在面试的时候可以正确的描述出来，不要问你的时候，你回答的数量级相差甚远！</p><h2 id="四、Redis为什么这么快"><a href="#四、Redis为什么这么快" class="headerlink" title="四、Redis为什么这么快"></a>四、Redis为什么这么快</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p><p>（1）多路 I/O 复用模型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h2 id="五、那么为什么Redis是单线程的"><a href="#五、那么为什么Redis是单线程的" class="headerlink" title="五、那么为什么Redis是单线程的"></a>五、那么为什么Redis是单线程的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180307162652293.png" alt="这里写图片描述"><br>可以参考：<a href="https://redis.io/topics/faq" target="_blank" rel="noopener">https://redis.io/topics/faq</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;看到这里，你可能会气哭！本以为会有什么重大的技术要点才使得Redis使用单线程就可以这么快，没想到就是一句官方看似糊弄我们的回答！但是，我们已经可以很清楚的解释了为什么Redis这么快，并且正是由于在单线程模式的情况下已经很快了，就没有必要在使用多线程了！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p><p><strong>警告1</strong>：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180307172053108.png" alt="这里写图片描述"></p><p>ps命令的“-T”参数表示显示线程（Show threads, possibly with SPID column.）“SID”栏表示线程ID，而“CMD”栏则显示了线程名称。</p><p><strong>警告2</strong>：在上图中FAQ中的最后一段，表述了从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！所以该篇文章在以后的版本中是否还是单线程的方式需要读者考证！</p><h2 id="六、注意点"><a href="#六、注意点" class="headerlink" title="六、注意点"></a>六、注意点</h2><p>1、我们知道Redis是用”单线程-多路复用IO模型”来实现高性能的内存数据服务的，这种机制避免了使用锁，但是同时这种机制在进行sunion之类的比较耗时的命令时会使redis的并发下降。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个CPU核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成master-master或者master-slave的形式，耗时的读命令可以完全在slave进行。</p><p>需要改的redis.conf项：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis/redis_6377.pid  #pidfile要加上端口号</span><br><span class="line">port 6377  #这个是必须改的</span><br><span class="line">logfile /var/log/redis/redis_6377.log #logfile的名称也加上端口号</span><br><span class="line">dbfilename dump_6377.rdb  #rdbfile也加上端口号</span><br></pre></td></tr></table></figure></p><p>2、“我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以，我们可以手动地为其分配CPU核，而不会过多地占用CPU，或是让我们关键进程和一堆别的进程挤在一起。”。<br>CPU 是一个重要的影响因素，由于是单线程模型，Redis 更喜欢大缓存快速 CPU， 而不是多核</p><p>在多核 CPU 服务器上面，Redis 的性能还依赖NUMA 配置和处理器绑定位置。最明显的影响是 redis-benchmark 会随机使用CPU内核。为了获得精准的结果，需要使用固定处理器工具（在 Linux 上可以使用 taskset）。最有效的办法是将客户端和服务端分离到两个不同的 CPU 来高校使用三级缓存。</p><h2 id="七、扩展"><a href="#七、扩展" class="headerlink" title="七、扩展"></a>七、扩展</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;以下也是你应该知道的几种模型，祝你的面试一臂之力！</p><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20180307172918264.png" alt="这里写图片描述"></p><hr><p>参考文章：</p><p>1、<a href="http://www.syyong.com/db/Redis-why-the-use-of-single-process-and-single-threaded-way-so-fast.html" target="_blank" rel="noopener">http://www.syyong.com/db/Redis-why-the-use-of-single-process-and-single-threaded-way-so-fast.html</a><br>2、<a href="http://blog.csdn.net/xxb2008/article/details/42238557" target="_blank" rel="noopener">http://blog.csdn.net/xxb2008/article/details/42238557</a><br>3、<a href="http://blog.csdn.net/hobbs136/article/details/7619719" target="_blank" rel="noopener">http://blog.csdn.net/hobbs136/article/details/7619719</a><br>4、<a href="http://blog.csdn.net/yushitao/article/details/43565851" target="_blank" rel="noopener">http://blog.csdn.net/yushitao/article/details/43565851</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;近乎所有与Java相关的面试都会问到缓存的问题，基础一点的会问到什么是“二八定律”、什么是“热数据和冷数据”，复杂一点的会问到缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题，这些看似不常见的概念，都与我们的缓存服务器相关，一般常用的缓存服务器有Redis、Memcached等，而笔者目前最常用的也只有Redis这一种。&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="https://yfzhou.coding.me/categories/redis/"/>
    
    
      <category term="redis" scheme="https://yfzhou.coding.me/tags/redis/"/>
    
      <category term="线程" scheme="https://yfzhou.coding.me/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器深入探索</title>
    <link href="https://yfzhou.coding.me/2018/08/24/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/"/>
    <id>https://yfzhou.coding.me/2018/08/24/Java类加载器深入探索/</id>
    <published>2018-08-24T07:49:10.000Z</published>
    <updated>2018-08-24T08:48:15.491Z</updated>
    
    <content type="html"><![CDATA[<p><span><br><a id="more"></a></span></p><h1 id="什么是-class文件？"><a href="#什么是-class文件？" class="headerlink" title="什么是.class文件？"></a>什么是.class文件？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;class文件全名称为Java class文件，主要在平台无关性和网络移动性方面使Java更适合网络。它在平台无关性方面的任务是：为Java程序提供独立于底层主机平台的二进制形式的服务。class文件径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。而这也是Java宣称的“一次编译，到处运行”的真正原因，因为各个系统上的Java文件都是被编译成.class文件，然后通过虚拟机来加载运行的。</p><h1 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;类加载器是一个用来加载类文件的类。Java源代码通过javac编译器编译成类文件。然后JVM来执行类文件中的字节码来执行程序。类加载器负责加载文件系统、网络或其他来源的类文件。有三种默认使用的类加载器：Bootstrap类加载器、Extension类加载器和System类加载器（或者叫作Application类加载器）。每种类加载器都有设定好从哪里加载类。</p><h1 id="生成一个对象实例发生了什么事？"><a href="#生成一个对象实例发生了什么事？" class="headerlink" title="生成一个对象实例发生了什么事？"></a>生成一个对象实例发生了什么事？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;生成一个实例，程序主要会把对应的类的java文件使用编译器生成字节码文件，然后等此类被调用静态变量或方法或生成实例时，虚拟机自动去相应目录查找字节码文件，并加载到虚拟机当中，然后生成对应的实例对象。每一个字节码文件只会被加载一次。其过程如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920142201727" alt="">  </p><h1 id="类加载的方式"><a href="#类加载的方式" class="headerlink" title="类加载的方式"></a>类加载的方式</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Java提供两种方法来达成动态行，一种是隐式的，另一种是显式的。这两种方式底层用到的机制完全相同，差异只有程序代码不同。隐式的就是当用到new这个Java关键字时，会让类加载器依需求载入所需的类。显式的又分为两种方法：一种是借用java.lang.Class里的forName()方法，另一种则是借用java.lang.ClassLoader里的loadClass()方法。  </p><h1 id="类加载器的树状组织结构及加载文件目录"><a href="#类加载器的树状组织结构及加载文件目录" class="headerlink" title="类加载器的树状组织结构及加载文件目录"></a>类加载器的树状组织结构及加载文件目录</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><p>(1) Bootstrap ClassLoader（引导类加载器） : 它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。将存放于&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用  </p><p>(2) Extension ClassLoader（扩展类加载器） : 它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。将&lt;JAVA_HOME&gt;\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。  </p><p>(3) Application ClassLoader或叫System Classloader （系统类加载器）: 负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p><p>以下有两种方式来取得类加载器的组织结构：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassLoadTest1</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line"> ClassLoader loader = ClassLoadTest1.class.getClassLoader(); </span><br><span class="line"> ClassLoader loader1 = ClassLoader.getSystemClassLoader();</span><br><span class="line"> <span class="comment">//从子到父取得加载器</span></span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="literal">null</span>) &#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(loader.toString()); </span><br><span class="line">            loader = loader.getParent(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (loader1 != <span class="literal">null</span>) &#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(loader1.toString()); </span><br><span class="line">            loader1 = loader1.getParent(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920145542249" alt="">  </p><p>可以看到，两种方法都是先取得 Application ClassLoader，然后再取得Extension ClassLoader。</p><p>表 1. ClassLoader 中与加载类相关的方法</p><table border="1"><tr><td>方法</td><td>说明</td></tr><tr></tr><tr><td>getParent()</td><td>返回该类加载器的父类加载器。</td></tr><tr></tr><tr><td>loadClass(String name)</td><td>加载名称为 name的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr></tr><tr><td>findClass(String name)</td><td>查找名称为 name的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例</td></tr><tr></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。</td></tr><tr></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>链接指定的 Java 类。</td></tr><tr></tr></table><p>&nbsp;&nbsp;&nbsp;&nbsp;除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 表 1中给出的 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。下图 中给出了一个典型的类加载器树状组织结构示意图，其中的箭头指向的是父类加载器。  </p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920143136831" alt="">  </p><p>每次加载的具体的过程：</p><h1 id="类加载器工作过程"><a href="#类加载器工作过程" class="headerlink" title="类加载器工作过程"></a>类加载器工作过程</h1><p>类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：<br>(1) 装载：查找和导入Class文件；<br>(2) 链接：把类的二进制数据合并到JRE中；<br>&nbsp;&nbsp;&nbsp;&nbsp;(a)校验：检查载入Class文件数据的正确性；<br>&nbsp;&nbsp;&nbsp;&nbsp;(b)准备：给类的静态变量分配存储空间；<br>&nbsp;&nbsp;&nbsp;&nbsp;(c)解析：将符号引用转成直接引用；</p><p>(3) 初始化：对类的静态变量，静态代码块执行初始化操作</p><h1 id="类加载器的工作原理"><a href="#类加载器的工作原理" class="headerlink" title="类加载器的工作原理"></a>类加载器的工作原理</h1><p>(1)委托机制<br>&nbsp;&nbsp;&nbsp;&nbsp;当一个类加载和初始化的时候，类仅在有需要加载的时候被加载。假设你有一个应用需要的类叫作Abc.class，首先加载这个类的请求由Application类加载器委托给它的父类加载器Extension类加载器，然后再委托给Bootstrap类加载器。Bootstrap类加载器会先看看rt.jar中有没有这个类，因为并没有这个类，所以这个请求由回到Extension类加载器，它会查看jre/lib/ext目录下有没有这个类，如果这个类被Extension类加载器找到了，那么它将被加载，而Application类加载器不会加载这个类；而如果这个类没有被Extension类加载器找到，那么再由Application类加载器从classpath中寻找。记住classpath定义的是类文件的加载目录，而PATH是定义的是可执行程序如javac，java等的执行路径。  </p><p>工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920154823695" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。下面通过示例来具体说明。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"> </span><br><span class="line">public class Sample &#123;</span><br><span class="line">private Sample<span class="built_in"> instance; </span></span><br><span class="line">    public void setSample(Object instance) &#123; </span><br><span class="line">        this.instance = (Sample)<span class="built_in"> instance; </span></span><br><span class="line">    &#125; </span><br><span class="line">    public void say()&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello LinBingwen"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是使用：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class ClassLoadTest4&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException, IllegalAccessException, NoSuchMethodException, InstantiationException, InvocationTargetException&#123;</span><br><span class="line">    ClassLoader pClassLoader = ClassLoader.getSystemClassLoader(); <span class="comment">// 以System ClassLoader作为父类加载器</span></span><br><span class="line">    URL[] baseUrls = &#123;<span class="keyword">new</span> URL(<span class="string">"file:/E:/workspace/Eclipse/ClassLoadTest"</span>)&#125;; <span class="comment">// 搜索类库的目录</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> binaryName = <span class="string">"com.lin.Sample"</span>; <span class="comment">// 需要加载的类的二进制名称</span></span><br><span class="line"> </span><br><span class="line">    ClassLoader userClassLoader1 = <span class="keyword">new</span> URLClassLoader(baseUrls, pClassLoader);</span><br><span class="line">    ClassLoader userClassLoader2 = <span class="keyword">new</span> URLClassLoader(baseUrls, pClassLoader);</span><br><span class="line">    Class clazz1 = userClassLoader1.loadClass(binaryName);</span><br><span class="line">    Class clazz2 = userClassLoader2.loadClass(binaryName);</span><br><span class="line">    <span class="keyword">Object</span> instance1 = clazz1.newInstance();</span><br><span class="line">    <span class="keyword">Object</span> instance2 = clazz2.newInstance();</span><br><span class="line">    <span class="comment">// 调用say方法</span></span><br><span class="line">    clazz1.getMethod(<span class="string">"say"</span>).invoke(instance1);</span><br><span class="line">    clazz2.getMethod(<span class="string">"say"</span>).invoke(instance2);</span><br><span class="line">    <span class="comment">// 输出类的二进制名称</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz1.toString());</span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz2.toString());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 比较两个类的地址是否相同</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz1 == clazz2);</span><br><span class="line">    <span class="comment">// 比较两个类是否相同或是否为继承关系</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(clazz1.isAssignableFrom(clazz2));</span><br><span class="line">    <span class="comment">// 查看类型转换是否成功</span></span><br><span class="line">    <span class="built_in">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       Method setSampleMethod = clazz1.getMethod(<span class="string">"setSample"</span>, java.lang.<span class="keyword">Object</span>.class); </span><br><span class="line">       setSampleMethod.invoke(instance1, instance2); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.<span class="built_in">println</span>(ret);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920161618517" alt=""></p><p>因为都是从 ClassLoader.getSystemClassLoader(); // 以System ClassLoader作为父类加载器，所以两个加载器其实是一样的。</p><p>(2)可见性机制<br>根据可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。所以下面的例子中，当Abc.class已经被Application类加载器加载过了，然后如果想要使用Extension类加载器加载这个类，将会抛出java.lang.ClassNotFoundException异常。  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassLoadTest2 &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;          </span><br><span class="line">            <span class="comment">//打印当前的类加载器</span></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"ClassLoadTest2.getClass().getClassLoader() : "</span></span><br><span class="line">                                 + ClassLoadTest2.<span class="keyword">class</span>.getClassLoader());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//使用扩展类加载器再次加载子类加载器加载过的</span></span><br><span class="line">            <span class="keyword">Class</span>.forName(<span class="string">" com.lin.ClassLoadTest1"</span>, <span class="keyword">true</span></span><br><span class="line">                            ,  ClassLoadTest2.<span class="keyword">class</span>.getClassLoader().getParent());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            Logger.getLogger(ClassLoadTest2.<span class="keyword">class</span>.getName()).log(Level.SEVERE, <span class="keyword">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150920152839964" alt=""></p><p>(3)单一性机制<br>根据这个机制，父加载器加载过的类不能被子加载器加载第二次。虽然重写违反委托和单一性机制的类加载器是可能的，但这样做并不可取。你写自己的类加载器的时候应该严格遵守这三条机制。  </p><p>参考文章：</p><p>1、<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a></p><p>2、<a href="http://www.cnblogs.com/ITtangtang/p/3978102.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3978102.html</a></p><p>3、<a href="http://www.cnblogs.com/rason2008/archive/2012/01/01/2309718.html" target="_blank" rel="noopener">http://www.cnblogs.com/rason2008/archive/2012/01/01/2309718.html</a></p><p>4、<a href="http://www.importnew.com/6581.html" target="_blank" rel="noopener">http://www.importnew.com/6581.html</a></p><p><br><br><a href="http://my.csdn.net/?ref=toolbar" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="反射" scheme="https://yfzhou.coding.me/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="类加载器" scheme="https://yfzhou.coding.me/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java反射探索研究</title>
    <link href="https://yfzhou.coding.me/2018/08/24/Java%E5%8F%8D%E5%B0%84%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6/"/>
    <id>https://yfzhou.coding.me/2018/08/24/Java反射探索研究/</id>
    <published>2018-08-24T07:48:59.000Z</published>
    <updated>2018-08-24T09:16:25.831Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;摘要：本文详细深入讲解是Java中反射的机制，并介绍了如何通过反射来生成对象、调用函数、取得字段、设置字段的方法。最后，给出了一些反射常用到的实例。</p><a id="more"></a><h1 id="一、反射"><a href="#一、反射" class="headerlink" title="一、反射"></a>一、反射</h1><p>（1）概念<br>&nbsp;&nbsp;&nbsp;&nbsp;反射含义：可以获取正在运行的Java对象。<br>（2）功能<br>&nbsp;&nbsp;&nbsp;&nbsp;1)在运行时判断任意一个对象所属的类<br>&nbsp;&nbsp;&nbsp;&nbsp;2)在运行时构造任意一个类的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;3) 在运行时判断任意一个类所具有的成员变量和方法<br>&nbsp;&nbsp;&nbsp;&nbsp;4)在运行时调用任意一个对象的方法<br>（3）实现Java反射的类<br>&nbsp;&nbsp;&nbsp;&nbsp;1)Class：它表示正在运行的Java应用程序中的类和接口<br>&nbsp;&nbsp;&nbsp;&nbsp;2)Field：提供有关类或接口的属性信息，以及对它的动态访问权限<br>&nbsp;&nbsp;&nbsp;&nbsp;3)Constructor：提供关于类的单个构造方法的信息以及对它的访问权限<br>&nbsp;&nbsp;&nbsp;&nbsp;4)Method：提供关于类或接口中某个方法信息<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：<span style="color:red">Class类是Java反射中最重要的一个功能类，所有获取对象的信息(包括：方法/属性/构造方法/访问权限)都需要它来实现  </span></p><p>（4）取得class的三种方法</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> Dog(); </span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass = dog.getClass();</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass1 = Dog.<span class="keyword">class</span>;</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass2 = <span class="keyword">Class</span>.forName(<span class="string">"com.lin.Dog"</span>);<span class="comment">//注意要添加异常抛出</span></span><br></pre></td></tr></table></figure><p>（5）关键方法</p><table border="1"><tr><td>方法关键字</td><td>含义</td></tr><tr><td>getDeclaredMethods()</td><td>获取所有的方法</td></tr><tr><td>getReturnType()</td><td>获得方法的放回类型</td></tr><tr><td>getParameterTypes()</td><td>获得方法的传入参数类型</td></tr><tr><td>getDeclaredMethod(“方法名”,参数类型.class,……)</td><td>获得特定的方法</td></tr><tr><td></td><td></td></tr><tr><td>构造方法关键字</td><td>含义</td></tr><tr><td>getDeclaredConstructors()</td><td>获取所有的构造方法</td></tr><tr><td>getDeclaredConstructor(参数类型.class,……)</td><td>获取特定的构造方法</td></tr><tr><td></td><td></td></tr><tr><td>父类和父接口</td><td>含义</td></tr><tr><td>getSuperclass()</td><td>获取某类的父类</td></tr><tr><td>getInterfaces()</td><td>获取某类实现的接口</td></tr></table><p>（6）一些区别函数</p><p>public Method[] getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。</p><p>public Method[] getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p><p>getFields()获得某个类的所有的公共（public）的字段，包括父类。  </p><p>getDeclaredFields()获得某个类的所有申明的字段，即包括public、private和proteced，<br>但是不包括父类的申明字段。  </p><p>下面来看一个例子说明：</p><p>动物接口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"> </span><br><span class="line">public<span class="built_in"> interface </span>Aminal &#123;</span><br><span class="line"></span><br><span class="line">public String eat(String obj);</span><br><span class="line"></span><br><span class="line">public int <span class="builtin-name">run</span>(int obj);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.jar.Attributes.Name;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Aminal</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO 自动生成的构造函数存根  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;     </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">        System.out.println(name + <span class="string">"睡觉"</span> + x + <span class="string">"分钟"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eat</span><span class="params">(String obj)</span> </span>&#123;  </span><br><span class="line">        System.out.println(name + <span class="string">"吃"</span>+ obj);  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"跑，速度："</span>+ obj);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"狗名："</span> + name + <span class="string">"  狗的年纪："</span> + age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"狗狗自己玩啊玩"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看各自的调用：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectLearning</span> &#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line"> System.out.println(dog.getClass()); </span><br><span class="line"> System.out.println(dog.getClass().getName()); </span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">dogClass</span> = <span class="title">dog</span>.<span class="title">getClass</span>();</span></span><br><span class="line"> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">dogClass1</span> = <span class="title">Dog</span>.<span class="title">class</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">dogClass2</span> = <span class="title">Class</span>.<span class="title">forName</span>("<span class="title">com</span>.<span class="title">lin</span>.<span class="title">Dog</span>");</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">Method</span>[] <span class="title">methods1</span> =</span> dogClass.getMethods();</span><br><span class="line"> System.out.println(<span class="string">"====================通过getMethods取得方法开始===================="</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="function"><span class="keyword">Method</span> <span class="title">method</span> :</span> methods1) &#123;</span><br><span class="line"> System.out.println(<span class="function"><span class="keyword">method</span>); </span></span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(<span class="string">"====================通过getMethods取得方法结束===================="</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">Method</span>[] <span class="title">methods2</span> =</span> dogClass.getDeclaredMethods();</span><br><span class="line"> System.out.println(<span class="string">"====================通过getDeclaredMethods取得方法开始===================="</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="function"><span class="keyword">Method</span> <span class="title">method</span> :</span> methods2) &#123;</span><br><span class="line"> System.out.println(<span class="function"><span class="keyword">method</span>); </span></span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(<span class="string">"====================通过getDeclaredMethods取得方法结束===================="</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下结果：</p><p>getMethods方法</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122162709709" alt=""></p><p>getDeclareMethos方法：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122194430541" alt="">  </p><p>从上面可以看出getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p><h1 id="二、通过反射调用构造函数"><a href="#二、通过反射调用构造函数" class="headerlink" title="二、通过反射调用构造函数"></a>二、通过反射调用构造函数</h1><p>（1）、列出所有的构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = dogClass.getConstructors();</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"====================列出所有的构造函数结束===================="</span>);</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; <span class="keyword">constructor</span> : constructors) &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">constructor</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"====================列出所有的构造函数结束===================="</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122164012549" alt=""></p><p>（2）、通过反射生成对象</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"====================通过newInstance()来生成对象，一定在有默认构造函数===================="</span>);</span><br><span class="line">Dog dog1 = (Dog) dogClass.newInstance();</span><br><span class="line">dog1.setName(<span class="string">"狗狗1号"</span>);</span><br><span class="line">dog1.setAge(<span class="number">7</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(dog1);</span><br><span class="line"> </span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"====================通过newInstance(参数)方法一来生成对象===================="</span>);</span><br><span class="line">Dog dog2 = (Dog)constructors[<span class="number">0</span>].newInstance(<span class="string">"狗狗2号"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(dog2);</span><br><span class="line"> </span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"====================通过newInstance(参数)方法二来生成对象===================="</span>);</span><br><span class="line">Constructor con1 = dogClass.getConstructor(<span class="keyword">new</span>  <span class="keyword">Class</span>[]&#123;String.<span class="keyword">class</span>,<span class="keyword">int</span>.<span class="keyword">class</span>&#125;);     <span class="comment">//主要就是这句了</span></span><br><span class="line">Dog dog3 = (Dog) con1.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">"狗狗3号"</span>,<span class="number">14</span>&#125;);</span><br><span class="line">System.out.<span class="keyword">println</span>(dog3);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122165743286" alt="">  </p><p>从上面可以看出，先通过getConstructor(new  Class[]{xxxx.class,yyy.class}),再通过con1.newInstance(new Object[]{“xxxxx”,…});的方式是最灵活的，可以自动根据输入的参数类型和个数，找到对应的构造函数来调用。第二种方法需要得到构造函数的数组，并且需要知道对应哪一个构造函数。第一种就只能调用无参构造函数。</p><h1 id="三、通过反射调用普通函数、静态函数"><a href="#三、通过反射调用普通函数、静态函数" class="headerlink" title="三、通过反射调用普通函数、静态函数"></a>三、通过反射调用普通函数、静态函数</h1><p>（1）取得函数的一些基本信息</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; dogClass = Dog.class;</span><br><span class="line"><span class="function"><span class="keyword">Method</span>[] <span class="title">methods</span> = <span class="title">dogClass</span>.<span class="title">getDeclaredMethods</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="function"><span class="keyword">Method</span> <span class="title">method</span> :</span> methods) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">System.out.println("函数名："+method.getName() +"        函数类型："+ method.getModifiers() + "         函数返回： "+ method.getReturnType() + "        函数参数个数：" + method.getParameterCount());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122171525947" alt="">  </p><p>其中函数类型对应表如下：<br>PUBLIC: 1<br>PRIVATE: 2<br>PROTECTED: 4<br>STATIC: 8<br>FINAL: 16<br>SYNCHRONIZED: 32<br>VOLATILE: 64<br>TRANSIENT: 128<br>NATIVE: 256<br>INTERFACE: 512<br>ABSTRACT: 1024<br>STRICT: 2048  </p><p>（2）方法调用</p><p>这是当前狗类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.jar.Attributes.Name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Aminal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的构造函数存根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">"睡觉"</span> + x + <span class="string">"分钟"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">eat</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">"吃"</span>+ obj);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"跑，速度："</span>+ obj);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"狗名："</span> + name + <span class="string">"  狗的年纪："</span> + age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狗狗自己玩啊玩"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同方法的调用过程：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用私有方法</span></span><br><span class="line">Method method1 = dogClass.getDeclaredMethod(<span class="string">"sleep"</span>, int.class);<span class="comment">//不要用getMethod，它只能取到public方法</span></span><br><span class="line">Dog dog1 = (Dog) dogClass.getConstructor(<span class="keyword">new</span> <span class="type">Class</span>[] &#123;<span class="keyword">String</span>.class&#125;).<span class="keyword">new</span><span class="type">Instance</span>(<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"狗狗1号"</span>&#125;);</span><br><span class="line">method1.setAccessible(<span class="literal">true</span>);<span class="comment">//私有方法一定要加这句</span></span><br><span class="line">method1.invoke(dog1, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用私有静态方法</span></span><br><span class="line">              Method method2 = dogClass.getDeclaredMethod(<span class="string">"play"</span>);<span class="comment">//不要用getMethod，它只能取到public方法 </span></span><br><span class="line">              method2.setAccessible(<span class="literal">true</span>);<span class="comment">//私有方法一定要加这句</span></span><br><span class="line">             method2.invoke(dogClass.<span class="keyword">new</span><span class="type">Instance</span>()); </span><br><span class="line">      </span><br><span class="line">             <span class="comment">//调用公共方法</span></span><br><span class="line">Method method3 = dogClass.getMethod(<span class="string">"eat"</span>, <span class="keyword">String</span>.class);<span class="comment">//这里也可以用getDeclaredMethod</span></span><br><span class="line">Dog dog3 = <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"狗狗3号"</span>, <span class="number">45</span>);</span><br><span class="line">method3.invoke(dog3, <span class="string">"苹果～"</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122173757753" alt="">  </p><p>方法调用这里一定要记住getMethod和getDeclaredMethod的区别，并且在调用私有的方法之前一定要加setAccessible（true）这一句，要不会报错！</p><h1 id="四、通过反射取得字段、设置字段值"><a href="#四、通过反射取得字段、设置字段值" class="headerlink" title="四、通过反射取得字段、设置字段值"></a>四、通过反射取得字段、设置字段值</h1><p>(1)怎么通过反射获取类的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;a)Class.getDeclaredField(String name);<br>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。<br>&nbsp;&nbsp;&nbsp;&nbsp;b)Class.getDeclaredFields();<br>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。<br>&nbsp;&nbsp;&nbsp;&nbsp;c)Class.getField(String name);<br>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。<br>&nbsp;&nbsp;&nbsp;&nbsp;d)Class.getField();<br>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。  </p><p>(2)进行属性获取更改  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dog dog1 = <span class="keyword">new</span> Dog(<span class="string">"狗狗1号"</span>, <span class="number">12</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(dog1);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; dogClass = dog1.getClass();</span><br><span class="line">Field field1 = dogClass.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//注意，getField只能取得public的字段</span></span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);<span class="comment">//私有变量必须先设置Accessible为true</span></span><br><span class="line">   System.<span class="keyword">out</span>.println(<span class="string">"原本狗名："</span> + field1.<span class="keyword">get</span>(dog1));</span><br><span class="line"></span><br><span class="line">field1.<span class="keyword">set</span>(dog1,<span class="string">"狗狗2号"</span>);</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(dog1);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122194146554" alt="">  </p><p>值得注意的是获取私有属性的时候必须先设置Accessible为true，然后才能获取。  </p><h1 id="五、反射常用工具类"><a href="#五、反射常用工具类" class="headerlink" title="五、反射常用工具类"></a>五、反射常用工具类</h1><p>（1）bean复制工具<br>&nbsp;&nbsp;&nbsp;&nbsp;这里可以使用commons-beanutils中的copyProperties()方法，自己写是为了加深对反射的理解。</p><p>1、toString的基类</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.<span class="built_in">text</span>.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean基類</span></span><br><span class="line"><span class="comment"> * @author lin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class BaseBean &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> toString() &#123; </span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();  </span><br><span class="line">  SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">      Class&lt;?&gt; cls = <span class="keyword">this</span>.getClass();</span><br><span class="line">      Field[] fields = cls.getDeclaredFields();</span><br><span class="line">  sb.<span class="built_in">append</span>(cls.getName() + <span class="string">"&#123;"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">          field.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">          sb.<span class="built_in">append</span>(field.getName());  </span><br><span class="line">          sb.<span class="built_in">append</span>(<span class="string">"="</span>);  </span><br><span class="line">          sb.<span class="built_in">append</span>(field.<span class="built_in">get</span>(<span class="keyword">this</span>));  </span><br><span class="line">          sb.<span class="built_in">append</span>(<span class="string">" "</span>);  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">          e.printStackTrace();  </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line">      sb.<span class="built_in">append</span>(<span class="string">"&#125;"</span>);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、bean复制工具</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个JavaBean风格对象的属性值拷贝到另一个对象的同名属性中 (如果不存在同名属性的就不拷贝）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class BeanCopy &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> GET = <span class="string">"get"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> SET = <span class="string">"set"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param source</span></span><br><span class="line"><span class="comment">     * @param target</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">copy</span>(<span class="keyword">Object</span> source,<span class="keyword">Object</span> target)&#123;</span><br><span class="line">Class&lt;?&gt; sourceClz = source.getClass();</span><br><span class="line">Class&lt;?&gt; targetClz = target.getClass();</span><br><span class="line"><span class="comment">// 得到Class对象所表征的类的所有属性(包括私有属性)</span></span><br><span class="line">Field[] sourceFields = sourceClz.getDeclaredFields();</span><br><span class="line"><span class="keyword">if</span> (sourceFields.length == <span class="number">0</span>) &#123;</span><br><span class="line">sourceFields = sourceClz.getSuperclass().getDeclaredFields();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> len = sourceFields.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">String</span> fieldName = sourceFields[i].getName();</span><br><span class="line">Field targetField = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 得到targetClz对象所表征的类的名为fieldName的属性，不存在就进入下次循环</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">targetField = targetClz.getDeclaredField(fieldName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">targetField = targetClz.getSuperclass().getDeclaredField(fieldName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (targetField == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断sourceClz字段类型和targetClz同名字段类型是否相同</span></span><br><span class="line"><span class="keyword">if</span> (sourceFields[i].getType() == targetField.getType()) &#123;</span><br><span class="line"><span class="comment">// 由属性名字得到对应get和set方法的名字</span></span><br><span class="line"><span class="keyword">String</span> getMethodName = GET + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">String</span> setMethodName = SET + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 由方法的名字得到get和set方法的Method对象</span></span><br><span class="line">Method getMethod;</span><br><span class="line">Method setMethod;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getMethod = sourceClz.getDeclaredMethod(getMethodName,<span class="keyword">new</span> Class[] &#123;&#125;);<span class="comment">//get方法入參為空</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">getMethod = sourceClz.getSuperclass().getDeclaredMethod(getMethodName,<span class="keyword">new</span> Class[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">setMethod = targetClz.getDeclaredMethod(setMethodName,sourceFields[i].getType());<span class="comment">//set方法入參不為空</span></span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">setMethod = targetClz.getSuperclass().getDeclaredMethod(setMethodName,sourceFields[i].getType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用source对象的getMethod方法</span></span><br><span class="line"><span class="keyword">Object</span> result = getMethod.invoke(source, <span class="keyword">new</span> <span class="keyword">Object</span>[] &#123;&#125;);</span><br><span class="line"><span class="comment">// 调用target对象的setMethod方法</span></span><br><span class="line">setMethod.invoke(target, result);</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><p>新建两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">BaseBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Boolean sellFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> maxSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> minSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> driverPeople;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getSellFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSellFlag</span><span class="params">(Boolean sellFlag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sellFlag = sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">double</span> maxSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMinSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinSpeed</span><span class="params">(<span class="keyword">double</span> minSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.minSpeed = minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDriverPeople</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverPeople</span><span class="params">(<span class="keyword">int</span> driverPeople)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.driverPeople = driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">BaseBean</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Boolean sellFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> maxSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> minSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> driverPeople;<span class="comment">//和car類型不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> driverYear;<span class="comment">//car沒有這個</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getSellFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSellFlag</span><span class="params">(Boolean sellFlag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sellFlag = sellFlag;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">double</span> maxSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMinSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinSpeed</span><span class="params">(<span class="keyword">double</span> minSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.minSpeed = minSpeed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDriverPeople</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverPeople</span><span class="params">(<span class="keyword">long</span> driverPeople)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.driverPeople = driverPeople;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDriverYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> driverYear;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverYear</span><span class="params">(<span class="keyword">int</span> driverYear)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.driverYear = driverYear;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void test5() &#123;</span><br><span class="line">Car car = new Car()<span class="comment">;</span></span><br><span class="line">car.setAge(<span class="number">12</span>)<span class="comment">;</span></span><br><span class="line">car.setDriverPeople(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">car.setId(<span class="string">"YU1234"</span>)<span class="comment">;</span></span><br><span class="line">car.setMaxSpeed(<span class="number">13</span>.<span class="number">66</span>)<span class="comment">;</span></span><br><span class="line">car.setMinSpeed(<span class="number">1</span>.<span class="number">09</span>)<span class="comment">;</span></span><br><span class="line">car.setName(<span class="string">"小车"</span>)<span class="comment">;</span></span><br><span class="line">car.setSellFlag(false)<span class="comment">;</span></span><br><span class="line">car.setDate(new Date())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bus </span><span class="keyword">bus </span>= new <span class="keyword">Bus();</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">BeanCopy.copy(car,bus);</span></span><br><span class="line"><span class="keyword"></span>System.out.println(car)<span class="comment">;</span></span><br><span class="line">System.out.println(<span class="keyword">bus);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151122205834415" alt=""></p><p>除了两个不同的字段外，其它的都复制过去了，这在DTO、VO、DOMAIN对象转换时经常用到。</p><p><br><br><a href="http://my.csdn.net/?ref=toolbar" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;摘要：本文详细深入讲解是Java中反射的机制，并介绍了如何通过反射来生成对象、调用函数、取得字段、设置字段的方法。最后，给出了一些反射常用到的实例。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="反射" scheme="https://yfzhou.coding.me/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java反射探索-----从类加载说起</title>
    <link href="https://yfzhou.coding.me/2018/08/24/Java%E5%8F%8D%E5%B0%84%E6%8E%A2%E7%B4%A2-%E4%BB%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%AF%B4%E8%B5%B7/"/>
    <id>https://yfzhou.coding.me/2018/08/24/Java反射探索-从类加载说起/</id>
    <published>2018-08-24T06:29:49.000Z</published>
    <updated>2018-08-24T09:05:20.004Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;摘要：本文主要讲了Java类加载的机制，这是学习反射的入门基础。</p><a id="more"></a><h1 id="一、类加载"><a href="#一、类加载" class="headerlink" title="一、类加载"></a>一、类加载</h1><p><strong>JVM和类</strong>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们调用Java命令运行某个Java程序时，该命令将会启动一条Java虚拟机进程，不管该Java程序有多么复杂，该程序启动了多少个线程，它们都处于该Java虚拟机进程里。正如前面介绍的，同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。当系统出现以下几种情况时，JVM进程将被终止:  </p><p>1、程序运行到最后正常结束。<br>2、程序运行到使用System.exit()或Runtime.getRuntime().exit()代码结束程序。<br>3、程序执行过程中遇到未捕获的异常或错误而结束。<br>3、程序所在平台强制结束了JVM进程。<br>从上面的介绍可以看出，当Java程序运行结束时，JVM进程结束，该进程在内存中状态将会丢失。</p><p><strong>类的生命周期</strong></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021091611555" alt=""></p><p><strong>类的加载/类初始化</strong>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。</p><p><strong>加载：查找并加载类的二进制数据</strong></p><p>1、通过一个类的全限定名来获取定义此类的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</p><p><span style="color:red"><strong>注意：将编译后的java类文件（也就是.class文件）中的二进制数据读入内存，并将其放在运行时数据区的方法区内，然后再堆区创建一个Java.lang.Class对象，用来封装类在方法区的数据结构。即加载后最终得到的是Class对象，并且更加值得注意的是：该Java.lang.Class对象是单实例的，无论这个类创建了多少个对象，他的Class对象时唯一的！</strong>  </span><br><strong>连接：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1、验证：确保被加载的类的正确性<br>&nbsp;&nbsp;&nbsp;&nbsp;2、准备：为类的静态变量分配内存，并将其初始化为默认值<br>&nbsp;&nbsp;&nbsp;&nbsp;3、解析：把类中的符号引用转换为直接引用。<br><strong>初始化：为类的静态变量赋予正确的初始值。</strong></p><p><strong><span style="color:red">注意：连接和初始化阶段，其实静态变量经过了两次赋值：第一次是静态变量类型的默认值；第二次是我们真正赋给静态变量的值。</span></strong></p><p>我简单画了个图，其过程如下：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021091656155" alt="">  </p><p><strong><span style="color:red">类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。事实上，每个类是一批具有相同特征的对象的抽象(或者说概念)，而系统中所有的类，它们实际上也是对象，它们都是java.lang.Class的实例。</span></strong>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是我们前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</strong>  </p><p>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源:  </p><p><strong> 1、从本地文件系统来加载class文件，这是绝大部分示例程序的类加载方式。  </strong><br><strong>  2、从JAR包中加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就是放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。  </strong><br><strong>  3、通过网络加载class文件。  </strong><br><strong>  4、把一个Java源文件动态编译、并执行加载。</strong>  </p><p>类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。</p><p><strong>Java程序对类的使用方式  </strong><br><strong>  主动使用</strong><br>1、创建类的实例<br>2、方法某个类或接口的静态变量，或者对该静态变量赋值<br>3、调用类的静态方法<br>4、反射（如 Class.forName(“com.itzhai.Test”)）<br>5、初始化一个类的子类<br>6、Java虚拟机启动时被标明为启动类的类（Main Class）  </p><p><strong>被动使用</strong><br>除了以上6中方式，其他对类的使用都是被动使用，都不会导致类的初始化。类的初始化时机正是java程序对类的首次主动使用，<br>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化它们。</p><p><strong>对象初始化</strong><br>在类被装载、连接和初始化，这个类就随时都可能使用了。对象实例化和初始化是就是对象生命的起始阶段的活动，在这里我们主要讨论对象的初始化工作的相关特点。<br>Java 编译器在编译每个类时都会为该类至少生成一个实例初始化方法–即”<init>()” 方法。此方法与源代码中的每个构造方法相对应，如果类没有明确地声明任何构造方法，编译器则为该类生成一个默认的无参构造方法，这个默认的构造器仅仅调用父类的无参构造器，与此同时也会生成一个与默认构造方法对应的 “<init>()” 方法.<br>通常来说，<init>() 方法内包括的代码内容大概为：调用另一个 <init>() 方法；对实例变量初始化；与其对应的构造方法内的代码。<br>如果构造方法是明确地从调用同一个类中的另一个构造方法开始，那它对应的 <init>() 方法体内包括的内容为：一个对本类的 <init>() 方法的调用；对应用构造方法内的所有字节码。<br>如果构造方法不是通过调用自身类的其它构造方法开始，并且该对象不是 Object 对象，那 <init>() 法内则包括的内容为：一个对父类 <init>() 方法的调用；对实例变量初始化方法的字节码；最后是对应构造子的方法体字节码。<br>如果这个类是 Object，那么它的 <init>() 方法则不包括对父类 <init>() 方法的调用。</init></init></init></init></init></init></init></init></init></init></p><h1 id="二、Class-forName、实例对象-class-属性-、实例对象getClass-的区别"><a href="#二、Class-forName、实例对象-class-属性-、实例对象getClass-的区别" class="headerlink" title="二、Class.forName、实例对象.class(属性)、实例对象getClass()的区别"></a>二、Class.forName、实例对象.class(属性)、实例对象getClass()的区别</h1><p>1、相同点：<br>通过这几种方式，得到的都是Java.lang.Class对象（这个是上面讲到的类在加载时获得的最终产物）<br>例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> people &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> * @param args    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"..............使用不同的方式加载类..................."</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(people.<span class="keyword">class</span>);<span class="comment">//通过类.class获得Class对象</span></span><br><span class="line">people a = <span class="keyword">new</span> people();</span><br><span class="line">System.out.<span class="keyword">println</span>(a.getClass());<span class="comment">//通过 实例名.getClass()获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">Class</span>.forName(<span class="string">"com.lin.people"</span>));<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"..............使用不同的方式创建对象..................."</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(a);<span class="comment">//使用不同的方式创建对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(people.<span class="keyword">class</span>.newInstance());</span><br><span class="line">System.out.<span class="keyword">println</span>(a.getClass().newInstance());</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">Class</span>.forName(<span class="string">"com.lin.people"</span>).newInstance()); </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021091837350" alt=""></p><p>从上面可以看到不同的方式加载类。其实这一过程只发生一次！</p><p>2、区别：</p><p>下面用一个实例来说说它们的区别</p><p>如下新建一个类</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"生成了一只猫"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始使用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CatTest &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> * @param args    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class开始------------------"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(Cat.<span class="keyword">class</span>);<span class="comment">//通过类.class获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Class.forName开始------------------"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">Class</span>.forName(<span class="string">"com.lin.Cat"</span>));<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Class.forName结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()开始------------------"</span>);</span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.<span class="keyword">println</span>(cat.getClass());<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021092000170" alt=""></p><p>如果，将Class.forName()去掉：</p><p>如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能概要：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CatTest &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author linbingwen</span></span><br><span class="line"><span class="comment"> * @since  2015年10月20日 </span></span><br><span class="line"><span class="comment"> * @param args    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class开始------------------"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(Cat.<span class="keyword">class</span>);<span class="comment">//通过类.class获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------Cat.class结束------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("---------------Class.forName开始------------------");</span></span><br><span class="line"><span class="comment">//System.out.println(Class.forName("com.lin.Cat"));//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line"><span class="comment">//System.out.println("---------------Class.forName结束------------------");</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()开始------------------"</span>);</span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.<span class="keyword">println</span>(cat.getClass());<span class="comment">//通过Class.forName(全路径)获得Class对象</span></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"---------------cat.getClass()结束------------------"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果又变成：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20151021092344220" alt=""></p><p>所以，可以得出以下结论：</p><p>1)Class cl=Cat.class; <strong>JVM将使用类Cat的类装载器,将类A装入内存(前提是:类A还没有装入内存),不对类A做类的初始化工作.</strong>返回类A的Class的对象<br>2)Class cl=对象引用o.getClass();<strong>返回引用o运行时真正所指的对象(因为:儿子对象的引用可能会赋给父对象的引用变量中)所属的类的Class的对象 ,如果还没装载过，会进行装载。</strong><br>3)Class.forName(“类名”); <strong>装入类A,并做类的初始化(前提是:类A还没有装入内存)</strong>  </p><h1 id="三、new和newInstance"><a href="#三、new和newInstance" class="headerlink" title="三、new和newInstance()"></a>三、new和newInstance()</h1><p>从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。但是使用Class对象的newInstance()方法的时候，就必须保证：</p><p>1、这个类已经加载；</p><p>2、这个类已经连接了。而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。   </p><p>现在可以看出，Class对象的newInstance()（这种用法和Java中的工厂模式有着异曲同工之妙）实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。 </p><p>Class.forName().newInstance()和通过new得到对象的区别</p><p>1、使用newInstance可以解耦。使用newInstance的前提是，类已加载并且这个类已连接，这是正是class的静态方法forName（）完成的工作。newInstance实际上是把new 这个方式分解为两步，即，首先调用class的加载方法加载某个类，然后实例化。  </p><p>2、newInstance: 弱类型。低效率。只能调用无参构造。 new: 强类型。相对高效。能调用任何public构造。   </p><p>3、newInstance()是实现IOC、反射、面对接口编程和依赖倒置等技术方法的必然选择，new只能实现具体类的实例化，不适合于接口编程。   </p><p>4、 newInstance() 一般用于动态加载类。  </p><p>5、Class.forName(“”).newInstance()返回的是object 。</p><p>6、newInstance( )是一个方法，而new是一个关键字；</p><p>注:一般在通用框架里面用的就是class.forName来加载类,然后再通过反射来调用其中的方法,譬如Tomcat源码里面,这样就避免了new关键字的耦合度,还有让不同的类加载器来加载不同的类,方便提高类之间的安全性和隔离性.</p><p><a href="http://my.csdn.net/Evankaka" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;摘要：本文主要讲了Java类加载的机制，这是学习反射的入门基础。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="反射" scheme="https://yfzhou.coding.me/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="类加载" scheme="https://yfzhou.coding.me/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程学习（吐血超详细总结）</title>
    <link href="https://yfzhou.coding.me/2018/08/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%90%90%E8%A1%80%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/23/Java多线程学习（吐血超详细总结）/</id>
    <published>2018-08-23T08:10:48.000Z</published>
    <updated>2018-08-23T12:14:34.345Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面的话：此文只能说是java多线程的一个入门，其实Java里头线程完全可以写一本书了，但是如果最基本的你都学掌握好，又怎么能更上一个台阶呢？如果你觉得此文很简单，那推荐你看看Java并发包的的线程池（<a href="http://blog.csdn.net/evankaka/article/details/51489322" target="_blank" rel="noopener">Java并发编程与技术内幕:线程池深入理解</a>），或者看这个专栏：<a href="http://blog.csdn.net/column/details/javahhighconcurrence.html" target="_blank" rel="noopener">Java并发编程与技术内幕</a>。你将会对Java里头的高并发场景下的线程有更加深刻的理解。</p><a id="more"></a><p>目录</p><ol><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t0" target="_blank" rel="noopener">一扩展javalangThread类</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t1" target="_blank" rel="noopener">二实现javalangRunnable接口</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t2" target="_blank" rel="noopener">三Thread和Runnable的区别</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t3" target="_blank" rel="noopener">四线程状态转换</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t4" target="_blank" rel="noopener">五线程调度</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t5" target="_blank" rel="noopener">六常用函数说明</a><ol><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t6" target="_blank" rel="noopener">使用方式</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t7" target="_blank" rel="noopener">为什么要用join方法</a></li></ol></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t8" target="_blank" rel="noopener">七常见线程名词解释</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t9" target="_blank" rel="noopener">八线程同步</a></li><li><a href="http://blog.csdn.net/evankaka/article/details/44153709#t10" target="_blank" rel="noopener">九线程数据传递</a></li></ol><p>本文主要讲了java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别：</p><p><strong>　　进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）</strong></p><p><strong>　　线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</strong></p><p>　　<span style="color:red">线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</span></p><p>　　<span style="color:red">多进程是指操作系统能同时运行多个任务（程序）。</span></p><p>　　多线程是指在同一程序中有多个顺序流在执行。</p><p>在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(<span style="color:red"><strong>其实准确来讲，应该有三种，还有一种是实现Callable接口</strong></span>，并与Future、线程池结合使用，此文这里不讲这个，有兴趣看这里<a href="http://blog.csdn.net/evankaka/article/details/51610635" target="_blank" rel="noopener">Java并发编程与技术内幕:Callable、Future、FutureTask、CompletionService</a>)  </p><h1 id="一、扩展java-lang-Thread类"><a href="#一、扩展java-lang-Thread类" class="headerlink" title="一、扩展java.lang.Thread类"></a>一、扩展java.lang.Thread类</h1><p>这里继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.（<span style="color:red"><strong>笔者推荐使用Runable，后头会说明为什么</strong></span>）。下面来看一个简单的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.multithread.learning;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行  :  "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：</p><p>A运行  :  0<br>B运行  :  0<br>A运行  :  1<br>A运行  :  2<br>A运行  :  3<br>A运行  :  4<br>B运行  :  1<br>B运行  :  2<br>B运行  :  3<br>B运行  :  4</p><p>再运行一下：</p><p>A运行  :  0<br>B运行  :  0<br>B运行  :  1<br>B运行  :  2<br>B运行  :  3<br>B运行  :  4<br>A运行  :  1<br>A运行  :  2<br>A运行  :  3<br>A运行  :  4  </p><p>说明：</p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。</p><p>注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p><p>从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</p><p>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</p><p>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。</p><p>但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread1 mTh1=new Thread1(<span class="string">"A"</span>)<span class="comment">;</span></span><br><span class="line">Thread1 mTh2=mTh1<span class="comment">;</span></span><br><span class="line">mTh1.start()<span class="comment">;</span></span><br><span class="line">mTh2.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.IllegalThreadStateException</span>  </span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.start</span>(Unknown Source)  </span><br><span class="line">    at com<span class="selector-class">.multithread</span><span class="selector-class">.learning</span><span class="selector-class">.Main</span><span class="selector-class">.main</span>(Main<span class="selector-class">.java</span>:<span class="number">31</span>)  </span><br><span class="line">A运行  :  <span class="number">0</span>  </span><br><span class="line">A运行  :  <span class="number">1</span>  </span><br><span class="line">A运行  :  <span class="number">2</span>  </span><br><span class="line">A运行  :  <span class="number">3</span>  </span><br><span class="line">A运行  :  <span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="二、实现java-lang-Runnable接口"><a href="#二、实现java-lang-Runnable接口" class="headerlink" title="二、实现java.lang.Runnable接口"></a>二、实现java.lang.Runnable接口</h1><p>采用Runnable也是非常常见的一种，我们只需要重写run方法即可。下面也来看个实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.multithread.runnable;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行  :  "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"C"</span>)).start();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"D"</span>)).start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：</p><p>C运行  :  0<br>D运行  :  0<br>D运行  :  1<br>C运行  :  1<br>D运行  :  2<br>C运行  :  2<br>D运行  :  3<br>C运行  :  3<br>D运行  :  4<br>C运行  :  4</p><p>说明：</p><p>Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><h1 id="三、Thread和Runnable的区别"><a href="#三、Thread和Runnable的区别" class="headerlink" title="三、Thread和Runnable的区别"></a>三、Thread和Runnable的区别</h1><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p><p><strong>总结：  </strong></p><p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p><p><strong>1）：适合多个相同的程序代码的线程去处理同一个资源</strong></p><p><strong>2）：可以避免java中的单继承的限制</strong></p><p><strong>3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</strong></p><p><strong>4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</strong></p><p><span style="color:red"><strong>提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。</strong></span></p><p><span style="color:red"><strong>在**</strong>java<strong><strong>中，每次程序运行至少启动</strong></strong>2<strong><strong>个线程。一个是</strong></strong>main<strong><strong>线程，一个是垃圾收集线程。因为每当使用</strong></strong>java<strong>**命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ实习在就是在操作系统中启动了一个进程。</strong></span></p><h1 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h1><p>下面的这个图非常重要！你如果看懂了这个图，那么对于多线程的理解将会更加深刻！</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20150309140927553" alt="">  </p><p>1、新建状态（New）：新创建了一个线程对象。</p><p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</p><p>3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</p><p><span style="color:red"><strong>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</strong></span></p><p><span style="color:red"><strong>（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</strong></span></p><p><span style="color:red"><strong>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</strong></span></p><p><span style="color:red"><strong>（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</strong></span></p><p>5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。  </p><h1 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h1><p>线程的调度</p><p>1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。</p><p>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程可以具有的最高优先级，取值为10。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY</span><br><span class="line"><span class="comment">//线程可以具有的最低优先级，取值为1。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY</span><br><span class="line"><span class="comment">//分配给线程的默认优先级，取值为5。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY</span><br></pre></td></tr></table></figure></p><p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p><p> 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。</p><p>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p><p>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p><p>2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><p>3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p><p>4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><p>5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><p>6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><p> 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。  </p><h1 id="六、常用函数说明"><a href="#六、常用函数说明" class="headerlink" title="六、常用函数说明"></a>六、常用函数说明</h1><p><strong>① sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）  </strong>  </p><p><strong>② join():指等待t线程终止。</strong>  </p><h3 id="使用方式。"><a href="#使用方式。" class="headerlink" title="使用方式。"></a>使用方式。</h3><p>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> t = <span class="function"><span class="keyword">new</span> <span class="title">AThread</span>(); <span class="title">t</span>.<span class="title">start</span>(); <span class="title">t</span>.<span class="title">join</span>();</span></span><br></pre></td></tr></table></figure><h3 id="为什么要用join-方法"><a href="#为什么要用join-方法" class="headerlink" title="为什么要用join()方法"></a>为什么要用join()方法</h3><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p>不加join。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@functon 多线程学习,join</span></span><br><span class="line"><span class="comment"> *@author 林炳文</span></span><br><span class="line"><span class="comment"> *@time 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">package com.multithread.<span class="keyword">join</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span>(<span class="params">String name</span>) </span>&#123;</span><br><span class="line">    super(name);</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" 线程运行开始!"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span>+name + <span class="string">"运行 : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" 线程运行结束!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+<span class="string">"主线程运行开始!"</span>);</span><br><span class="line">Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+ <span class="string">"主线程运行结束!"</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>main主线程运行开始!<br>main主线程运行结束!<br>B 线程运行开始!<br>子线程B运行 : 0<br>A 线程运行开始!<br>子线程A运行 : 0<br>子线程B运行 : 1<br>子线程A运行 : 1<br>子线程A运行 : 2<br>子线程A运行 : 3<br>子线程A运行 : 4<br>A 线程运行结束!<br>子线程B运行 : 2<br>子线程B运行 : 3<br>子线程B运行 : 4<br>B 线程运行结束!<br>发现主线程比子线程早结束  </p><p>加join<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+<span class="string">"主线程运行开始!"</span>);</span><br><span class="line">Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mTh1.<span class="keyword">join</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mTh2.<span class="keyword">join</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+ <span class="string">"主线程运行结束!"</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>main主线程运行开始!<br>A 线程运行开始!<br>子线程A运行 : 0<br>B 线程运行开始!<br>子线程B运行 : 0<br>子线程A运行 : 1<br>子线程B运行 : 1<br>子线程A运行 : 2<br>子线程B运行 : 2<br>子线程A运行 : 3<br>子线程B运行 : 3<br>子线程A运行 : 4<br>子线程B运行 : 4<br>A 线程运行结束!<br>主线程一定会等子线程都结束了才结束  </p><p><strong>③ yield():暂停当前正在执行的线程对象，并执行其他线程。</strong>  </p><p>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p><p><span style="color:red"><strong>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。</strong></span>因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p> <span style="color:red">结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习 yield</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.multithread.yield;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadYield</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">""</span> + <span class="keyword">this</span>.getName() + <span class="string">"-----"</span> + i);</span><br><span class="line">            <span class="comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）</span></span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ThreadYield yt1 = <span class="keyword">new</span> ThreadYield(<span class="string">"张三"</span>);</span><br><span class="line">    ThreadYield yt2 = <span class="keyword">new</span> ThreadYield(<span class="string">"李四"</span>);</span><br><span class="line">        yt1.start();</span><br><span class="line">        yt2.start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。</p><p>第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。  </p><p><strong>sleep()和yield()的区别</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>&nbsp;&nbsp;&nbsp;sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程<br>&nbsp;&nbsp;&nbsp;&nbsp;另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。  </p><p><strong>④setPriority(): 更改线程的优先级。</strong><br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MIN_PRIORITY</span> = <span class="number">1</span>  </span><br><span class="line"><span class="attr">NORM_PRIORITY</span> = <span class="number">5</span>  </span><br><span class="line"><span class="attr">MAX_PRIORITY</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>用法：  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread4 <span class="built_in">t1</span> = new Thread4(<span class="string">"t1"</span>)<span class="comment">;</span></span><br><span class="line">Thread4 <span class="built_in">t2</span> = new Thread4(<span class="string">"t2"</span>)<span class="comment">;</span></span><br><span class="line"><span class="built_in">t1</span>.setPriority(Thread.MAX_PRIORITY)<span class="comment">;</span></span><br><span class="line"><span class="built_in">t2</span>.setPriority(Thread.MIN_PRIORITY)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><span style="color:red"><strong>⑤interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！</strong></span></p><p>⑥wait()</p><p>Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对Object.wait()，Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题了吧，这是一道比较经典的面试题，题目要求如下：</p><p>&nbsp;&nbsp;&nbsp;建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait用法</span></span><br><span class="line"><span class="comment"> * @author DreamSea </span></span><br><span class="line"><span class="comment"> * @time 2015.3.9 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.multithread.wait;</span><br><span class="line"><span class="keyword">public</span> class MyThreadPrinter2 implements Runnable &#123;   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> prev;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> self;   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> MyThreadPrinter2(<span class="keyword">String</span> name, <span class="keyword">Object</span> prev, <span class="keyword">Object</span> self) &#123;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.prev = prev;   </span><br><span class="line">        <span class="keyword">this</span>.self = self;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;   </span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">10</span>;   </span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            <span class="keyword">synchronized</span> (prev) &#123;   </span><br><span class="line">                <span class="keyword">synchronized</span> (self) &#123;   </span><br><span class="line">                    System.out.<span class="built_in">print</span>(name);   </span><br><span class="line">                    count--;  </span><br><span class="line">                    </span><br><span class="line">                    self.notify();   </span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">try</span> &#123;   </span><br><span class="line">                    prev.wait();   </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;   </span><br><span class="line">        <span class="keyword">Object</span> a = <span class="keyword">new</span> <span class="keyword">Object</span>();   </span><br><span class="line">        <span class="keyword">Object</span> b = <span class="keyword">new</span> <span class="keyword">Object</span>();   </span><br><span class="line">        <span class="keyword">Object</span> c = <span class="keyword">new</span> <span class="keyword">Object</span>();   </span><br><span class="line">        MyThreadPrinter2 pa = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"A"</span>, c, a);   </span><br><span class="line">        MyThreadPrinter2 pb = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"B"</span>, a, b);   </span><br><span class="line">        MyThreadPrinter2 pc = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"C"</span>, b, c);   </span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">new</span> Thread(pa).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  <span class="comment">//确保按顺序A、B、C执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(pb).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        <span class="keyword">new</span> Thread(pc).start();   </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>ABCABCABCABCABCABCABCABCABCABC  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>wait和sleep区别  </strong><br><strong>共同点：</strong><br>1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。<br>2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。<br>   如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。<br>   需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。<br><strong>不同点：</strong><br>1. Thread类的方法：sleep(),yield()等<br>   Object的方法：wait()和notify()等<br>2. 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。<br>   <span style="color:red">sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。  </span><br>3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用<br><span style="color:red">所以sleep()和wait()方法的最大区别是：<br>　　　　sleep()睡眠时，保持对象锁，仍然占有该锁；<br>　　　　而wait()睡眠时，释放对象锁。<br>　　但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。  </span><br><strong>sleep（）方法</strong><br>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;<br>　　 sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。<br>　　在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。<br><strong>wait（）方法</strong><br>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；<br>　　wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。<br>　　wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。  </p><h1 id="七、常见线程名词解释"><a href="#七、常见线程名词解释" class="headerlink" title="七、常见线程名词解释"></a>七、常见线程名词解释</h1><p>主线程：JVM调用程序main()所产生的线程。</p><p>当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。</p><p>后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。<strong>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</strong></p><p>前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</p><p><strong>线程类的一些常用方法：   </strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sleep</span><span class="params">()</span></span>: 强迫一个线程睡眠Ｎ毫秒。 </span><br><span class="line"><span class="function"><span class="title">isAlive</span><span class="params">()</span></span>: 判断一个线程是否存活。 </span><br><span class="line"><span class="function"><span class="title">join</span><span class="params">()</span></span>: 等待线程终止。 </span><br><span class="line"><span class="function"><span class="title">activeCount</span><span class="params">()</span></span>: 程序中活跃的线程数。 </span><br><span class="line"><span class="function"><span class="title">enumerate</span><span class="params">()</span></span>: 枚举程序中的线程。 </span><br><span class="line"><span class="function"><span class="title">currentThread</span><span class="params">()</span></span>: 得到当前线程。 </span><br><span class="line"><span class="function"><span class="title">isDaemon</span><span class="params">()</span></span>: 一个线程是否为守护线程。 </span><br><span class="line"><span class="function"><span class="title">setDaemon</span><span class="params">()</span></span>: 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) </span><br><span class="line"><span class="function"><span class="title">setName</span><span class="params">()</span></span>: 为线程设置一个名称。 </span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">()</span></span>: 强迫一个线程等待。 </span><br><span class="line"><span class="function"><span class="title">notify</span><span class="params">()</span></span>: 通知一个线程继续运行。 </span><br><span class="line"><span class="function"><span class="title">setPriority</span><span class="params">()</span></span>: 设置一个线程的优先级。</span><br></pre></td></tr></table></figure><h1 id="八、线程同步"><a href="#八、线程同步" class="headerlink" title="八、线程同步"></a>八、线程同步</h1><p><span style="color:#0000ff;">1、synchronized关键字的作用域有二种：  </span><br><span style="color:#0000ff;">1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；  </span><br><span style="color:#0000ff;">2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。  </span></p><p><span style="color:#0000ff;">2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象；  </span></p><p><span style="color:#0000ff;">3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；  </span></p><p>Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对synchronized关键字的作用进行深入了解才可定论。</p><p>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</p><p>在进一步阐述之前，我们需要明确几点：</p><p>A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</p><p>B．每个对象只有一个锁（lock）与之相关联。</p><p>C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p><p>接着来讨论synchronized用到不同地方对代码产生的影响：</p><p>假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。</p><p>1．  把synchronized当作函数修饰符时，示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//….</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。</p><p>上边的示例代码等同于如下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;      <span class="comment">//  (1)</span></span><br><span class="line">    <span class="comment">//…..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> (1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱：（</p><p>2．同步块，示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">(SomeObject so)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(so) &#123;</span><br><span class="line">    <span class="comment">//…..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量</span></span><br><span class="line">  <span class="function">Public <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123; </span><br><span class="line">      <span class="comment">//… &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//…..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p><p>3．将synchronized作用于static 函数，示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Foo &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span> </span>&#123;  <span class="comment">// 同步的static 函数</span></span><br><span class="line">    <span class="comment">//….</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">methodBBB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Foo.class)   <span class="comment">//  class literal(类名称字面常量)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。</p><p>记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。</p><p>可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。</p><p><strong>总结一下：</strong></p><p>1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。<br>2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法<br>3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。<br>4、对于同步，要时刻清醒在哪个对象上同步，这是关键。<br>5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。<br>6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。<br>7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。  </p><h1 id="九、线程数据传递"><a href="#九、线程数据传递" class="headerlink" title="九、线程数据传递"></a>九、线程数据传递</h1><p>在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和return语句来返回数据。  </p><p>9.1、通过构造方法传递数据<br>在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用(其实就是在run方法中使用)。下面的代码演示了如何通过构造方法来传递数据：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">package</span> mythread; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span>  </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(String name)</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"hello "</span> + name); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread1(<span class="string">"world"</span>); </span><br><span class="line">    thread.start(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 </p><p>9.2、通过变量和方法传递数据<br>向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对MyThread1类的改版，使用了一个setName方法来设置 name变量：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">package</span> mythread; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">this</span>.name = name; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">System.out.println(<span class="string">"hello "</span> + name); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">MyThread2 myThread = <span class="keyword">new</span> MyThread2(); </span><br><span class="line">myThread.setName(<span class="string">"world"</span>); </span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread); </span><br><span class="line">thread.start(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.3、通过回调函数传递数据 </p><p>上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个 value是无法事先就传入线程类的。   </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">package mythread; </span><br><span class="line"><span class="keyword">class</span> <span class="title">Data</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Work</span> &#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">Data data, Integer numbers</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : numbers) &#123; </span><br><span class="line">      data.<span class="keyword">value</span> += n; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyThread3</span> <span class="title">extends</span> <span class="title">Thread</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> Work work; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread3</span>(<span class="params">Work work</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.work = work; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    java.util.Random random = <span class="keyword">new</span> java.util.Random(); </span><br><span class="line">    Data data = <span class="keyword">new</span> Data(); </span><br><span class="line">    <span class="keyword">int</span> n1 = random.nextInt(<span class="number">1000</span>); </span><br><span class="line">    <span class="keyword">int</span> n2 = random.nextInt(<span class="number">2000</span>); </span><br><span class="line">    <span class="keyword">int</span> n3 = random.nextInt(<span class="number">3000</span>); </span><br><span class="line">    work.process(data, n1, n2, n3); <span class="comment">// 使用回调函数 </span></span><br><span class="line">    System.<span class="keyword">out</span>.println(String.valueOf(n1) + <span class="string">"+"</span> + String.valueOf(n2) + <span class="string">"+"</span> </span><br><span class="line">    + String.valueOf(n3) + <span class="string">"="</span> + data.<span class="keyword">value</span>); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread3(<span class="keyword">new</span> Work()); </span><br><span class="line">    thread.start(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;好了，Java多线程的基础知识就讲到这里了，有兴趣研究多线程的推荐直接看java的源码，你将会得到很大的提升！</p><p><a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">林炳文Evankaka</a>原创作品。转载请注明出处<a href="http://blog.csdn.net/evankaka" target="_blank" rel="noopener">http://blog.csdn.net/evankaka</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面的话：此文只能说是java多线程的一个入门，其实Java里头线程完全可以写一本书了，但是如果最基本的你都学掌握好，又怎么能更上一个台阶呢？如果你觉得此文很简单，那推荐你看看Java并发包的的线程池（&lt;a href=&quot;http://blog.csdn.net/evankaka/article/details/51489322&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程与技术内幕:线程池深入理解&lt;/a&gt;），或者看这个专栏：&lt;a href=&quot;http://blog.csdn.net/column/details/javahhighconcurrence.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程与技术内幕&lt;/a&gt;。你将会对Java里头的高并发场景下的线程有更加深刻的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="多线程" scheme="https://yfzhou.coding.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript工作原理：V8引擎和5招优化</title>
    <link href="https://yfzhou.coding.me/2018/08/23/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9AV8%E5%BC%95%E6%93%8E%E5%92%8C5%E6%8B%9B%E4%BC%98%E5%8C%96/"/>
    <id>https://yfzhou.coding.me/2018/08/23/JavaScript工作原理：V8引擎和5招优化/</id>
    <published>2018-08-23T03:51:12.000Z</published>
    <updated>2018-08-23T06:39:54.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript引擎是执行JavaScript代码的程序或解释器。JavaScript引擎可以作为标准解释器或即时编译器来实现，该编译器以某种形式将JavaScript编译为字节码。</p><a id="more"></a><p>流行的JavaScript引擎：</p><ul><li>V8：开源，Google开发，C++，Chrome浏览器 Rhino：开源，Mozilla开发，Java</li><li>SpiderMonkey：第一个JavaScript引擎，网景浏览器（之前）和Firefox（现在）</li><li>JavaScriptCore：开源，苹果Safari浏览器 - Chakra（JSscript9）：Internet Explorer浏览器</li><li>Chakra（JavaScript）：Microsoft Edge浏览器</li></ul><h3 id="V8起源"><a href="#V8起源" class="headerlink" title="V8起源"></a>V8起源</h3><p>V8引擎是由Google构建的，以C++开发并且开源，与其它的引擎不同的是，V8还是Node.js的运行时环境。</p><p><img src="https://image-static.segmentfault.com/118/401/1184019299-599fa1648acc6_articlex" alt="v8_why" title="v8_why"></p><p>V8最初设计用于提高浏览器内部JavaScript执行的性能。为了获得速度，V8将JavaScript代码转换为更高效的机器代码，而不是使用解释器。它通过实现JIT（Just-In-Time）编译器（如SpiderMonkey或Rhino（Mozilla）等许多现代JavaScript引擎）将JavaScript代码编译为机器代码。 这里的主要区别在于V8不生成字节码或任何中间代码。</p><h3 id="V8曾经的两个编译器"><a href="#V8曾经的两个编译器" class="headerlink" title="V8曾经的两个编译器"></a>V8曾经的两个编译器</h3><p>在V8引擎的v5.9版本出来之前，V8有两个编译器：<br>full-codegen：一个简单而且速度非常快的编译器，可以生成简单且相对较慢的机器代码。<br>Crankshaft：一种更复杂（Just-In-Time）的优化编译器，可以生成高度优化的代码。</p><p>V8引擎还在内部使用多个线程：</p><ul><li>主线程完成预定的任务：获取你的代码，编译它然后执行它</li><li>一个单独的线程用于编译，当这个单独的线程优化代码时，主线程可以继续执行</li><li>一个Profiler线程，它会告诉运行时我们花了很多时间，使得Crankshaft能够优化它们</li><li>一些线程处理垃圾处理器扫描</li></ul><p>当第一次执行JavaScript代码时，V8利用full-codegen，直接将解析的JavaScript翻译成机器代码而无需任何转换。这使它可以非常快速地开始执行机器代码。请注意，V8不使用中间字节码表示法，不需要解释器。</p><p>当您的代码运行一段时间后，Profiler线程已经收集了足够的数据以确定哪种方法应该进行优化。</p><p>接下来，Crankshaft优化从另一个线程开始。它将JavaScript抽象语法树翻译为称为Hydrogen的高级静态单分配（SSA）表示，并尝试优化该hydrogen图。 大多数优化都是在这个级别完成的。</p><h3 id="优化：内联"><a href="#优化：内联" class="headerlink" title="优化：内联"></a>优化：内联</h3><p>第一次优化是提前尽可能多地嵌入代码。 内联是将被调用函数的主体替换为调用网站（调用该函数的代码行）的过程。 这个简单的步骤可以让以下优化变得更有意义。</p><p><img src="https://image-static.segmentfault.com/912/896/912896149-5ae2d38d99b77_articlex" alt="v8_inling" title="v8_inling"></p><h3 id="优化：隐藏的类"><a href="#优化：隐藏的类" class="headerlink" title="优化：隐藏的类"></a>优化：隐藏的类</h3><p>JavaScript是一种基于原型的语言：没有类，对象的创建是通过克隆实现的。JavaScript也是一种动态编程语言，它意味着属性可以在实例化后轻松添加或从对象中移除。</p><p>大多数JavaScript解释器使用字典式结构（基于哈希函数）来存储对象属性值在内存中的位置。这种结构使得检索JavaScript中的属性的值比在Java或C＃等非动态编程语言中的计算更昂贵。在Java中，所有对象属性都是在编译之前由固定的对象布局确定的，并且不能在运行时动态添加或删除（当然，C＃的动态类型是另一个主题）。因此，属性的值（或指向这些属性的指针）可以作为连续缓冲区存储在内存中，每个值之间都有一个固定偏移量。偏移量的长度可以根据属性类型轻松确定，但在运行时可以更改属性类型的JavaScript中不可行。</p><p>由于使用字典查找内存中对象属性的位置效率非常低，因此V8使用不同的方法：隐藏类。隐藏类的工作方式与Java等语言中使用的固定对象布局（类）类似，除了它们是在运行时创建的。现在，让我们看看他们实际的样子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>当“new Point(1, 2)”被执行时， V8引擎会创建一个名为C0的隐藏类。</p><p><img src="https://image-static.segmentfault.com/338/869/3388694770-5ae29b3121882_articlex" alt="v8_hidden_class_c0" title="v8_hidden_class_c0"></p><p>由于Point还未定义任何属性，因此“C0”为空。</p><p>一旦执行了第一条语句“this.x = x”（在“Point”函数内部），V8将创建第二个隐藏类“C1”，它基于“C0”。“C1”描述了可以找到属性x的存储器中的位置（相对于对象指针）。在这种情况下，“x”存储在偏移量0处，这意味着在内存中将点对象视为连续缓冲区时，第一个偏移量将对应于属性“x”。 V8还将用“类别转换”更新“C0”，该类别转换指出如果将属性“x”添加到点对象，隐藏类应从“C0”切换到“C1”。 下面的点对象的隐藏类现在是“C1”。</p><p><img src="https://image-static.segmentfault.com/247/471/2474713203-5ae29c6d63386_articlex" alt="v8_hidden-class_c1" title="v8_hidden-class_c1"></p><p>每次将新属性添加到对象时，旧的隐藏类都会使用到新隐藏类的转换路径进行更新。隐藏类转换非常重要，因为它们允许隐藏类在以相同方式创建的对象之间共享。如果两个对象共享一个隐藏类并向它们添加了相同的属性，则转换将确保两个对象都接收到相同的新隐藏类以及随附的所有优化代码。</p><p>当执行语句“this.y = y”（同样，在“this.x = x”语句之后的Point函数内部）时，将重复此过程。</p><p>创建一个名为“C2”的新隐藏类，将类转换添加到“C1”，指出如果将属性“y”添加到Point对象（已包含属性“x”），则隐藏类应更改为 “C2”，点对象的隐藏类更新为“C2”。</p><p><img src="https://image-static.segmentfault.com/400/635/4006356827-5ae2c8a2f300d_articlex" alt="v8_hidden-class_c2" title="v8_hidden-class_c2"></p><p>隐藏类转换取决于将属性添加到对象的顺序。 看看下面的代码片段：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span></span>(x, y) &#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p>现在，您可能认为对于p1和p2，将使用相同的隐藏类和转换。事实上却不是。对于“p1”，首先添加属性“a”，然后添加属性“b”。然而，对于“p2”，首先分配“b”，然后是“a”。 因此，由于不同的转换路径，“p1”和“p2”以不同的隐藏类结束。在这种情况下，以相同顺序初始化动态属性好得多，以便隐藏的类可以重用。</p><p><strong>内联缓存</strong><br>V8利用另一种技术来优化称为内联缓存的动态类型化语言。内联缓存依赖于观察到对相同方法的重复调用倾向于发生在相同类型的对象上。在这里可以找到关于内联缓存的深入解释。</p><p>我们将讨论内联缓存的一般概念（如果您没有时间通过​​上面的深入解释）。</p><p>那么它是怎样工作的？ V8维护一个对象类型的缓存，这些对象在最近的方法调用中作为参数传递，并使用这些信息来预测将来作为参数传递的对象的类型。如果V8能够对传递给方法的对象的类型做出很好的假设，那么它可以绕过确定如何访问对象属性的过程，而是使用以前查找存储的信息到对象的隐藏课程。</p><p>那么隐藏类和内联缓存的概念如何相关？无论何时在特定对象上调用方法，V8引擎都必须执行对该对象的隐藏类的查找，以确定访问特定属性的偏移量。在相同隐藏类的两次成功调用之后，V8省略了隐藏类查找，并简单地将该属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8引擎都假定隐藏的类没有更改，并使用从以前的查找存储的偏移量直接跳转到特定属性的内存地址。这大大提高了执行速度。</p><p>内联缓存也是为什么相同类型的对象共享隐藏类非常重要的原因。如果您创建两个具有相同类型和不同隐藏类的对象（就像我们之前的示例中那样），V8将无法使用内联缓存，因为即使这两个对象的类型相同，它们对应的隐藏类为其属性分配不同的偏移量。</p><p><img src="https://image-static.segmentfault.com/307/815/3078150790-5ae2caae22fb4_articlex" alt="v8_inline_cacahing" title="v8_inline_cacahing"></p><h3 id="编译为机器码"><a href="#编译为机器码" class="headerlink" title="编译为机器码"></a>编译为机器码</h3><p>一旦Hydrogen图被优化，Crankshaft将其降低到称为Lithium的较低级表示。大部分的Lithium实施都是特定于架构的。寄存器分配发生在这个级别。</p><p>最终，Lithium被编译成机器码。然后发生其他事情，称为OSR：堆栈替换。在我们开始编译和优化那些耗时较长的方法之前，我们可能会运行它。V8不会忘记它刚刚缓慢执行的内容，以再次优化版本开始。相反，它会转换我们拥有的所有上下文（堆栈，寄存器），以便我们可以在执行过程中切换到优化版本。这是一项非常复杂的任务，考虑到除了其他优化之外，V8最初还是将代码内联。 V8不是唯一能够做到的引擎。</p><p>有一种叫做去最佳化的保护措施可以做出相反的转变，并在引擎的假设不再成立的情况下恢复到非优化的代码。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>对于垃圾收集，V8采用了传统的标记清除方式来清理老一代。标记阶段应该停止JavaScript执行。为了控制GC成本并使执行更加稳定，V8使用增量标记：不是遍历整个堆，而是试图标记每个可能的对象，它只走过堆的一部分，然后恢复正常执行。下一个GC停止将从先前堆走过的地方继续。这允许在正常执行期间非常短的暂停。如前所述，扫描阶段由单独的线程处理。</p><h3 id="Ignition和TurboFan"><a href="#Ignition和TurboFan" class="headerlink" title="Ignition和TurboFan"></a>Ignition和TurboFan</h3><p>随着2017年早些时候发布V8 5.9，引入了新的执行流程。这个新的管道在实际的JavaScript应用程序中实现了更大的性能改进和显着的内存节省。</p><p>新的执行流程建立在Ignition，V8的解释器和TurboFan，V8的最新优化编译器之上。</p><p>您可以查看V8团队关于此主题的博客文章。</p><p>自从V8.5版本问世以来，V8团队一直在努力跟上新的JavaScript语言特性，而V8团队已经不再使用V8版本的全代码和Crankshaft（自2010年以来服务于V8的技术）。这些功能需要进行优化。</p><p>这意味着整体V8将有更简单和更可维护的架构。</p><p><img src="https://image-static.segmentfault.com/295/050/2950506090-5ae2d1c0cf39e_articlex" alt="v8_benchmarks" title="v8_benchmarks"></p><p>这些改进仅仅是一个开始。 新的Ignition和TurboFan管道为进一步优化铺平了道路，这将在未来几年提升JavaScript性能并缩小V8在Chrome和Node.js中的占用空间。</p><p>最后，这里有一些关于如何编写优化的，更好的JavaScript的技巧和窍门。 您可以轻松地从上述内容中获取这些内容，但是，为了方便起见，以下是摘要：</p><h3 id="如何编写优化的JavaScript"><a href="#如何编写优化的JavaScript" class="headerlink" title="如何编写优化的JavaScript"></a>如何编写优化的JavaScript</h3><ul><li>对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。</li><li>动态属性：在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。</li><li>方法：重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。</li><li>数组：避免稀疏数组，其中的键不是增量数字。稀疏数组中没有每个元素都是哈希表。这种阵列中的元素访问费用较高。另外，尽量避免预分配大型数组。随着你的成长，成长会更好。最后，不要删除数组中的元素。它使密钥稀疏。</li><li>标记值：V8用32位来表示对象和数字。由于它的31位，它使用1个bit来知道它是一个对象（flag = 1）还是一个称为SMI（SMall Integer）的整数（flag = 0）。然后，如果数字值大于31位，V8会将该数字框起来，将其变成双精度值并创建一个新对象以将该数字放入其中。尝试尽可能使用31位有符号数字以避免将昂贵的装箱操作转换为JS对象。</li></ul><p><strong>此文摘自<a href="https://segmentfault.com/a/1190000014593649" target="_blank" rel="noopener">《JavaScript工作原理（二）：V8引擎和5招优化》</a></strong></p><p><strong>作者：<a href="https://segmentfault.com/u/xupea" target="_blank" rel="noopener">xupea</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;JavaScript引擎是执行JavaScript代码的程序或解释器。JavaScript引擎可以作为标准解释器或即时编译器来实现，该编译器以某种形式将JavaScript编译为字节码。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://yfzhou.coding.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://yfzhou.coding.me/tags/js/"/>
    
      <category term="V8" scheme="https://yfzhou.coding.me/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>SQL执行效率总结</title>
    <link href="https://yfzhou.coding.me/2018/08/22/SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E6%80%BB%E7%BB%93/"/>
    <id>https://yfzhou.coding.me/2018/08/22/SQL执行效率总结/</id>
    <published>2018-08-22T03:14:58.000Z</published>
    <updated>2018-08-22T03:48:56.506Z</updated>
    
    <content type="html"><![CDATA[<p>SQL执行效率总结</p><a id="more"></a><p>1.关于SQL查询效率，100w数据，查询只要1秒，与您分享:</p><p>机器情况 p4: 2.4 内存: 1 G os: windows 2003 数据库: ms sql server 2000 目的: 查询性能测试,比较两种查询的性能</p><p>SQL查询效率 step by step</p><p>-- setp 1. – 建表 <code>create table t_userinfo ( userid int identity(1,1) primary key nonclustered, nick varchar(50) not null default &#39;&#39;, classid int not null default 0, writetime datetime not null default getdate() ) go</code></p><p>-- 建索引 <code>create clustered index ix_userinfo_classid on t_userinfo(classid) go</code></p><p>-- step 2.<br><code>declare @i int declare @k int declare @nick varchar(10) set @i = 1 while @i&lt;1000000 begin set @k = @i % 10 set @nick = convert(varchar,@i) insert into t_userinfo(nick,classid,writetime) values(@nick,@k,getdate()) set @i = @i + 1 end</code> </p><p>-- 耗时 08:27 ，需要耐心等待</p><p>-- step 3. <code>select top 20 userid,nick,classid,writetime from t_userinfo where userid not in ( select top 900000 userid from t_userinfoorder by userid asc )</code></p><p>-- 耗时 8 秒 ,够长的</p><p>-- step 4. <code>select a.userid,b.nick,b.classid,b.writetime from ( select top 20 a.userid from ( select top 900020 userid from t_userinfo order by userid asc ) a order by a.userid desc ) a inner join t_userinfo b on a.userid = b.userid order by a.userid asc</code></p><p>-- 耗时 1 秒，太快了吧，不可以思议</p><p>-- step 5 where 查询 <code>select top 20 userid,nick,classid,writetime from t_userinfo where classid = 1 and userid not in ( select top 90000 userid from t_userinfo where classid = 1 order by userid asc )</code> – 耗时 2 秒</p><p>-- step 6 where 查询 <code>select a.userid,b.nick,b.classid,b.writetime from ( select top 20 a.userid from ( select top 90000 userid from t_userinfo where classid = 1 order by userid asc ) a order by a.userid desc ) a inner join t_userinfo b on a.userid = b.userid order by a.userid asc</code></p><p>-- 查询分析器显示不到 1 秒.</p><p>查询效率分析： 子查询为确保消除重复值，必须为外部查询的每个结果都处理嵌套查询。在这种情况下可以考虑用联接查询来取代。 如果要用子查询，那就用EXISTS替代IN、用NOT EXISTS替代NOT IN。因为EXISTS引入的子查询只是测试是否存在符合子查询中指定条件的行，效率较高。无论在哪种情况下,NOT IN都是最低效的。因为它对子查询中的表执行了一个全表遍历。</p><p>建立合理的索引,避免扫描多余数据，避免表扫描！ 几百万条数据，照样几十毫秒完成查询,对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： <code>select id from t where num is null</code> 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： <code>select id from t where num=0</code></p><p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： <code>select id from t where num=10 or num=20</code> 可以这样查询： <code>select id from t where num=10 union all select id from t where num=20</code></p><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如： <code>select id from t where num in(1,2,3)</code> 对于连续的数值，能用 between 就不要用 in 了： <code>select id from t where num between 1 and 3</code></p><p>6.下面的查询也将导致全表扫描： <code>select id from t where name like &#39;%c%&#39;</code> 若要提高效率，可以考虑全文检索。</p><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： <code>select id from t where[num=@num](mailto:num=@num)</code> 可以改为强制查询使用索引： <code>select id from t with(index(索引名)) where[num=@num](mailto:num=@num)</code></p><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： <code>select id from t where num/2=100</code> 应改为: <code>select id from t where num=100*2</code></p><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： <code>select id from t where substring(name,1,3)=&#39;abc&#39;--name以abc开头的id select id from t where datediff(day,createdate,&#39;2005-11-30&#39;)=0--‘2005-11-30’</code>生成的id 应改为: <code>select id from t where name like &#39;abc%&#39; select id from t where createdate&gt;=&#39;2005-11-30&#39; and createdate&lt;&#39;2005-12-1&#39;</code></p><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12.不要写一些没有意义的查询，如需要生成一个空表结构： <code>select col1,col2 into #t from t where 1=0</code> 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<code>create table #t(...)</code></p><p>13.很多时候用 exists 代替 in 是一个好的选择： <code>select num from a where num in(select num from b)</code> 用下面的语句替换： <code>select num from a where exists(select 1 from b where num=a.num)</code></p><p>14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p><p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19.任何地方都不要使用 <code>select * from t</code> ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>29.尽量避免大事务操作，提高系统并发能力。</p><p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理 </p><blockquote><p>1、避免将字段设为“允许为空”<br>2、数据表设计要规范<br>3、深入分析数据操作所要对数据库进行的操作<br>4、尽量不要使用临时表<br>5、多多使用事务<br>6、尽量不要使用游标<br>7、避免死锁<br>8、要注意读写锁的使用<br>9、不要打开大的数据集<br>10、不要使用服务器端游标<br>11、在程序编码时使用大数据量的数据库<br>12、不要给“性别”列创建索引<br>13、注意超时问题<br>14、不要使用Select *<br>15、在细节表中插入纪录时，不要在主表执行Select MAX(ID)<br>16、尽量不要使用TEXT数据类型<br>17、使用参数查询<br>18、不要使用Insert导入大批的数据<br>19、学会分析查询<br>20、使用参照完整性<br>21、用INNER JOIN 和LEFT JOIN代替Where </p></blockquote><h3 id="提高SQL查询效率（要点与技巧）："><a href="#提高SQL查询效率（要点与技巧）：" class="headerlink" title="提高SQL查询效率（要点与技巧）："></a>提高SQL查询效率（要点与技巧）：</h3><h4 id="技巧一"><a href="#技巧一" class="headerlink" title="技巧一"></a>技巧一</h4><p>问题类型：ACCESS数据库字段中含有日文片假名或其它不明字符时查询会提示内存溢出。 解决方法：修改查询语句 <code>sql=&quot;select * from tablename where column like &#39;%&quot;&amp;word&amp;&quot;%&#39;&quot; 改为 sql=&quot;select * from tablename&quot; rs.filter = &quot; column like &#39;%&quot;&amp;word&amp;&quot;%&#39;&quot;</code> </p><h4 id="技巧二"><a href="#技巧二" class="headerlink" title="技巧二"></a>技巧二</h4><p>问题类型：如何用简易的办法实现类似百度的多关键词查询（多关键词用空格或其它符号间隔）。 解决方法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//用空格分割查询字符串 </span><br><span class="line">ck=split(word," ")</span><br><span class="line">//得到分割后的数量 </span><br><span class="line">sck=UBound(ck) </span><br><span class="line">sql="<span class="keyword">select</span> * tablename <span class="keyword">where</span><span class="string">" 在一个字段中查询 For i = 0 To sck SQL = SQL &amp; tempJoinWord &amp; "</span>(<span class="string">" &amp; _ "</span><span class="keyword">column</span> <span class="keyword">like</span> <span class="string">'"&amp;ck(i)&amp;"%'</span>)<span class="string">" tempJoinWord = "</span> <span class="keyword">and</span> <span class="string">" Next 在二个字段中同时查询 For i = 0 To sck SQL = SQL &amp; tempJoinWord &amp; "</span>(<span class="string">" &amp; _ "</span><span class="keyword">column</span> <span class="keyword">like</span> <span class="string">'"&amp;ck(i)&amp;"%'</span> <span class="keyword">or</span> <span class="string">" &amp; _ "</span>column1 <span class="keyword">like</span> <span class="string">'"&amp;ck(i)&amp;"%'</span>)<span class="string">" tempJoinWord = "</span> <span class="keyword">and</span> <span class="string">" Next</span></span><br></pre></td></tr></table></figure></p><h4 id="技巧三"><a href="#技巧三" class="headerlink" title="技巧三"></a>技巧三</h4><p>大大提高查询效率的几种技巧</p><ol><li>尽量不要使用 or，使用or会引起全表扫描，将大大降低查询效率。  </li><li>经过实践验证，charindex()并不比前面加%的like更能提高查询效率，并且charindex()会使索引失去作用（指sqlserver数据库）  </li><li>column like ‘%”&amp;word&amp;”%’ 会使索引不起作用<br>column like ‘“&amp;word&amp;”%’ 会使索引起作用（去掉前面的%符号）<br>（指sqlserver数据库）  </li><li>‘%”&amp;word&amp;”%’ 与’”&amp;word&amp;”%’ 在查询时的区别：<br>比如你的字段内容为 一个容易受伤的女人<br>‘%”&amp;word&amp;”%’ ：会通配所有字符串，不论查“受伤”还是查“一个”，都会显示结果。<br>‘“&amp;word&amp;”%’ ：只通配前面的字符串，例如查“受伤”是没有结果的，只有查“一个”，才会显示结果。  </li><li>字段提取要按照“需多少、提多少”的原则，避免“select *”，尽量使用“select 字段1,字段2,字段3……..”。实践证明：每少提取一个字段，数据的提取速度就会有相应的提升。提升的速度还要看您舍弃的字段的大小来判断。  </li><li>order by按聚集索引列排序效率最高。一个sqlserver数据表只能建立一个聚集索引，一般默认为ID，也可以改为其它的字段。  </li><li>为你的表建立适当的索引，建立索引可以使你的查询速度提高几十几百倍。（指sqlserver数据库）  </li></ol><h3 id="以下是建立索引与不建立索引的一个查询效率分析："><a href="#以下是建立索引与不建立索引的一个查询效率分析：" class="headerlink" title="以下是建立索引与不建立索引的一个查询效率分析："></a>以下是建立索引与不建立索引的一个查询效率分析：</h3><p>Sqlserver索引与查询效率分析。<br>表 News<br>字段<br>Id：自动编号<br>Title：文章标题<br>Author：作者<br>Content：内容<br>Star：优先级<br>Addtime：时间<br>记录：100万条<br>测试机器：P4 2.8/1G内存/IDE硬盘  </p><h4 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h4><p>主键Id，默认为聚集索引，不建立其它非聚集索引<br><code>select * from News where Title like &#39;%&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;%&quot;&amp;word&amp;&quot;%&#39; order by Id desc</code><br>从字段Title和Author中模糊检索，按Id排序<br>查询时间：50秒  </p><h4 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39; order by Id desc</code><br>从字段Title和Author中模糊检索，按Id排序<br>查询时间：2 - 2.5秒 </p><h4 id="方案3："><a href="#方案3：" class="headerlink" title="方案3："></a>方案3：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39; order by Star desc</code><br>从字段Title和Author中模糊检索，按Star排序<br>查询时间：2 秒  </p><h4 id="方案4："><a href="#方案4：" class="headerlink" title="方案4："></a>方案4：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39; or Author like &#39;&quot;&amp;word&amp;&quot;%&#39;</code><br>从字段Title和Author中模糊检索，不排序<br>查询时间：1.8 - 2 秒  </p><h4 id="方案5："><a href="#方案5：" class="headerlink" title="方案5："></a>方案5：</h4><p>主键Id，默认为聚集索引<br>在Title、Author、Star上建立非聚集索引<br><code>select * from News where Title like &#39;&quot;&amp;word&amp;&quot;%&#39;</code><br>或<br><code>select * from News where Author like &#39;&quot;&amp;word&amp;&quot;%&#39;</code><br>从字段Title 或 Author中检索，不排序<br>查询时间：1秒  </p><h3 id="如何提高SQL语言的查询效率"><a href="#如何提高SQL语言的查询效率" class="headerlink" title="如何提高SQL语言的查询效率?"></a>如何提高SQL语言的查询效率?</h3><p>问：请问我如何才能提高SQL语言的查询效率呢？<br>答：这得从头说起：<br>由于SQL是面向结果而不是面向过程的查询语言，所以一般支持SQL语言的大型关系型数据库都使用一个基于查询成本的优化器，为即时查询提供一个最佳的执行策略。对于优化器，输入是一条查询语句，输出是一个执行策略。<br>一条SQL查询语句可以有多种执行策略，优化器将估计出全部执行方法中所需时间最少的所谓成本最低的那一种方法。所有优化都是基于用记所使用的查询语句中的where子句，优化器对where子句中的优化主要用搜索参数(Serach Argument)。<br>搜索参数的核心思想就是数据库使用表中字段的索引来查询数据，而不必直接查询记录中的数据。<br>带有 =、&lt;、&lt;=、&gt;、&gt;= 等操作符的条件语句可以直接使用索引，如下列是搜索参数：<br>emp_id = “10001” 或 salary &gt; 3000 或 a =1 and c = 7<br>而下列则不是搜索参数：<br>salary = emp_salary 或 dep_id != 10 或 salary * 12 &gt;= 3000 或 a=1 or c=7<br>应当尽可能提供一些冗余的搜索参数，使优化器有更多的选择余地。请看以下3种方法：  </p><h4 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select employee.emp_name,department.dep_name <span class="keyword">from</span> department,employee </span><br><span class="line">where (employee.dep_id = department.dep_id) </span><br><span class="line"><span class="keyword">and</span> (department.<span class="attribute">dep_code</span>=<span class="string">"01"</span>) </span><br><span class="line"><span class="keyword">and</span> (employee.<span class="attribute">dep_code</span>=<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure><p>它的搜索分析结果如下：<br>Estimate 2 I/O operations<br>Scan department using primary key<br>for rows where dep_code equals “01”<br>Estimate getting here 1 times<br>Scan employee sequentially<br>Estimate getting here 5 times  </p><h4 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select employee.emp_name,department.dep_name <span class="keyword">from</span> department,employee</span><br><span class="line">where (employee.<span class="attribute">dep_id</span>=department.dep_id) </span><br><span class="line"><span class="keyword">and</span> (department.<span class="attribute">dep_code</span>=<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure><p>它的搜索分析结果如下：<br>Estimate 2 I/O operations<br>Scan department using primary key<br>for rows where dep_code equals “01”<br>Estimate getting here 1 times<br>Scan employee sequentially<br>Estimate getting here 5 times  </p><p>第一种方法与第二种运行效率相同，但第一种方法最好，因为它为优化器提供了更多的选择机会。</p><h4 id="第三种方法："><a href="#第三种方法：" class="headerlink" title="第三种方法："></a>第三种方法：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee.emp_name,department.dep_name <span class="keyword">from</span> department,employee </span><br><span class="line"><span class="keyword">where</span> (employee.dep_id = department.dep_id) </span><br><span class="line"><span class="keyword">and</span> (employee.dep_code=<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure><p>这种方法最不好，因为它无法使用索引，也就是无法优化……</p><p>使用SQL语句时应注意以下几点：<br>1、避免使用不兼容的数据类型。例如，Float和Integer，Char和Varchar，Binary和Long Binary不兼容的。数据类型的不兼容可能使优化器无法执行一些本可以进行的优化操作。例如：<br>select emp_name form employee where salary &gt; 3000;<br>在此语句中若salary是Float类型的，则优化器很难对其进行优化，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。<br>2、尽量不要使用表达式，因它在编绎时是无法得到的，所以SQL只能使用其平均密度来估计将要命中的记录数。<br>3、避免对搜索参数使用其他的数学操作符。如：<br><code>select emp_name from employee where salary * 12 &gt; 3000;`</code><br>应改为：<br><code>select emp_name from employee where salary &gt; 250;</code></p><p>4、避免使用 != 或 &lt;&gt; 等这样的操作符，因为它会使系统无法使用索引，而只能直接搜索表中的数据。  </p><h3 id="ORACAL中的应用"><a href="#ORACAL中的应用" class="headerlink" title="ORACAL中的应用"></a>ORACAL中的应用</h3><p>一个1600万数据表－－短信上行表TBL_SMS_MO<br>结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TBL_SMS_MO  </span><br><span class="line">(  </span><br><span class="line">SMS_ID <span class="built_in">NUMBER</span>,  </span><br><span class="line">MO_ID VARCHAR2(<span class="number">50</span>),  </span><br><span class="line">MOBILE VARCHAR2(<span class="number">11</span>),  </span><br><span class="line">SPNUMBER VARCHAR2(<span class="number">20</span>),  </span><br><span class="line">MESSAGE VARCHAR2(<span class="number">150</span>),  </span><br><span class="line">TRADE_CODE VARCHAR2(<span class="number">20</span>),  </span><br><span class="line">LINK_ID VARCHAR2(<span class="number">50</span>),  </span><br><span class="line">GATEWAY_ID <span class="built_in">NUMBER</span>,  </span><br><span class="line">GATEWAY_PORT <span class="built_in">NUMBER</span>,  </span><br><span class="line">MO_TIME <span class="built_in">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">SYSDATE</span>  </span><br><span class="line">);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_MO_DATE <span class="keyword">ON</span> TBL_SMS_MO (MO_TIME)  </span><br><span class="line">PCTFREE <span class="number">10</span>  </span><br><span class="line"><span class="keyword">INITRANS</span> <span class="number">2</span>  </span><br><span class="line"><span class="keyword">MAXTRANS</span> <span class="number">255</span>  </span><br><span class="line"><span class="keyword">STORAGE</span>  </span><br><span class="line">(  </span><br><span class="line"><span class="keyword">INITIAL</span> <span class="number">1</span>M  </span><br><span class="line"><span class="keyword">NEXT</span> <span class="number">1</span>M  </span><br><span class="line"><span class="keyword">MINEXTENTS</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span>  </span><br><span class="line"><span class="keyword">PCTINCREASE</span> <span class="number">0</span>  </span><br><span class="line">);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_MO_MOBILE <span class="keyword">ON</span> TBL_SMS_MO (MOBILE)  </span><br><span class="line">PCTFREE <span class="number">10</span>  </span><br><span class="line"><span class="keyword">INITRANS</span> <span class="number">2</span>  </span><br><span class="line"><span class="keyword">MAXTRANS</span> <span class="number">255</span>  </span><br><span class="line"><span class="keyword">STORAGE</span>  </span><br><span class="line">(  </span><br><span class="line"><span class="keyword">INITIAL</span> <span class="number">64</span>K  </span><br><span class="line"><span class="keyword">NEXT</span> <span class="number">1</span>M  </span><br><span class="line"><span class="keyword">MINEXTENTS</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span>  </span><br><span class="line"><span class="keyword">PCTINCREASE</span> <span class="number">0</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>　　问题：从表中查询某时间段内某手机发送的短消息，如下SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOBILE,MESSAGE,TRADE_CODE,MO_TIME  </span><br><span class="line"><span class="keyword">FROM</span> TBL_SMS_MO  </span><br><span class="line"><span class="keyword">WHERE</span> MOBILE=<span class="string">'130XXXXXXXX'</span>  </span><br><span class="line"><span class="keyword">AND</span> MO_TIME <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-01'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>) <span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-07'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>)  </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> MO_TIME <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></p><p>返回结果大约需要10分钟，应用于网页查询，简直难以忍受。<br>分析：<br>在PL/SQL Developer，点击“Explain Plan”按钮（或F5键），对SQL进行分析，发现缺省使用的索引是IDX_MO_DATE。问题可能出在这里，因为相对于总数量1600万数据来说， 都mobile的数据是很少的，如果使用ID_MO_MOBILE比较容易锁定数据。<br>如下优化：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOBILE,MESSAGE,TRADE_CODE,MO_TIME  </span><br><span class="line"><span class="keyword">FROM</span> TBL_SMS_MO  </span><br><span class="line"><span class="keyword">WHERE</span> MOBILE=<span class="string">'130XXXXXXXX'</span>  </span><br><span class="line"><span class="keyword">AND</span> MO_TIME <span class="keyword">BETWEEN</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-01'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>) <span class="keyword">AND</span> <span class="keyword">TO_DATE</span>(<span class="string">'2006-04-07'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>)  </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> MO_TIME <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></p><p>测试：<br>按F8运行这个SQL，哇～… … 2.360s，这就是差别。<br>用索引提高SQL Server性能<br>特别说明<br>　　在微软的SQL Server系统中通过有效的使用索引可以提高数据库的查询性能，但是性能的提高取决于数据库的实现。在本文中将会告诉你如何实现索引并有效的提高数据库的性能。　  </p><p>　 　在关系型数据库中使用索引能够提高数据库性能，这一点是非常明显的。用的索引越多，从数据库系统中得到数据的速度就越快。然而，需要注意的是，用的索引 越多，向数据库系统中插入新数据所花费的时间就越多。在本文中，你将了解到微软的SQL Server数据库所支持的各种不同类型的索引，在这里你将了解到如何使用不同的方法来实现索引，通过这些不同的实现方法，你在数据库的读性能方面得到的 远比在数据库的整体性能方面的损失要多得多。  </p><p>　　索引的定义<br>　　索引是数据库的工具，通过使用索引，在数据库中获取数据的时 候，就可以不用扫描数据库中的所有数据记录，这样能够提高系统获取数据的性能。使用索引可以改变数据的组织方式，使得所有的数据都是按照相似的结构来组织 的，这样就可以很容易地实现数据的检索访问。索引是按照列来创建的，这样就可以根据索引列中的值来帮助数据库找到相应的数据。  </p><p>　　索引的类型<br>　 　微软的SQL Server 支持两种类型的索引：clustered 索引和nonclustered索引。Clustered 索引在数据表中按照物理顺序存储数据。因为在表中只有一个物理顺序，所以在每个表中只能有一个clustered索引。在查找某个范围内的数据 时，Clustered索引是一种非常有效的索引，因为这些数据在存储的时候已经按照物理顺序排好序了。  </p><p>　　 Nonclustered索引不会影响到下面的物理存储，但是它是由数据行指针构成的。如果已经存在一个clustered索引，在 nonclustered中的索引指针将包含clustered索引的位置参考。这些索引比数据更紧促，而且对这些索引的扫描速度比对实际的数据表扫描要 快得多。  </p><p>　　如何实现索引<br>　　数据库可以自动创建某些索引。例如，微软的SQL Server系统通过自动创建唯一索引来强制实现UNIQUE约束，这样可以确保在数据库中不会插入重复数据。也可以使用CREATE INDEX语句或者通过SQL Server Enterprise Manager来创建其他索引，SQL Server Enterprise Manager还有一个索引创建模板来指导你如何创建索引。  </p><p>　　得到更好的性能<br>　　虽然索引可以带来性能上的优势，但是同时 也将带来一定的代价。虽然SQL Server系统允许你在每个数据表中创建多达256个nonclustered索引，但是建议不要使用这么多的索引。因为索引需要在内存和物理磁盘驱动 器上使用更多的存储空间。在执行插入声明的过程中可能会在一定程度上导致系统性能的下降，因为在插入数据的时候是需要根据索引的顺序插入，而不是在第一个 可用的位置直接插入数据，这样一来，存在的索引越多将导致插入或者更新声明所需要的时间就越多。  </p><p>　　在使用SQL Server系统创建索引的时候，建议参照下面的创建准则来实现：  </p><p>　　正确的选择数据类型<br>　 　在索引中使用某些数据类型可以提高数据库系统的效率，例如，Int，bigint， smallint，和tinyint等这些数据类型都非常适合于用在索引中，因为他们都占用相同大小的空间并且可以很容易地实现比较操作。其他的数据类型 如char和varchar的效率都非常低，因为这些数据类型都不适合于执行数学操作，并且执行比较操作的时间都比上面提到数据类型要长。  </p><p>　　确保在使用的过程中正确的利用索引值<br>　 　在执行查询操作时，可能所使用的列只是clustered的一部分，这时尤其要注意的是如何使用这些数据。当用这些数据列作为参数调用函数时，这些函数 可能会使现有的排序优势失效。例如，使用日期值作为索引，而为了实现比较操作，可能需要将这个日期值转换为字符串，这样将导致在查询过程中无法用到这个日 期索引值。  </p><p>　　在创建多列索引时，需要注意列的顺序<br>　　数据库将根据第一列索引的值来排列记录，然后进一步根据第二列的值来排序，依次排序直到最后一个索引排序完毕。哪一列唯一数据值较少，哪一列就应该为第一个索引，这样可以确保数据可以通过索引进一步交叉排序。  </p><p>　　在clustered索引中限制列的数量<br>　　在clustered索引中用到的列越多，在nonclustered索引中包含的clustered索引参考位置就越多，需要存储的数据也就越多。这样将增加包含索引的数据表的大小，并且将增加基于索引的搜索时间。  </p><p>　　避免频繁更新clustered索引数据列<br>　 　由于nonclustered 索引依赖于clustered 索引，所以如果构成clustered 索引的数据列频繁更新，将导致在nonclustered中存储的行定位器也将随之频繁更新。对于所有与这些列相关的查询来说，如果发生记录被锁定的情况 时，这将可能导致性能成本的增加。  </p><p>　　分开操作（如果可能的话）<br>　　对于一个表来说，如果需要进行频繁的执行插入、更新操作，同时还有大量读操作的话，在可能的情况下尝试将这个表分开操作。所有的插入和更新操作可以在一个没有索引的表中操作，然后将其复制到另外一个表中，在这个表里有大量的索引可以优化读数据的能力。  </p><p>　　适当的重建索引<br>　 　Nonclustered索引包含clustered索引的指针，这样一来Nonclustered索引将从属于clustered 索引。当重建clustered索引时，首先是丢弃原来的索引，然后再使用CREATE INDEX 来创建索引，或者在使用CREATE INDEX 声明的同时将DROP_EXISTING 子句作为重建索引的一部分。将丢弃和创建分为几步将会导致多次重建nonclustered 索引，而不象使用DROP_EXISTING 子句那样，只重建一次nonclustered 索引。  </p><p>　　明智的使用填充因子<br>　 　数据存储在那些具有固定大小的连续内存页面内。随着新的记录行的加入，数据内存页将逐渐被填满，系统就必须执行数据页的拆分工作，通过这个拆分工作将部 分数据转移到下一个新的页面当中。这样的拆分之后，将加重系统的负担，并且会导致存储的数据支离破碎。填充因子可以维护数据之间的缺口，一般在创建索引的 时候，该索引的填充因子就已经被设置好了。这样一来，可以减少插入数据所引起的页面分裂的次数。因为只是在创建索引的时候才维护空间的大小，在增加数据或 者更新数据时不会去维护空间的大小。因此，要想能够充分的利用填充因子，就必须周期性的重建索引。由填充因子所造成的缺口将导致读性能的下降，因为随着数 据库的扩张，越来越多的磁盘存取工作需要读取数据。所以，在读的次数超过写的次数的时候，很重要的一点是考虑使用填充因子还是使用缺省方式合适。  </p><p>　　管理层的决策<br>　 　通过有效的使用索引，可以在微软的SQL Server系统中实现很好的查询功能，但是使用索引的效率取决于几种不同的实现决策。在索引的性能平衡方面，要做出正确的数据库管理决策意味着需要在良 好的性能和困境中抉择。在特定的情况下，本文给出的一些建议将有助于你做出正确的决策</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL执行效率总结&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yfzhou.coding.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://yfzhou.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="https://yfzhou.coding.me/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 分组统计，按照天、月份周和自然周、月、季度和年</title>
    <link href="https://yfzhou.coding.me/2018/08/21/Oracle-%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1%EF%BC%8C%E6%8C%89%E7%85%A7%E5%A4%A9%E3%80%81%E6%9C%88%E4%BB%BD%E5%91%A8%E5%92%8C%E8%87%AA%E7%84%B6%E5%91%A8%E3%80%81%E6%9C%88%E3%80%81%E5%AD%A3%E5%BA%A6%E5%92%8C%E5%B9%B4/"/>
    <id>https://yfzhou.coding.me/2018/08/21/Oracle-分组统计，按照天、月份周和自然周、月、季度和年/</id>
    <published>2018-08-21T10:11:20.000Z</published>
    <updated>2018-08-21T11:11:58.004Z</updated>
    
    <content type="html"><![CDATA[<p>做报表统计时会经常用到 周，月，季度，年进行分组统计，所以结合网络搜索推荐的sql，总结如下</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按天统计</span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED+<span class="number">15</span>/<span class="number">24</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="keyword">as</span> 天,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED+<span class="number">15</span>/<span class="number">24</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">--trunc(t.CREATED, 'DD')</span></span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822152940276.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按自然周的日期统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(next_day(t.CREATED+<span class="number">15</span>/<span class="number">24</span> - <span class="number">7</span>,<span class="number">2</span>),<span class="string">'YYYY-MM-DD'</span>) <span class="keyword">AS</span> 周,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(next_day(t.CREATED+<span class="number">15</span>/<span class="number">24</span> - <span class="number">7</span>,<span class="number">2</span>),<span class="string">'YYYY-MM-DD'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 周;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153822139.jpg" alt="">  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按自然周统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'iw'</span>) <span class="keyword">AS</span> 周,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED,<span class="string">'iw'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 周;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153043617.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按自然月统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'YYYY-MM'</span>) <span class="keyword">as</span> 月份,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">to_char(t.CREATED,<span class="string">'YYYY-MM'</span>) <span class="comment">-- to_char(t.CREATED+15/24,'yyyy-mm') 不大准确</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 月份;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153206494.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按季统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'q'</span>) 季度,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED,<span class="string">'q'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 季度 <span class="keyword">NULLS</span>  <span class="keyword">LAST</span>;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153233106.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--按年统计 </span></span><br><span class="line"><span class="keyword">select</span> to_char(t.CREATED,<span class="string">'yyyy'</span>) <span class="keyword">AS</span> 年度,<span class="keyword">sum</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量</span><br><span class="line"><span class="keyword">from</span> TB_EXT_TRADE t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.TID <span class="keyword">LIKE</span> <span class="string">'SC%'</span> <span class="keyword">OR</span> t.TID <span class="keyword">LIKE</span> <span class="string">'WSC%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> to_char(t.CREATED,<span class="string">'yyyy'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年度;</span><br></pre></td></tr></table></figure><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/20160822153258464.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做报表统计时会经常用到 周，月，季度，年进行分组统计，所以结合网络搜索推荐的sql，总结如下&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yfzhou.coding.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://yfzhou.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="https://yfzhou.coding.me/tags/SQL/"/>
    
      <category term="Oracle" scheme="https://yfzhou.coding.me/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Spring任务调度之Quartz</title>
    <link href="https://yfzhou.coding.me/2018/08/21/Spring%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B9%8BQuartz/"/>
    <id>https://yfzhou.coding.me/2018/08/21/Spring任务调度之Quartz/</id>
    <published>2018-08-21T00:47:21.000Z</published>
    <updated>2018-08-21T12:25:06.960Z</updated>
    
    <content type="html"><![CDATA[<p><code>Quartz</code>是<code>OpenSymphony</code>开源组织在<code>Job scheduling</code>领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。<br><code>Quartz</code>用一个小Java库发布文件（.jar文件），这个库文件包含了所有Quartz核心功能。这些功能的主要接口(API)是<code>Scheduler</code>接口。它提供了简单的操作，例如：将任务纳入日程或者从日程中取消，开始/停止/暂停日程进度。 </p><hr><a id="more"></a><h4 id="一、Quartz作业类的继承方式来讲，可以分为两类："><a href="#一、Quartz作业类的继承方式来讲，可以分为两类：" class="headerlink" title="一、Quartz作业类的继承方式来讲，可以分为两类："></a>一、Quartz作业类的继承方式来讲，可以分为两类：</h4><ol><li>作业类需要继承自特定的作业类基类，如Quartz中需要继承自<code>org.springframework.scheduling.quartz.QuartzJobBean</code>；<code>java.util.Time</code>r中需要继承自<code>java.util.TimerTask</code>。</li><li>作业类即普通的java类，不需要继承自任何基类。</li></ol><p>注:推荐使用第二种方式，因为这样所以的类都是普通类，不需要事先区别对待。</p><ul><li><h5 id="从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种："><a href="#从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种：" class="headerlink" title="从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种："></a>从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种：</h5></li></ul><ol><li>每隔指定时间则触发一次，在<code>Quartz</code>中对应的触发器为：<code>org.springframework.scheduling.quartz.SimpleTriggerBean</code></li><li>每到指定时间则触发一次，在<code>Quartz</code>中对应的调度器为：<code>org.springframework.scheduling.quartz.CronTriggerBean</code></li></ol><p>注：并非每种任务都可以使用这两种触发器，如<code>java.util.TimerTask</code>任务就只能使用第一种。<code>Quartz</code>和<code>spring tas</code>k都可以支持这两种触发条件。</p><hr><h4 id="第一种，作业类继承自特定的基类：org-springframework-scheduling-quartz-QuartzJobBean"><a href="#第一种，作业类继承自特定的基类：org-springframework-scheduling-quartz-QuartzJobBean" class="headerlink" title="第一种，作业类继承自特定的基类：org.springframework.scheduling.quartz.QuartzJobBean"></a>第一种，作业类继承自特定的基类：org.springframework.scheduling.quartz.QuartzJobBean</h4><h5 id="第一步：定义作业类"><a href="#第一步：定义作业类" class="headerlink" title="第一步：定义作业类"></a>第一步：定义作业类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;  </span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.QuartzJobBean;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job1</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> timeout;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">  <span class="comment">//调度工厂实例化后，经过timeout时间开始执行调度  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">this</span>.timeout = timeout;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 要调度的具体任务 </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span>  </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JobExecutionException </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"定时任务执行中…"</span>);  </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二步：spring配置文件中配置作业类JobDetailBean"><a href="#第二步：spring配置文件中配置作业类JobDetailBean" class="headerlink" title="第二步：spring配置文件中配置作业类JobDetailBean"></a>第二步：spring配置文件中配置作业类JobDetailBean</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"job1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.JobDetailBean"</span>&gt;  </span><br><span class="line">&lt;property name=<span class="string">"jobClass"</span> value=<span class="string">"com.gy.Job1"</span> /&gt;  </span><br><span class="line">&lt;property name=<span class="string">"jobDataAsMap"</span>&gt;  </span><br><span class="line">  &lt;map&gt;  </span><br><span class="line">    &lt;entry key=<span class="string">"timeout"</span> value=<span class="string">"0"</span> /&gt;  </span><br><span class="line">  &lt;<span class="regexp">/map&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>property&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：org.springframework.scheduling.quartz.JobDetailBean有两个属性，jobClass属性即我们在java代码中定义的任务类，jobDataAsMap属性即该任务类中需要注入的属性值。</p></blockquote><h5 id="第三步：配置作业调度的触发方式（触发器）"><a href="#第三步：配置作业调度的触发方式（触发器）" class="headerlink" title="第三步：配置作业调度的触发方式（触发器）"></a>第三步：配置作业调度的触发方式（触发器）</h5><p>   Quartz的作业触发器有两种，分别是</p><p>   <code>org.springframework.scheduling.quartz.SimpleTriggerBean</code></p><p>   <code>org.springframework.scheduling.quartz.CronTriggerBean</code></p><h6 id="第一种-SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："><a href="#第一种-SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：" class="headerlink" title="第一种 SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："></a>第一种 SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SimpleTriggerBean"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span> <span class="attr">ref</span>=<span class="string">"job1"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startDelay"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span><span class="comment">&lt;!--调度工厂实例化后，经过0秒开始执行调度 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"repeatInterval"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span><span class="comment">&lt;!--每2秒调度一次 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="第二种-CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下："><a href="#第二种-CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下：" class="headerlink" title="第二种 CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下："></a>第二种 CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"cronTrigger"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"jobDetail"</span> ref=<span class="string">"job1"</span> /&gt;  </span><br><span class="line">  &lt;!--每天<span class="number">12</span>:<span class="number">00</span>运行一次--&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"cronExpression"</span> value=<span class="string">"0 0 12 * * ?"</span> /&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第四步：配置调度工厂"><a href="#第四步：配置调度工厂" class="headerlink" title="第四步：配置调度工厂"></a>第四步：配置调度工厂</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"triggers"</span>&gt;  </span><br><span class="line">    &lt;list&gt;  </span><br><span class="line">      &lt;ref bean=<span class="string">"cronTrigger"</span> /&gt;  </span><br><span class="line">    &lt;<span class="regexp">/list&gt;  </span></span><br><span class="line"><span class="regexp">  &lt;/</span>property&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p><em>说明：该参数指定的就是之前配置的触发器的名字。</em></p><h5 id="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。"><a href="#第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。" class="headerlink" title="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。"></a>第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。</h5><hr><h4 id="第二种，作业类不继承特定基类。"><a href="#第二种，作业类不继承特定基类。" class="headerlink" title="第二种，作业类不继承特定基类。"></a>第二种，作业类不继承特定基类。</h4><p>Spring能够支持这种方式，归功于两个类：</p><p><code>org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean</code></p><p><code>org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean</code></p><p>这两个类分别对应spring支持的两种实现任务调度的方式，即前文提到到java自带的timer task方式和Quartz方式。这里我只写MethodInvokingJobDetailFactoryBean的用法，使用该类的好处是,我们的任务类不再需要继承自任何类，而是普通的pojo。</p><h5 id="第一步：编写任务类"><a href="#第一步：编写任务类" class="headerlink" title="第一步：编写任务类"></a>第一步：编写任务类</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Job2</span> &#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doJob2</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"不继承QuartzJobBean方式-调度进行中…"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：可以看出，这就是一个普通的类，并且有一个方法。</strong></p><h5 id="第二步：配置作业类"><a href="#第二步：配置作业类" class="headerlink" title="第二步：配置作业类"></a>第二步：配置作业类</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"job2"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.gy.Job2"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"doJob2"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"concurrent"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span><span class="comment">&lt;!-- 作业不并发调度 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>说明：这一步是关键步骤，声明一个MethodInvokingJobDetailFactoryBean，有两个关键属性：targetObject指定任务类，targetMethod指定运行的方法。往下的步骤就与方法一相同了，为了完整，同样贴出。</em></p><h5 id="第三步：配置作业调度的触发方式（触发器）-1"><a href="#第三步：配置作业调度的触发方式（触发器）-1" class="headerlink" title="第三步：配置作业调度的触发方式（触发器）"></a>第三步：配置作业调度的触发方式（触发器）</h5><p>   Quartz的作业触发器有两种，分别是</p><p>   <code>org.springframework.scheduling.quartz.SimpleTriggerBean</code></p><p>   <code>org.springframework.scheduling.quartz.CronTriggerBean</code></p><h6 id="第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："><a href="#第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：" class="headerlink" title="第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下："></a>第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。配置方式如下：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SimpleTriggerBean"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span> <span class="attr">ref</span>=<span class="string">"job2"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startDelay"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span><span class="comment">&lt;!-- 调度工厂实例化后，经过0秒开始执行调度 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"repeatInterval"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span><span class="comment">&lt;!-- 每2秒调度一次 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="第二种CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下："><a href="#第二种CronTriggerBean，支持到指定时间运行一次，如每天12-00运行一次等。配置方式如下：" class="headerlink" title="第二种CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下："></a>第二种CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。配置方式如下：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"cronTrigger"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"jobDetail"</span> ref=<span class="string">"job2"</span> /&gt;  </span><br><span class="line">  &lt;!--每天<span class="number">12</span>:<span class="number">00</span>运行一次 --&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"cronExpression"</span> value=<span class="string">"0 0 12 * * ?"</span> /&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p><strong>以上两种调度方式根据实际情况，任选一种即可。</strong></p><h5 id="第四步：配置调度工厂-1"><a href="#第四步：配置调度工厂-1" class="headerlink" title="第四步：配置调度工厂"></a>第四步：配置调度工厂</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;  </span><br><span class="line">  &lt;property name=<span class="string">"triggers"</span>&gt;  </span><br><span class="line">    &lt;list&gt;  </span><br><span class="line">      &lt;ref bean=<span class="string">"cronTrigger"</span> /&gt;  </span><br><span class="line">    &lt;<span class="regexp">/list&gt;  </span></span><br><span class="line"><span class="regexp">  &lt;/</span>property&gt;  </span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure><p><em>说明：该参数指定的就是之前配置的触发器的名字。</em></p><h5 id="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。-1"><a href="#第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。-1" class="headerlink" title="第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。"></a>第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。</h5><p><strong>到此，spring中Quartz的基本配置就介绍完了，当然了，使用之前，要导入相应的spring的包与Quartz的包，这些就不消多说了。</strong></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">《官网》</a><br><a href="http://sishuok.com/forum/posts/list/405.html" target="_blank" rel="noopener">《Quartz任务调度快速入门》</a><br><a href="http://lavasoft.blog.51cto.com/62575/181907/" target="_blank" rel="noopener">《深入解读Quartz的原理》</a><br><a href="https://blog.csdn.net/u010648555/article/category/6601767" target="_blank" rel="noopener">《Quartz学习-阿飞(dufyun)》</a><br><a href="https://www.cnblogs.com/hongwz/p/5642429.html" target="_blank" rel="noopener">《Spring任务调度之Quartz-独具匠心》</a><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/" target="_blank" rel="noopener">《基于Quartz开发企业级任务调度应用》</a><br><a href="http://blog.csdn.net/tengdazhang770960436/article/details/51019291" target="_blank" rel="noopener">《Quartz 数据库表含义解释》</a><br><a href="https://my.oschina.net/chengxiaoyuan/blog/664833" target="_blank" rel="noopener">《Quartz源码分析》</a><br><a href="http://blog.csdn.net/Evankaka/article/category/3155529" target="_blank" rel="noopener">《Quartz系列》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Quartz&lt;/code&gt;是&lt;code&gt;OpenSymphony&lt;/code&gt;开源组织在&lt;code&gt;Job scheduling&lt;/code&gt;领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。&lt;br&gt;&lt;code&gt;Quartz&lt;/code&gt;用一个小Java库发布文件（.jar文件），这个库文件包含了所有Quartz核心功能。这些功能的主要接口(API)是&lt;code&gt;Scheduler&lt;/code&gt;接口。它提供了简单的操作，例如：将任务纳入日程或者从日程中取消，开始/停止/暂停日程进度。 &lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="Spring" scheme="https://yfzhou.coding.me/tags/Spring/"/>
    
      <category term="Quartz" scheme="https://yfzhou.coding.me/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>Spring+Quartz的版本问题</title>
    <link href="https://yfzhou.coding.me/2018/08/21/Spring-Quartz%E7%9A%84%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <id>https://yfzhou.coding.me/2018/08/21/Spring-Quartz的版本问题/</id>
    <published>2018-08-21T00:35:58.000Z</published>
    <updated>2018-08-21T12:25:12.886Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java<span class="selector-class">.lang</span><span class="selector-class">.IncompatibleClassChangeError</span>: class org<span class="selector-class">.springframework</span><span class="selector-class">.scheduling</span><span class="selector-class">.quartz</span><span class="selector-class">.CronTriggerBean</span> has interface org<span class="selector-class">.quartz</span><span class="selector-class">.CronTrigger</span> as superclass</span><br></pre></td></tr></table></figure><a id="more"></a><p>原因是Spring 3.0版本中内置的Quartz版本是&lt;2.0的，在使用最新的Quartz包(&gt;2.0)之后，接口不兼容。</p><p>解决办法有三种：</p><p>1.降低Quartz版本，降到1.X去。</p><p>2.升级Spring版本到3.1+，根据Spring的建议，将原来的<strong>TriggerBean替换成</strong>TriggerFactoryBean，例如CronTriggerBean 就可以替换成 CronTriggerFactoryBean。替换之后问题解决。</p><p>3.如果不在xml配置文件中引用 Spring 3.0 是支持 Quartz2.2.1(目前最新版本)，直接在程序中调用即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: java&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.IncompatibleClassChangeError&lt;/span&gt;: class org&lt;span class=&quot;selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.scheduling&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.quartz&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.CronTriggerBean&lt;/span&gt; has interface org&lt;span class=&quot;selector-class&quot;&gt;.quartz&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.CronTrigger&lt;/span&gt; as superclass&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="Spring" scheme="https://yfzhou.coding.me/tags/Spring/"/>
    
      <category term="Quartz" scheme="https://yfzhou.coding.me/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>Python骚操作：微信远程控制电脑</title>
    <link href="https://yfzhou.coding.me/2018/08/20/Python%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BE%AE%E4%BF%A1%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/"/>
    <id>https://yfzhou.coding.me/2018/08/20/Python骚操作：微信远程控制电脑/</id>
    <published>2018-08-20T04:18:36.000Z</published>
    <updated>2018-08-23T07:17:48.177Z</updated>
    
    <content type="html"><![CDATA[<p>今天带给大家一个非常有意思的 python 程序，基于 itchat 实现微信控制电脑。你可以通过在微信发送命令，来拍摄当前电脑的使用者，然后图片会发送到你的微信上。甚至你可以发送命令来远程关闭电脑。</p><a id="more"></a><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/374660489816441329_%E7%9C%8B%E5%9B%BE%E7%8E%8B.jpg?x-oss-process=style/w200" alt=""></p><p><strong>应用场景</strong></p><p>你可爱又迷人的女朋友，在看到这篇教程之后，非常的开心。在你的电脑上部署了这个脚本，并且在你不知情的情况下，默默的登录上。随后跟你说我出去跟闺蜜逛街啦，今天就不陪你了。要记得不准吃鸡。</p><p>你心想老子终于可以放松一天了！开心的吃鸡！口上说着：“好的！亲爱的玩得开心！”等着女朋友出门以后，你就开启了吃鸡模式，在绝地求生里大开杀戒。</p><p>你的女朋友早已对你了如指掌，通过脚本，先让电脑截图留下现场证据，随后再打电话质问你是否在吃鸡，你如果撒谎就把电脑远程关机。</p><p>最后你想了下不对我没有女朋友啊，随后你转头微笑地看着你的室友。</p><p><strong>程序思路</strong></p><p>此次程序使用的环境是 python3.7 + windows7，在运行程序之前请先确保你已经安装好了 opencv-python 和 matplotlib。通过 pip install 即可安装。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> opencv-python</span><br><span class="line">pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure><p>程序主要是通过使用 itchat 库来登录到微信网页端，然后通过 itchat 来发送消息和接收消息。并通过 opencv 来调用电脑的摄像头，把当前使用电脑的用户拍照下来，发送到你的微信上。至于远程关机是通过调用 os 库，发送 cmd 命名即可实现。</p><p><strong>程序源码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/8/20 11:12</span></span><br><span class="line"><span class="comment"># @Author  : yfzhou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : wechat_control_computer.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># Life is short, I use python.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">sendMsg = <span class="string">u"&#123;消息助手&#125;：暂时无法回复"</span></span><br><span class="line">usageMsg = <span class="string">u"使用方法：\n1.运行CMD命令：cmd xxx (xxx为命令)\n"</span> \</span><br><span class="line">           <span class="string">u"-例如关机命令:\ncmd shutdown -s -t 0 \n"</span> \</span><br><span class="line">           <span class="string">u"2.获取当前电脑用户：cap\n3.启用消息助手(默认关闭)：ast\n"</span> \</span><br><span class="line">           <span class="string">u"4.关闭消息助手：astc"</span></span><br><span class="line">flag = <span class="number">0</span>  <span class="comment"># 消息助手开关</span></span><br><span class="line">nowTime = time.localtime()</span><br><span class="line">filename = str(nowTime.tm_mday) + str(nowTime.tm_hour) + str(nowTime.tm_min) + str(nowTime.tm_sec) + <span class="string">".txt"</span></span><br><span class="line">myfile = open(filename, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register('Text')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    message = msg[<span class="string">'Text'</span>]</span><br><span class="line">    fromName = msg[<span class="string">'FromUserName'</span>]</span><br><span class="line">    toName = msg[<span class="string">'ToUserName'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> toName == <span class="string">"filehelper"</span>:</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">"cap"</span>:</span><br><span class="line">            cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">            ret, img = cap.read()</span><br><span class="line">            cv2.imwrite(<span class="string">"weixinTemp.jpg"</span>, img)</span><br><span class="line">            itchat.send(<span class="string">'@img@%s'</span> % <span class="string">u'weixinTemp.jpg'</span>, <span class="string">'filehelper'</span>)</span><br><span class="line">            cap.release()</span><br><span class="line">        <span class="keyword">if</span> message[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">"cmd"</span>:</span><br><span class="line">            os.system(message.strip(message[<span class="number">0</span>:<span class="number">4</span>]))</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">"ast"</span>:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            itchat.send(<span class="string">"消息助手已开启"</span>, <span class="string">"filehelper"</span>)</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">"astc"</span>:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            itchat.send(<span class="string">"消息助手已关闭"</span>, <span class="string">"filehelper"</span>)</span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="number">1</span>:</span><br><span class="line">        itchat.send(sendMsg, fromName)</span><br><span class="line">        myfile.write(message)</span><br><span class="line">        myfile.write(<span class="string">"\n"</span>)</span><br><span class="line">        myfile.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    itchat.auto_login()</span><br><span class="line">    itchat.send(usageMsg, <span class="string">"filehelper"</span>)</span><br><span class="line">    itchat.run()</span><br></pre></td></tr></table></figure><p>程序并不复杂，定义了一些发送的消息，然后通过调用 itchat 和 cv2 相关库的操作，即可实现。关于 itchat 库的一些操作，可以去网上找相关的文档。</p><p><strong><strong>使用教程</strong></strong></p><p>获取源代码，然后在你的电脑上运行。随后会弹出一个微信网页登录的二维码。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/TIM%E6%88%AA%E5%9B%BE20180820122055.png?x-oss-process=style/w200" alt=""></p><p>使用你的手机微信扫描登录，等待一会儿，微信文件助手就会收到相应操作信息。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/374660489816441329_%E7%9C%8B%E5%9B%BE%E7%8E%8B.jpg?x-oss-process=style/w200" alt=""></p><p>发送消息「cmd shutdown -s -t 0」即可让当前的电脑关闭。</p><p>发送消息「cap」即可调用电脑摄像头拍摄当前用户，然后把图片发送到微信上。</p><p>当然 cmd 命名还可以做更多有趣的事，大家可以自己去网上搜索下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天带给大家一个非常有意思的 python 程序，基于 itchat 实现微信控制电脑。你可以通过在微信发送命令，来拍摄当前电脑的使用者，然后图片会发送到你的微信上。甚至你可以发送命令来远程关闭电脑。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://yfzhou.coding.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://yfzhou.coding.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中深拷贝与浅拷贝的区别</title>
    <link href="https://yfzhou.coding.me/2018/08/18/Python%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://yfzhou.coding.me/2018/08/18/Python中深拷贝与浅拷贝的区别/</id>
    <published>2018-08-18T10:48:44.000Z</published>
    <updated>2018-08-18T10:52:59.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>在Python中对象的赋值其实就是对象的引用。当创建一个对象，把它赋值给另一个变量的时候，python并没有拷贝这个对象，只是拷贝了这个对象的引用而已。</p></blockquote><a id="more"></a><p><br></p><blockquote><p>浅拷贝：拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已。也就是，把对象复制一遍，但是该对象中引用的其他对象我不复制</p><p>深拷贝：外围和内部元素都进行了拷贝对象本身，而不是引用。也就是，把对象复制一遍，并且该对象中引用的其他对象我也复制。</p></blockquote><h3 id="几个术语的解释："><a href="#几个术语的解释：" class="headerlink" title="几个术语的解释："></a>几个术语的解释：</h3><blockquote><p>1，变量：是一个系统表的元素，拥有指向对象的连接空间<br>2，对象：被分配的一块内存，存储其所代表的值<br>3，引用：是自动形成的从变量到对象的指针<br>4，注意：类型（int类型，long类型(python3已去除long类型，只剩下int类型的数据)）属于对象，不是变量<br>5，不可变对象：一旦创建就不可修改的对象，包括字符串、元组、数字<br>6，可变对象：可以修改的对象，包括列表、字典。</p></blockquote><h3 id="应用的范围："><a href="#应用的范围：" class="headerlink" title="应用的范围："></a>应用的范围：</h3><blockquote><p>1，切片可以应用于：列表、元组、字符串，但不能应用于字典。<br>2，深浅拷贝，既可应用序列（列表、元组、字符串），也可应用字典。</p></blockquote><h3 id="深浅拷贝的作用："><a href="#深浅拷贝的作用：" class="headerlink" title="深浅拷贝的作用："></a>深浅拷贝的作用：</h3><blockquote><p>1，减少内存的使用<br>2，以后在做数据的清洗、修改或者入库的时候，对原数据进行复制一份，以防数据修改之后，找不到原数据。</p></blockquote><h3 id="对于不可变对象的深浅拷贝："><a href="#对于不可变对象的深浅拷贝：" class="headerlink" title="对于不可变对象的深浅拷贝："></a>对于不可变对象的深浅拷贝：</h3><blockquote><p>不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。</p><p>一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a=(1,2,3)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====第一种=号浅拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=a</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====另一种copy浅拷贝==="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.copy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====深拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.deepcopy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">=====浅拷贝=====</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">2814522335952</span><br><span class="line">2814522335952</span><br><span class="line">=====另一种浅拷贝===</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">2814522335952</span><br><span class="line">2814522335952</span><br><span class="line">=====深拷贝=====</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">2814522335952</span><br><span class="line">2814522335952</span><br></pre></td></tr></table></figure><h1 id="对于可变对象深浅拷贝"><a href="#对于可变对象深浅拷贝" class="headerlink" title="对于可变对象深浅拷贝:"></a>对于可变对象深浅拷贝:</h1><blockquote><p>=浅拷贝：值相等，地址相等<br>copy浅拷贝：值相等，地址不相等<br>deepcopy深拷贝：值相等，地址不相等</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2,3]</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====第一种=号浅拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=a</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====另一种copy浅拷贝==="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.copy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"=====深拷贝====="</span>)</span><br><span class="line"><span class="attribute">b</span>=copy.deepcopy(a)</span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(id(a))</span><br><span class="line"><span class="builtin-name">print</span>(id(b))</span><br><span class="line"><span class="comment">#结果如下：</span></span><br><span class="line">=====浅拷贝=====</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">2007696321544</span><br><span class="line">2007696321544</span><br><span class="line">=====另一种copy浅拷贝===</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">2007696321544</span><br><span class="line">2007695909960</span><br><span class="line">=====深拷贝=====</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">2007696321544</span><br><span class="line">2007696319560</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>1，深浅拷贝都是对源对象的复制，占用不同的内存空间。</p><p>2，不可变类型的对象，对于深浅拷贝毫无影响，最终的地址值和值都是相等的。</p><p>3，可变类型：<br>=浅拷贝： 值相等，地址相等<br>copy浅拷贝：值相等，地址不相等<br>deepcopy深拷贝：值相等，地址不相等</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; title=&quot;定义：&quot;&gt;&lt;/a&gt;定义：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Python中对象的赋值其实就是对象的引用。当创建一个对象，把它赋值给另一个变量的时候，python并没有拷贝这个对象，只是拷贝了这个对象的引用而已。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://yfzhou.coding.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://yfzhou.coding.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（使用图床）</title>
    <link href="https://yfzhou.coding.me/2018/08/17/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/17/Hexo-Next搭建个人博客（使用图床）/</id>
    <published>2018-08-17T03:07:26.000Z</published>
    <updated>2018-08-17T03:16:43.770Z</updated>
    
    <content type="html"><![CDATA[<p>图片作为互联网服务中最基础的资源之一，随着互联网基础服务越来越专业化，图片的存储、处理、分发也发展成了一项独立的基础服务。试想一下，如果每家互联网公司都要花费大量人力物力去做图片相关的技术研发，哪还有时间去做自己的业务。专业的事情还是要交给专业的人来做。<br><a id="more"></a></p><p>图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。</p><p>当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生。我就经历过云服务商机房被雷劈，网站都挂掉的情况。支付宝光缆不也被挖断过吗？不过，对于我们个人用户来说，要求也没那么高，图床已经完全能满足我们的需求了。</p><hr><p>目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。  </p><h2 id="公共图床"><a href="#公共图床" class="headerlink" title="公共图床"></a>公共图床</h2><h3 id="微博图床"><a href="#微博图床" class="headerlink" title="微博图床"></a>微博图床</h3><p>由于微博本身就是面向公众提供服务，每个人发微博基本都得带上几张图片，以微博的体量，每天的新增图片数也不是个小数字。但是微博对于图片上传服务也没有接口说明文档，上传的接口还是在开发者们从微博产品里找出来的，可能微博只希望上传的图片仅仅用于微博产品本身吧。</p><p>微博图床的特点是免费，没有容量限制，全网 CDN 加速，支持 HTTPS，到哪里都很快。但是免费的服务也有不足的地方，上传的图片会被转成 jpg，图片中可能加上了肉眼难以识别的水印，另外微博的图片鉴别服务也可能会随时删除你的图片。</p><p>相关链接：</p><ul><li><p><a href="http://weibo.com/minipublish" target="_blank" rel="noopener">微博图床上传地址</a>：从这里直接上传图片比较麻烦，你可以使用下面介绍的一些图床工具，上传起来更方便。  </p></li><li><p><a href="http://picupload.service.weibo.com/interface/" target="_blank" rel="noopener">微博图床 API</a>：用浏览器当然是不能访问的，只提供图片上传。  </p></li></ul><h3 id="Imgur-图床"><a href="#Imgur-图床" class="headerlink" title="Imgur 图床"></a>Imgur 图床</h3><p><img src="https://cdn.sspai.com/2017/08/21/7d56369618ca55b7788a1f2b2469e274.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="Imgur API"></p><p>Imgur API</p><p><a href="https://imgur.com/" target="_blank" rel="noopener">Imgur</a> 是一家国外老牌的图片存储服务商，国外速度很快，口碑不错，支持 HTTPS。但是国内速度很不稳定，所以追求国内速度的同学慎用。</p><p>相关链接：</p><ul><li><a href="https://apidocs.imgur.com/" target="_blank" rel="noopener">Imgur API</a>  </li></ul><h3 id="SM-MS-图床"><a href="#SM-MS-图床" class="headerlink" title="SM.MS 图床"></a>SM.MS 图床</h3><p><img src="https://cdn.sspai.com/2017/08/21/a78e40318ea02f94a0b9e2ea19d8b10e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="sm.ms 图床"></p><p>sm.ms 图床</p><p><a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a> 是由 V2EX @<a href="https://www.v2ex.com/member/Showfom" target="_blank" rel="noopener">Showfom</a> 自建的，无外链限制，无流量限制的图床，支持 HTTPS，速度不错，已经运行两年多了。</p><p>相关链接：</p><ul><li><a href="https://sm.ms/doc/" target="_blank" rel="noopener">sm.ms API</a>  </li></ul><p>其它公共图床还有很多，一搜一大把，不过大部分规模都比较小，要不就是国内访问速度不理想，使用前最好先了解一下。</p><hr><p>目前自建图床方案有两种，一种是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片，另一种是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。</p><h2 id="自建图床：云服务"><a href="#自建图床：云服务" class="headerlink" title="自建图床：云服务"></a>自建图床：云服务</h2><h3 id="七牛"><a href="#七牛" class="headerlink" title="七牛"></a>七牛</h3><p><img src="https://cdn.sspai.com/2017/08/21/2242e610efb14f6d63261547f3e90609.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="七牛云"></p><p>七牛云</p><p><a href="https://portal.qiniu.com/signup?code=3lmd5t4axez4i" target="_blank" rel="noopener">七牛</a> 作为国内领先的云服务商，全网 CDN 加速，全国访问速度都不错，API 很详细，对开发者比较友好。免费用户提供 10GB 存储空间，国内和海外分别提供 10 GB 的 HTTP 免费流量，七牛的 HTTPS 流量是收费的，没有免费额度。此外，七牛还提供了针对图片的各种服务，包括图片裁剪，压缩，鉴黄等等衍生服务。如果你觉得图片尺寸太大，可以在外链后面添加参数，访问的时候七牛会自动根据你的参数对图片进行处理。</p><p>目前我的图片都存在七牛上，使用 HTTPS 外链，每个月支出也就几块钱，就为了博客上那个小绿锁 😆。</p><p>相关链接：</p><ul><li><p><a href="https://developer.qiniu.com/" target="_blank" rel="noopener">七牛云 API 文档</a>  </p></li><li><p><a href="https://www.qiniu.com/prices" target="_blank" rel="noopener">七牛价格</a>  </p></li></ul><h3 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h3><p><img src="https://cdn.sspai.com/2017/08/21/9f1b5842c3ab1b8bc29e5fdbce49a972.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="又拍云"></p><p>又拍云</p><p><a href="https://www.upyun.com/" target="_blank" rel="noopener">又拍云</a> 也算是国内比较有名的云服务商了，国内拥有 200+ 的自建 CDN 节点，国内速度也不错，API 很详细，不过对于普通用户没有免费额度，目前实行的是「按照用户每日实际消耗的 CDN 流量，实行 1:1 的存储空间费免费使用」。</p><p>相关链接：</p><ul><li><p><a href="http://docs.upyun.com/guide/#api" target="_blank" rel="noopener">又拍云 API 文档</a>  </p></li><li><p><a href="https://www.upyun.com/pricing" target="_blank" rel="noopener">又拍云价格</a>  </p></li></ul><h3 id="阿里云-OSS"><a href="#阿里云-OSS" class="headerlink" title="阿里云 OSS"></a>阿里云 OSS</h3><p><img src="https://cdn.sspai.com/2017/08/21/dea389e72df9a46289eaa24b3d88aee4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="阿里云 OSS"></p><p>阿里云 OSS</p><p><a href="https://www.aliyun.com/price/product#/oss/detail" target="_blank" rel="noopener">阿里云 OSS</a>（Object Storage Service），即阿里云对象存储服务，也可以作为图床，速度国内国外都不错，SDK 和 API 都很完善，收费也不算太贵，就是计费方案太复杂，目前费用包括：存储费用+流量费用+接口调用费用+数据处理，而且还分时段，地区，阶梯计费。可以选择包年包月和按量付费，具体价格和文档可以查看下面的官网介绍。</p><p>相关链接：</p><ul><li><p><a href="https://promotion.aliyun.com/ntms/act/ossdoclist.html" target="_blank" rel="noopener">阿里云 OSS 文档</a>  </p></li><li><p><a href="https://www.aliyun.com/price/product#/oss/detail" target="_blank" rel="noopener">阿里云 OSS 价格</a>  </p></li></ul><h2 id="自建图床：开源方案"><a href="#自建图床：开源方案" class="headerlink" title="自建图床：开源方案"></a>自建图床：开源方案</h2><p>如果你有 VPS，并且网络速度 OK 的话，自建图床也是一个不错的选择。</p><h3 id="Lychee"><a href="#Lychee" class="headerlink" title="Lychee"></a>Lychee</h3><p><img src="https://cdn.sspai.com/2017/08/21/5d4f0efa178487d54309f3da47d75e6e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="Lychee"></p><p>Lychee</p><p><a href="https://github.com/electerious/Lychee" target="_blank" rel="noopener">Lychee</a> 是一个开源免费的基于 PHP 的图片管理系统，支持 Docker 部署，可以直接当做图床来用，Lychee 还支持很多扩展。</p><h3 id="树洞外链"><a href="#树洞外链" class="headerlink" title="树洞外链"></a>树洞外链</h3><p><img src="https://cdn.sspai.com/2017/08/21/d916ed36a802e3e878e95d556bd64ef3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="树洞外链"></p><p>树洞外链</p><p><a href="https://yun.aoaoao.me/" target="_blank" rel="noopener">树洞外链</a> 是一款免费开源的 PHP 外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。</p><p>相关链接：</p><ul><li><a href="https://file.aoaoao.me/" target="_blank" rel="noopener">演示站点</a>  </li></ul><h2 id="上传工具"><a href="#上传工具" class="headerlink" title="上传工具"></a>上传工具</h2><p>对普通用户来说，直接使用图床 API 很麻烦，我们可以借助一些工具方便的上传图片，下面就根据 macOS、Windows、Web 分别推荐几款工具。</p><h3 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h3><p><img src="https://cdn.sspai.com/attachment/origin/2016/07/04/336030.png" alt=""></p><h4 id="iPic-1"><a href="#iPic-1" class="headerlink" title="iPic"></a>iPic</h4><p>Mac</p><p><a href="https://sspai.com/app/iPic" target="_blank" rel="noopener">相关文章</a></p><p>下载</p><ul><li><a href="https://itunes.apple.com/cn/app/ipic-tu-chuang-shen-qi/id1101244278?mt=12&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">Mac</a></li></ul><p><a href="https://itunes.apple.com/cn/app/id1101244278?ls=1&amp;mt=12" target="_blank" rel="noopener">iPic</a> 是 macOS 上口碑最好的图床工具，支持 微博图床、七牛、阿里云 OSS、又拍云、Imgur、Flickr 等常见图床，支持拖拽、快捷键、剪贴板上传，支持上传前压缩，上传完毕自动生成 Markdown 并拷贝到剪贴板。如果你想迁移图床，开发者 <a href="https://slarker.me/image-oss/toolinbox.net" target="_blank" rel="noopener">@jason</a> 还做了一款 <a href="https://toolinbox.net/iPic/iPicMover.html" target="_blank" rel="noopener">图床迁移工具 iPic Mover</a> 来帮助你。此外，简洁优雅的 Markdown 工具 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>也内嵌了 iPic 的上传服务，如果你也使用 Typora 的话，能感觉到这俩工具简直是绝配。</p><h3 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h3><p><img src="https://cdn.sspai.com/attachment/origin/2017/01/23/364951.png" alt=""></p><h4 id="MWeb-1"><a href="#MWeb-1" class="headerlink" title="MWeb"></a>MWeb</h4><p>iOS</p><p><a href="https://sspai.com/app/MWeb" target="_blank" rel="noopener">相关文章</a></p><p>下载</p><ul><li><a href="https://itunes.apple.com/cn/app/mweb-pro-markdown-writing/id1183407767?mt=8&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">iOS 通用</a></li><li><a href="https://itunes.apple.com/cn/app/mweb-zhuan-ye-demarkdown-xie/id954188948?mt=12&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">Mac</a></li></ul><p><img src="https://cdn.sspai.com/2017/08/21/a2229ac36e94260816e5423f5ceeba09.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="MWeb 中的图床支持"></p><p>MWeb 中的图床支持</p><p>如果你只是码字的时候才用到图床，那可能 <a href="http://zh.mweb.im/" target="_blank" rel="noopener">MWeb</a> 也能满足你的需求，MWeb 支持七牛、imgur、Google Photos，还支持自定义图床，写作的时候只需要将图片拖进来，写作完成一键上传所有图片，也很方便。</p><h3 id="Dropzone-3"><a href="#Dropzone-3" class="headerlink" title="Dropzone 3"></a>Dropzone 3</h3><p><img src="https://cdn.sspai.com/attachment/origin/2015/12/14/298954.png" alt=""></p><h4 id="Dropzone-3-1"><a href="#Dropzone-3-1" class="headerlink" title="Dropzone 3"></a>Dropzone 3</h4><p>Mac</p><p><a href="https://sspai.com/app/Dropzone 3" target="_blank" rel="noopener">相关文章</a></p><p>下载</p><ul><li><a href="https://itunes.apple.com/cn/app/dropzone-3/id695406827?mt=12&amp;ign-mpt=uo%3D4&amp;uo=4&amp;at=10lJSw&amp;ct=appcards" target="_blank" rel="noopener">Mac</a></li></ul><p><a href="https://itunes.apple.com/us/app/dropzone-3/id695406827?mt=12" target="_blank" rel="noopener">Dropzone 3</a> 也可以通过 <a href="https://kyleduo.com/" target="_blank" rel="noopener">七牛插件</a> 来支持上传图片，和 MWeb 类似，具体教程可以看 <a href="https://blog.kyleduo.com/2017/02/27/qiniu-upload-for-dropzone/#more" target="_blank" rel="noopener">这里</a>。</p><h3 id="MPic"><a href="#MPic" class="headerlink" title="MPic"></a>MPic</h3><p><img src="https://cdn.sspai.com/2017/08/21/ff144a6f126b6e608b93b5ba06013e14.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="MPic"></p><p>MPic</p><p><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">MPic</a> 目测是 Windows 上唯一的图床工具了，目前只支持七牛，把图片拖拽到软件窗口中就能上传。</p><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>使用 Web 技术开发的图床工具一抓一大把，大部分都基于七牛和微博图床 API，这里就介绍两个体验不错的吧：</p><ul><li><p><a href="http://yotuku.cn/" target="_blank" rel="noopener">极简图床</a>：默认公共图床使用 sm.ms、微博图床，可以自定义支持七牛，界面简洁美观，支持 <a href="https://chrome.google.com/webstore/detail/heebflcbemenefckkgfnnklbhdbdkagg" target="_blank" rel="noopener">Chrome 插件</a>，注册后还可以同步上传历史。  </p></li><li><p><a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf/reviews" target="_blank" rel="noopener">微博图床 Chroem 扩展</a>：开源的图床工具，只支持微博图床，使用起来也很方便，可以批量上传，管理上传历史。  </p></li></ul><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>如果你对上面推荐的产品不满意，并且你会折腾的话，可以使用这个脚本来完成图片上传：<a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="noopener">Markdown 图片实用工具</a></p><p>该脚本使用 Python 版的七牛 SDK 来实现上传功能，你可以按照相关介绍，搭配 Alfred 来快速完成图片上传。</p><hr><p>图床服务最重要的是稳定性，大厂的云服务也都比较有保障，大家只要考虑下价格和易用性就可以了。就我个人而言，我首先推荐七牛，它的价格比较厚道，免费用户也有一定额度，数据可以自己掌控，另外各大平台的图床工具也基本都支持，易用性很高。其次推荐微博图床，对于不是很重要的图片，都可以存到微博图床，毕竟流量存储都免费，速度也不错。至于图床工具，就看自己的喜好了，只要顺手就行。但是不论选择哪一个服务或者工具，我觉得首先要自己可以掌控数据。</p><p>总之，适合自己的才是最好的。如果你还有其它好用的工具或者图床服务，欢迎留言给我，我会补充进来。</p><hr><p><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">《图床神器》</a></p><p><a href="https://pic.xiaojianjian.net/" target="_blank" rel="noopener">《小贱贱图床》</a></p><p><a href="https://sm.ms/" target="_blank" rel="noopener">《SM.SMb》</a></p><p><a href="https://sspai.com/post/40499" target="_blank" rel="noopener">《嗯，图片就交给它了》</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图片作为互联网服务中最基础的资源之一，随着互联网基础服务越来越专业化，图片的存储、处理、分发也发展成了一项独立的基础服务。试想一下，如果每家互联网公司都要花费大量人力物力去做图片相关的技术研发，哪还有时间去做自己的业务。专业的事情还是要交给专业的人来做。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB并发如此高，原因竟然在这？</title>
    <link href="https://yfzhou.coding.me/2018/08/14/InnoDB%E5%B9%B6%E5%8F%91%E5%A6%82%E6%AD%A4%E9%AB%98%EF%BC%8C%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E5%9C%A8%E8%BF%99%EF%BC%9F/"/>
    <id>https://yfzhou.coding.me/2018/08/14/InnoDB并发如此高，原因竟然在这？/</id>
    <published>2018-08-14T10:07:19.000Z</published>
    <updated>2018-08-15T13:50:38.879Z</updated>
    
    <content type="html"><![CDATA[<p>此文摘自微信公众号【架构师之路】</p><p>微信扫一扫<br>关注该公众号</p><p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961431&amp;idx=1&amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;send_time=" alt=""><br><a id="more"></a></p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961431&amp;idx=1&amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;chksm=bd2d0d8b8a5a849d8cb5a616c957abde7a6485cd2624372b84a5459eed081bd95429a09572f8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB行锁，如何锁住一条不存在的记录？</a>》埋了一个坑，没想到评论反响剧烈，大家都希望深挖下去。原计划写写InnoDB的锁结束这个case，既然呼声这么高，干脆全盘<strong>系统性</strong>的写写InnoDB的<strong>并发控制</strong>，<strong>锁</strong>，<strong>事务模型</strong>好了。</p><p>体系相对宏大，一篇肯定写不完，容我娓娓道来，通俗地说清楚来龙去脉。</p><p><strong>一、并发控制</strong></p><p><strong>为啥要进行并发控制？</strong></p><p>并发的任务对同一个临界资源进行操作，如果不采取措施，可能导致不一致，故必须进行<strong>并发控制</strong>（Concurrency Control）。</p><p><strong>技术上，通常如何进行并发控制？</strong></p><p>通过并发控制保证数据一致性的常见手段有：</p><ul><li><p>锁（Locking）</p></li><li><p>数据多版本（Multi Versioning）</p></li></ul><p><strong>二、锁</strong></p><p><strong>如何使用普通锁保证一致性？</strong></p><p>普通锁，被使用最多：</p><p>(1)<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">操作数据前，锁住，实施互斥</span>，不允许其他的并发任务操作；</p><p>(2)操作完成后，释放锁，让其他任务执行；</p><p>如此这般，来保证一致性。</p><p><strong>普通锁存在什么问题？</strong></p><p>简单的锁住太过粗暴，连“读任务”也无法并行，任务执行过程本质上是串行的。</p><p>于是出现了<strong>共享锁</strong>与<strong>排他锁</strong>：</p><ul><li><p>共享锁（<span style="color: rgb(255, 76, 0);"><strong><span style="letter-spacing: 1px;font-size: 12px;">S</span></strong></span>hare Locks，记为S锁），读取数据时加S锁</p></li><li><p>排他锁（e<span style="color: rgb(255, 76, 0);"><strong><span style="letter-spacing: 1px;font-size: 12px;">X</span></strong></span>clusive Locks，记为X锁），修改数据时加X锁</p></li></ul><p>共享锁与排他锁的玩法是：</p><ul><li><p><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">共享锁之间不互斥</span>，简记为：<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">读读可以并行</span></p></li><li><p><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">排他锁与任何锁互斥</span>，简记为：<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">写读，写写不可以并行</span></p></li></ul><p>可以看到，一旦写数据的任务没有完成，数据是不能被其他任务读取的，这对并发度有较大的影响。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">对应到数据库，可以理解为，写事务没有提交，读相关数据的</span></span><span style="font-family: 宋体;letter-spacing: 1px;font-size: 12px;">select</span><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">也会被阻塞。</span></em></span></p><p><strong>有没有可能，进一步提高并发呢？</strong></p><p>即使写任务没有完成，其他读任务也可能并发，这就引出了数据多版本。</p><p><strong>三、数据多版本</strong></p><p><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">数据多版本</span>是一种能够进一步提高并发的方法，它的<strong>核心原理</strong>是：</p><p>（1）写任务发生时，将数据克隆一份，以版本号区分；</p><p>（2）写任务操作新克隆的数据，直至提交；</p><p>（3）并发读任务可以继续读取旧版本的数据，不至于阻塞；</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/222481745858779089.jpg" alt=""></p><p>如上图：</p><ol><li><p>最开始数据的版本是V0；</p></li><li><p>T1时刻发起了一个写任务，这是把数据clone了一份，进行修改，版本变为V1，但任务还未完成；</p></li><li><p>T2时刻并发了一个读任务，依然可以读V0版本的数据；</p></li><li><p>T3时刻又并发了一个读任务，依然不会阻塞；</p></li></ol><p>可以看到，数据多版本，通过“读取旧版本数据”能够极大提高任务的并发度。</p><p>提高并发的演进思路，就在如此：</p><ul><li><p><strong>普通锁</strong>，本质是<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">串行</span>执行</p></li><li><p><strong>读写锁</strong>，可以实现<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">读读并发</span></p></li><li><p><strong>数据多版本</strong>，可以实现<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">读写并发</span></p></li></ul><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：这个思路，比整篇文章的其他技术细节更重要，希望大家牢记。</span></em></span></p><p>好，对应到InnoDB上，具体是怎么玩的呢？</p><p><strong>四、redo, undo,**</strong>回滚段**</p><p>在进一步介绍InnoDB如何使用“读取旧版本数据”极大提高任务的并发度之前，有必要先介绍下redo日志，undo日志，回滚段（rollback segment）。</p><p><strong>为什么要有redo**</strong>日志？**</p><p>数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。磁盘<strong>随机写</strong>性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。</p><p>优化方式是，将修改行为先写到redo日志里（此时变成了<strong>顺序写</strong>），再定期将数据刷到磁盘上，这样能极大提高性能。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：这里的架构设计方法是，<strong>随机写优化为顺序写</strong>，思路更重要。</span></em></span></p><p>假如某一时刻，数据库崩溃，还没来得及刷盘的数据，在数据库重启后，会重做redo日志里的内容，以保证已提交事务对数据产生的影响都刷到磁盘上。</p><p><strong>一句话</strong>，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">redo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志</span></span>用于保障，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">已提交事务的</span>ACID<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">特性</span></span>。</p><p><strong>为什么要有undo**</strong>日志？**</p><p>数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，当事务回滚时，或者数据库奔溃时，可以利用undo日志，即旧版本数据，撤销未提交事务对数据库产生的影响。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;">画外音：更细节的，</span></em></span></p><p><span style="color: rgb(0, 82, 255);"><em><span style="color: rgb(0, 82, 255);font-size: 14px;letter-spacing: 1px;"><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">对于</span><strong>insert<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">操作</span></strong><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，</span>undo<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志记录新数据的</span>PK(ROW_ID)<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，回滚时直接删除；</span></span></em></span></p><p><span style="color: rgb(0, 82, 255);"><em><span style="color: rgb(0, 82, 255);font-size: 14px;letter-spacing: 1px;"><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">对于</span><strong>delete/update<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">操作</span></strong><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，</span>undo<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志记录旧数据</span>row<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">，回滚时直接恢复；</span></span></em></span></p><p><span style="color: rgb(0, 82, 255);"><em><span style="color: rgb(0, 82, 255);font-size: 14px;letter-spacing: 1px;"><span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">他们分别存放在不同的</span>buffer<span style="color: rgb(0, 82, 255);letter-spacing: 1px;font-size: 14px;font-family: 宋体;">里。</span></span></em></span></p><p><strong>一句话</strong>，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">undo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志</span></span>用于保障，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">未提交事务不会对数据库的ACID特性</span>产生影响。</p><p><strong>什么是回滚段？</strong></p><p>存储undo日志的地方，是回滚段。</p><p>undo日志和回滚段和InnoDB的MVCC密切相关，这里举个例子展开说明一下。</p><p><strong>栗子</strong>：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">t</span>(<span class="name">id</span> PK, name)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>数据为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, shenjian</span><br><span class="line"><span class="number">2</span>, zhangsan</span><br><span class="line"><span class="number">3</span>, lisi</span><br></pre></td></tr></table></figure></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/854310171767639185.jpg" alt="">  </p><p>此时没有事务未提交，故回滚段是空的。</p><p>接着启动了一个事务：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> trx;</span><br><span class="line"><span class="keyword">delete</span> (<span class="number">1</span>, shenjian);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span>(<span class="number">3</span>, lisi) <span class="keyword">to</span> (<span class="number">3</span>, xxx);</span><br><span class="line"><span class="keyword">insert</span> (<span class="number">4</span>, wangwu);</span><br></pre></td></tr></table></figure></p><p>并且事务处于<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">未提交</span>的状态。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/76916220599096767.jpg" alt=""></p><p>可以看到：</p><p>(1)被<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">删除前</span>的(1, shenjian)作为旧版本数据，进入了回滚段；</p><p>(2)被<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">修改前</span>的(3, lisi)作为旧版本数据，进入了回滚段；</p><p>(3)被<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">插入的</span>数据，PK(4)进入了回滚段；</p><p>接下来，假如事务rollback，此时可以通过回滚段里的undo日志回滚。</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-size: 14px;letter-spacing: 1px;"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">画外音：假设事务提交，回滚段里的</span>undo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志可以删除。</span></span></em></span></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/138982544617441980.jpg" alt=""></p><p>可以看到：</p><p>(1)被删除的旧数据恢复了；</p><p>(2)被修改的旧数据也恢复了；</p><p>(3)被插入的数据，删除了；</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/319830267672366053.jpg" alt="">  </p><p>事务回滚成功，一切如故。</p><p><strong>四、InnoDB**</strong>是基于多版本并发控制的存储引擎**</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961428&amp;idx=1&amp;sn=31a9eb967941d888fbd4bb2112e9602b&amp;chksm=bd2d0d888a5a849e7ebaa7756a8bc1b3d4e2f493f3a76383fc80f7e9ce7657e4ed2f6c01777d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">大数据量，高并发量的互联网业务，一定要使用InnoDB</a>》提到，InnoDB是高并发互联网场景最为推荐的存储引擎，根本原因，就是其<strong>多版本并发控制</strong>（Multi Version Concurrency Control, MVCC）。<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">行锁，并发，事务回滚</span>等多种特性都和MVCC相关。</p><p>MVCC就是通过“读取旧版本数据”来降低并发事务的锁冲突，提高任务的并发度。</p><p><strong>核心问题：</strong></p><p><strong>旧版本数据存储在哪里？</strong></p><p><strong>存储旧版本数据，对MySQL**</strong>和InnoDB<strong>**原有架构是否有巨大冲击？</strong></p><p>通过上文<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">undo<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">日志</span></span>和<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">回滚段</span>的铺垫，这两个问题就非常好回答了：</p><p>(1)旧版本数据存储在回滚段里；</p><p>(2)对MySQL和InnoDB原有架构体系冲击不大；</p><p>InnoDB的内核，会对所有row数据增加三个内部属性：</p><p>(1)<strong>DB_TRX_ID</strong>，6字节，记录每一行最近一次修改它的事务ID；</p><p>(2)<strong>DB_ROLL_PTR</strong>，7字节，记录指向回滚段undo日志的指针；</p><p>(3)<strong>DB_ROW_ID</strong>，6字节，单调递增的行ID；</p><p><strong>InnoDB**</strong>为何能够做到这么高的并发？**</p><p>回滚段里的数据，其实是历史数据的<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;color: rgb(255, 76, 0);">快照</span>（snapshot），这些数据是不会被修改，select可以肆无忌惮的并发读取他们。</p><p><strong>快照读</strong>（Snapshot Read），这种<strong>一致性不加锁的读</strong>（Consistent Nonlocking Read），就是<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">InnoDB<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">并发如此之高的核心原因之一</span></span>。</p><p>这里的<strong>一致性</strong>是指，事务读取到的数据，要么是事务开始前就已经存在的数据（当然，是其他已提交事务产生的），要么是事务自身插入或者修改的数据。</p><p><strong>什么样的select**</strong>是快照读？**</p><p>除非显示加锁，<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">普通的</span>select<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">语句都是快照读</span></span>，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>这里的<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">显示加锁，非快照读</span>是指：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span> **<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>**;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span> **<span class="keyword">for</span> <span class="keyword">update</span>**;</span><br></pre></td></tr></table></figure></p><p>问题来了，这些显示加锁的读，是什么读？会加什么锁？和事务的隔离级别又有什么关系？</p><p>本节的内容已经够多了，且听下回分解。</p><p><strong>总结</strong></p><p>(1)常见并发控制保证数据一致性的方法有<strong>锁</strong>，<strong>数据多版本</strong>；</p><p>(2)<strong>普通锁</strong><span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);font-family: 宋体;">串行</span>，<strong>读写锁</strong><span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);font-family: 宋体;">读读并行</span>，<strong>数据多版本</strong><span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);font-family: 宋体;">读写并行</span>；</p><p>(3)<strong>redo日志</strong>保证<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">已提交事务的</span>，设计思路是，通过顺序写替代随机写，提高并发；</p><p>(4)<strong>undo日志</strong>用来<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">回滚未提交的事务</span>，它存储在回滚段里；</p><p>(5)InnoDB是基于<strong>MVCC</strong>的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；</p><p>(6)InnoDB之所以并发高，<span style="font-family: 宋体;font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);">快照读不加锁</span>；</p><p>(7)InnoDB所有<span style="font-size: 14px;letter-spacing: 1px;color: rgb(255, 76, 0);"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">普通</span>select<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">都是快照读</span></span>；</p><p><span style="color: rgb(0, 82, 255);"><em><span style="font-size: 14px;letter-spacing: 1px;"><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">画外音：</span><span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">本文的知识点均基于</span>MySQL5.6<span style="letter-spacing: 1px;font-size: 14px;font-family: 宋体;">。</span></span></em></span></p><p>希望大家有收获，下一篇继续深入InnoDB的<strong>锁</strong>。</p><p>希望通俗的技术文被更多人看到，求帮<strong>转</strong>。</p><p>相关文章：</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961428&amp;idx=1&amp;sn=31a9eb967941d888fbd4bb2112e9602b&amp;chksm=bd2d0d888a5a849e7ebaa7756a8bc1b3d4e2f493f3a76383fc80f7e9ce7657e4ed2f6c01777d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB，5项最佳实践，知其所以然？</a>》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文摘自微信公众号【架构师之路】&lt;/p&gt;
&lt;p&gt;微信扫一扫&lt;br&gt;关注该公众号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;amp;size=102&amp;amp;__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=2651961431&amp;amp;idx=1&amp;amp;sn=4f46fbada3d99ca6cf74b305d06c1ac6&amp;amp;send_time=&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yfzhou.coding.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://yfzhou.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="https://yfzhou.coding.me/tags/SQL/"/>
    
      <category term="InnoDB" scheme="https://yfzhou.coding.me/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>java8 Lambda表达式</title>
    <link href="https://yfzhou.coding.me/2018/08/13/java8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://yfzhou.coding.me/2018/08/13/java8-Lambda表达式/</id>
    <published>2018-08-13T12:10:58.000Z</published>
    <updated>2018-08-21T12:24:55.938Z</updated>
    
    <content type="html"><![CDATA[<p>Java8发布已经有一段时间了，这次发布的改动比较大，很多人将这次改动与Java5的升级相提并论。Java8其中一个很重要的新特性就是lambda表达式，允许我们将行为传到函数中。想想看，在Java8<br>之前我们想要将行为传入函数，仅有的选择就是匿名内部类。Java8发布以后，lambda表达式将大量替代匿名内部类的使用，简化代码的同时，更突出了原来匿名内部类中最重要的那部分包含真正逻辑的代码。尤其是对于做数据的同学来说，当习惯使用类似scala之类的函数式编程语言以后，体会将更加深刻。现在我们就来看看Java8中lambda表达式的一些常见写法。</p><a id="more"></a><h2 id="1-替代匿名内部类"><a href="#1-替代匿名内部类" class="headerlink" title="1.替代匿名内部类"></a>1.替代匿名内部类</h2><p>毫无疑问，lambda表达式用得最多的场合就是替代匿名内部类，而实现Runnable接口是匿名内部类的经典例子。lambda表达式的功能相当强大，用()-&gt;就可以代替整个匿名内部类！请看代码：</p><p>如果使用匿名内部类：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">oldRunable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The old runable now is using!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而如果使用lambda表达式：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="literal">void</span> runable() &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"It's a lambda function!"</span>))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>最后的输出：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The old runable now <span class="keyword">is</span> <span class="keyword">using</span>!</span><br><span class="line">It<span class="comment">'s a lambda function!</span></span><br></pre></td></tr></table></figure></p><p>是不是强大到可怕？是不是简单到可怕？是不是清晰明了重点突出到可怕？这就是lambda表达式的可怕之处，用极少的代码完成了之前一个类做的事情！</p><h2 id="2-使用lambda表达式对集合进行迭代"><a href="#2-使用lambda表达式对集合进行迭代" class="headerlink" title="2.使用lambda表达式对集合进行迭代"></a>2.使用lambda表达式对集合进行迭代</h2><p>Java的集合类是日常开发中经常用到的，甚至说没有哪个java代码中没有使用到集合类。。。而对集合类最常见的操作就是进行迭代遍历了。请看对比：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> iterTest() &#123;</span><br><span class="line">    List&lt;String&gt; languages = Arrays.<span class="keyword">asList</span>(<span class="string">"java"</span>,<span class="string">"scala"</span>,<span class="string">"python"</span>);</span><br><span class="line">    <span class="comment">//before java8</span></span><br><span class="line">    <span class="keyword">for</span>(String <span class="keyword">each</span>:languages) &#123;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="keyword">each</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//after java8</span></span><br><span class="line">    languages.forEach(x -&gt; System.out.<span class="keyword">println</span>(x));</span><br><span class="line">    languages.forEach(System.out::<span class="keyword">println</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果熟悉scala的同学，肯定对forEach不陌生。它可以迭代集合中所有的对象，并且将lambda表达式带入其中。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">languages</span><span class="selector-class">.forEach</span>(<span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-pseudo">::println)</span>;</span><br></pre></td></tr></table></figure></p><p>这一行看起来有点像c++里面作用域解析的写法，在这里也是可以的。</p><h2 id="3-用lambda表达式实现map"><a href="#3-用lambda表达式实现map" class="headerlink" title="3.用lambda表达式实现map"></a>3.用lambda表达式实现map</h2><p>一提到函数式编程，一提到lambda表达式，怎么能不提map。。。没错，java8肯定也是支持的。请看示例代码：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@Test</span></span><br><span class="line">public void mapTest() &#123;</span><br><span class="line">    List&lt;Double&gt; cost = Arrays.asList(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment">    cost.stream().map(x -&gt; x + x*0.05).forEach(x -&gt; System.out.println(x));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p><p>最后的输出结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10<span class="selector-class">.5</span></span><br><span class="line">21<span class="selector-class">.0</span></span><br><span class="line">31<span class="selector-class">.5</span></span><br></pre></td></tr></table></figure></p><p>map函数可以说是函数式编程里最重要的一个方法了。map的作用是将一个对象变换为另外一个。在我们的例子中，就是通过map方法将cost增加了0,05倍的大小然后输出。</p><h2 id="4-用lambda表达式实现map与reduce"><a href="#4-用lambda表达式实现map与reduce" class="headerlink" title="4.用lambda表达式实现map与reduce"></a>4.用lambda表达式实现map与reduce</h2><p>既然提到了map，又怎能不提到reduce。reduce与map一样，也是函数式编程里最重要的几个方法之一。。。map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个，请看：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="literal">void</span> mapReduceTest() &#123;</span><br><span class="line">    List&lt;Double&gt; cost = Arrays.asList(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>);</span><br><span class="line">    double allCost = cost.stream<span class="function"><span class="params">()</span>.<span class="title">map</span><span class="params">(x -&gt; x+x*<span class="number">0.05</span>)</span>.<span class="title">reduce</span><span class="params">((sum,x) -&gt; sum + x)</span>.<span class="title">get</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(allCost)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>最终的结果为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">63<span class="selector-class">.0</span></span><br></pre></td></tr></table></figure></p><p>如果我们用for循环来做这件事情：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> sumTest() &#123;</span><br><span class="line">    List&lt;<span class="keyword">Double</span>&gt; cost = Arrays.<span class="keyword">asList</span>(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>);</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> <span class="keyword">each</span>:cost) &#123;</span><br><span class="line">        <span class="keyword">each</span> += <span class="keyword">each</span> * <span class="number">0.05</span>;</span><br><span class="line">        sum += <span class="keyword">each</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="keyword">println</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相信用map+reduce+lambda表达式的写法高出不止一个level。</p><h2 id="5-filter操作"><a href="#5-filter操作" class="headerlink" title="5.filter操作"></a>5.filter操作</h2><p>filter也是我们经常使用的一个操作。在操作集合的时候，经常需要从原始的集合中过滤掉一部分元素。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> filterTest() &#123;</span><br><span class="line">    List&lt;<span class="keyword">Double</span>&gt; cost = Arrays.<span class="keyword">asList</span>(<span class="number">10.0</span>, <span class="number">20.0</span>,<span class="number">30.0</span>,<span class="number">40.0</span>);</span><br><span class="line">    List&lt;<span class="keyword">Double</span>&gt; filteredCost = cost.stream().filter(x -&gt; x &gt; <span class="number">25.0</span>).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    filteredCost.forEach(x -&gt; System.out.<span class="keyword">println</span>(x));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30<span class="selector-class">.0</span></span><br><span class="line">40<span class="selector-class">.0</span></span><br></pre></td></tr></table></figure></p><p>将java写出了python或者scala的感觉有没有！是不是帅到爆！</p><h2 id="6-与函数式接口Predicate配合"><a href="#6-与函数式接口Predicate配合" class="headerlink" title="6.与函数式接口Predicate配合"></a>6.与函数式接口Predicate配合</h2><p>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。Predicate接口非常适用于做过滤。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> filterTest(List&lt;<span class="keyword">String</span>&gt; languages, Predicate&lt;<span class="keyword">String</span>&gt; condition) &#123;</span><br><span class="line">    languages.stream().<span class="built_in">filter</span>(x -&gt; condition.test(x)).forEach(x -&gt; System.out.<span class="built_in">println</span>(x + <span class="string">" "</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; languages = Arrays.asList(<span class="string">"Java"</span>,<span class="string">"Python"</span>,<span class="string">"scala"</span>,<span class="string">"Shell"</span>,<span class="string">"R"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Language starts with J: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; x.startsWith(<span class="string">"J"</span>));</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Language ends with a: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; x.endsWith(<span class="string">"a"</span>));</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"All languages: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; <span class="keyword">true</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"No languages: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; <span class="keyword">false</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Language length bigger three: "</span>);</span><br><span class="line">    filterTest(languages,x -&gt; x.length() &gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的输出结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Language starts with <span class="keyword">J: </span></span><br><span class="line"><span class="keyword">Java </span></span><br><span class="line"></span><br><span class="line">Language ends with a: </span><br><span class="line"><span class="keyword">Java </span></span><br><span class="line"><span class="keyword">scala </span></span><br><span class="line"></span><br><span class="line">All languages: </span><br><span class="line"><span class="keyword">Java </span></span><br><span class="line">Python </span><br><span class="line"><span class="keyword">scala </span></span><br><span class="line"><span class="keyword">Shell </span></span><br><span class="line">R </span><br><span class="line"></span><br><span class="line">No languages: </span><br><span class="line"></span><br><span class="line">Language length <span class="keyword">bigger </span>three: </span><br><span class="line">Python </span><br><span class="line"><span class="keyword">scala </span></span><br><span class="line"><span class="keyword">Shell</span></span><br></pre></td></tr></table></figure><p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这也是lambda表达式的魔力！</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p>1.<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">《Java8 lambda表达式10个示例》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8发布已经有一段时间了，这次发布的改动比较大，很多人将这次改动与Java5的升级相提并论。Java8其中一个很重要的新特性就是lambda表达式，允许我们将行为传到函数中。想想看，在Java8&lt;br&gt;之前我们想要将行为传入函数，仅有的选择就是匿名内部类。Java8发布以后，lambda表达式将大量替代匿名内部类的使用，简化代码的同时，更突出了原来匿名内部类中最重要的那部分包含真正逻辑的代码。尤其是对于做数据的同学来说，当习惯使用类似scala之类的函数式编程语言以后，体会将更加深刻。现在我们就来看看Java8中lambda表达式的一些常见写法。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="Lambda" scheme="https://yfzhou.coding.me/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（添加网页标题崩溃欺骗搞怪特效）</title>
    <link href="https://yfzhou.coding.me/2018/08/13/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E6%A0%87%E9%A2%98%E5%B4%A9%E6%BA%83%E6%AC%BA%E9%AA%97%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/13/Hexo-Next搭建个人博客（添加网页标题崩溃欺骗搞怪特效）/</id>
    <published>2018-08-13T11:21:24.000Z</published>
    <updated>2018-08-13T11:25:17.715Z</updated>
    
    <content type="html"><![CDATA[<p>给网页title添加一些搞怪特效  </p><a id="more"></a><h1 id="crash-cheat-js"><a href="#crash-cheat-js" class="headerlink" title="crash_cheat.js"></a><a href="#crash-cheat-js" title="crash_cheat.js"></a>crash_cheat.js</h1><p>在<code>next\source\js\src</code>文件夹下创建<code>crash_cheat.js</code>，添加代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--崩溃欺骗--&gt;</span><br><span class="line"><span class="keyword">var</span> OriginTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        $(<span class="string">'[rel="icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/img/TEP.ico"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'╭(°A°`)╮ 页面崩溃啦 ~'</span>;</span><br><span class="line">        clearTimeout(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">'[rel="icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/favicon.ico"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'(ฅ&gt;ω&lt;*ฅ) 噫又好了~'</span> + OriginTitle;</span><br><span class="line">        titleTime = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = OriginTitle;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a><a href="#引用" title="引用"></a>引用</h1><p>在<code>next\layout\_layout.swig</code>文件中，添加引用（注：在swig末尾添加）：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--崩溃欺骗--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/crash_cheat.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给网页title添加一些搞怪特效  &lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>前端杂记</title>
    <link href="https://yfzhou.coding.me/2018/08/13/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%AE%B0/"/>
    <id>https://yfzhou.coding.me/2018/08/13/前端杂记/</id>
    <published>2018-08-13T02:39:15.000Z</published>
    <updated>2018-08-21T01:57:16.380Z</updated>
    
    <content type="html"><![CDATA[<p>记录工作中遇到的一些关于前端的破事。</p><a id="more"></a><ol><li><p>正则验证</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regIdNo = /(^\d&#123;<span class="number">15</span>&#125;$)|(^\d&#123;<span class="number">18</span>&#125;$)|(^\d&#123;<span class="number">17</span>&#125;(\d|X|x)$)/; </span><br><span class="line"><span class="keyword">let</span> regtel=/^[<span class="number">1</span>][<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">9</span>&#125;$/;</span><br><span class="line"><span class="keyword">let</span> reglicence = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;<span class="number">1</span>&#125;[A-Z]&#123;<span class="number">1</span>&#125;[A-Z<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">4</span>&#125;[A-Z<span class="number">0</span>-<span class="number">9</span>挂学警港澳]&#123;<span class="number">1</span>&#125;$/;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!regtel.test(<span class="string">'##############'</span>)) &#123;</span><br><span class="line">    alert(<span class="string">'手机号格式有误'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!regIdNo.test(<span class="string">'##############'</span>))&#123;  </span><br><span class="line"> alert(<span class="string">'身份证号填写有误'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!reglicence.test(<span class="string">'##########'</span>))&#123;</span><br><span class="line">alert(<span class="string">'身份证号填写有误'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合快速去除（ES6）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.from(<span class="keyword">new</span> <span class="type">Set</span>(a))</span><br></pre></td></tr></table></figure></li><li><p>获取当前项目的路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> urlRootContext = (function () &#123;</span><br><span class="line">  <span class="selector-tag">var</span> strPath = window<span class="selector-class">.document</span><span class="selector-class">.location</span><span class="selector-class">.pathname</span></span><br><span class="line">  <span class="selector-tag">var</span> postPath = strPath.substring(<span class="number">0</span>, strPath.substr(<span class="number">1</span>).indexOf(<span class="string">'/'</span>) + <span class="number">1</span>)</span><br><span class="line">  return postPath</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录工作中遇到的一些关于前端的破事。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://yfzhou.coding.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="https://yfzhou.coding.me/tags/HTML/"/>
    
      <category term="js" scheme="https://yfzhou.coding.me/tags/js/"/>
    
      <category term="前端" scheme="https://yfzhou.coding.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css" scheme="https://yfzhou.coding.me/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 file API加canvas实现图片前端JS压缩并上传</title>
    <link href="https://yfzhou.coding.me/2018/08/10/HTML5%20file%20API%E5%8A%A0canvas%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%89%8D%E7%AB%AFJS%E5%8E%8B%E7%BC%A9%E5%B9%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://yfzhou.coding.me/2018/08/10/HTML5 file API加canvas实现图片前端JS压缩并上传/</id>
    <published>2018-08-10T11:26:16.000Z</published>
    <updated>2018-08-13T03:08:14.205Z</updated>
    
    <content type="html"><![CDATA[<p>by <a href="http://www.zhangxinxu.com/" target="_blank" rel="noopener">zhangxinxu</a> from <a href="http://www.zhangxinxu.com/wordpress/?p=6308" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=6308</a><br>本文可全文转载，但需得到原作者书面许可，同时保留原作者和出处，摘要引流则随意。</p><a id="more"></a><h3 id="一、图片上传前端压缩的现实意义"><a href="#一、图片上传前端压缩的现实意义" class="headerlink" title="一、图片上传前端压缩的现实意义"></a>一、图片上传前端压缩的现实意义</h3><p>对于大尺寸图片的上传，在前端进行压缩除了省流量外，最大的意义是极大的提高了用户体验。</p><p>这种体验包括两方面：</p><ol><li>由于上传图片尺寸比较小，因此上传速度会比较快，交互会更加流畅，同时大大降低了网络异常导致上传失败风险。</li><li>最最重要的体验改进点：省略了图片的再加工成本。很多网站的图片上传功能都会对图片的大小进行限制，尤其是头像上传，限制5M或者2M以内是非常常见的。然后现在的数码设备拍摄功能都非常出众，一张原始图片超过2M几乎是标配，此时如果用户想把手机或相机中的某个得意图片上传作为自己的头像，就会遇到因为图片大小限制而不能上传的窘境，不得不对图片进行再处理，而这种体验其实非常不好的。如果可以在前端进行压缩，则理论上对图片尺寸的限制是没有必要的。</li></ol><h3 id="二、图片前端JS压缩并上传功能体验"><a href="#二、图片前端JS压缩并上传功能体验" class="headerlink" title="二、图片前端JS压缩并上传功能体验"></a>二、图片前端JS压缩并上传功能体验</h3><p>特意制作了一个图片前端压缩并上传的完整demo，您可以狠狠的点击这里：<a href="http://www.zhangxinxu.com/study/201707/js-compress-image-before-upload.html" target="_blank" rel="noopener">使用canvas在前端压缩图片并上传demo</a></p><p>进入demo会看到一个相貌平平的文件输入框：</p><p><img src="//image.zhangxinxu.com/image/blog/201707/gutianlle.jpg" alt="相貌平平"></p><p>啊，不对，应该是这张图：</p><p><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_221637.png" alt="相貌平平文件选择框"></p><p>点击文件选择框，我们不妨选一张尺寸比较大的图片，例如下面这种2M多的钓鱼收获照：</p><p><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_221955.png" alt="上传演示使用的图片"></p><p>于是图片歘歘歘地传上去了：<br><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_222424.png" alt="上传相关信息截图"></p><p>此时我们点击最终上传完毕的图片地址，会发现原来2M多3000多像素宽的图片被限制为400像素宽了：<br><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_222714s.jpg" alt="图片缩小后在浏览器中的预览效果图"></p><p>保存到本地会发现图片尺寸已经变成只有70K了：<br><img src="//image.zhangxinxu.com/image/blog/201707/2017-07-30_223016.jpg" alt="保存到本地显示的图片尺寸"></p><p>以上就是图片前端压缩并上传demo的完整演示。</p><h3 id="三、HTML5-file-API加canvas实现图片前端JS压缩"><a href="#三、HTML5-file-API加canvas实现图片前端JS压缩" class="headerlink" title="三、HTML5 file API加canvas实现图片前端JS压缩"></a>三、HTML5 file API加canvas实现图片前端JS压缩</h3><p>要想使用JS实现图片的压缩效果，原理其实很简单，核心API就是使用<code>canvas</code>的<code>drawImage()</code>方法。</p><p><code>canvas</code>的<code>drawImage()</code>方法API如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">context</span>.drawImage(img, dx, dy)<span class="comment">;</span></span><br><span class="line"><span class="built_in">context</span>.drawImage(img, dx, dy, dWidth, dHeight)<span class="comment">;</span></span><br><span class="line"><span class="built_in">context</span>.drawImage(img, sx, sy, <span class="keyword">sWidth, </span><span class="keyword">sHeight, </span>dx, dy, dWidth, dHeight)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>后面最复杂的语法虽然看上去有9大参数，但不用慌，实际上可以看出就3个参数：</p><p><strong>img</strong></p><p>就是图片对象，可以是页面上获取的DOM对象，也可以是虚拟DOM中的图片对象。</p><p><strong>dx, dy, dWidth, dHeight</strong></p><p>表示在<code>canvas</code>画布上规划处一片区域用来放置图片，<code>dx, dy</code>为canvas元素的左上角坐标，<code>dWidth, dHeight</code>指canvas元素上用在显示图片的区域大小。如果没有指定<code>sx,sy,sWidth,sHeight</code>这4个参数，则图片会被拉伸或缩放在这片区域内。</p><p><strong>sx,sy,swidth,sheight</strong></p><p>这4个坐标是针对图片元素的，表示图片在<code>canvas</code>画布上显示的大小和位置。<code>sx,sy</code>表示图片上<code>sx,sy</code>这个坐标作为左上角，然后往右下角的<code>swidth,sheight</code>尺寸范围图片作为最终在canvas上显示的图片内容。</p><p><code>drawImage()</code>方法有一个非常怪异的地方，大家一定要注意，那就是5参数和9参数里面参数位置是不一样的，这个和一般的API有所不同。一般API可选参数是放在后面。但是，这里的<code>drawImage()</code>9个参数时候，可选参数<code>sx,sy,swidth,sheight</code>是在前面的。如果不注意这一点，有些表现会让你无法理解。</p><p>下图为<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" target="_blank" rel="noopener">MDN</a>上原理示意：<br><img src="//image.zhangxinxu.com/image/blog/201711/Canvas_drawimage.jpg" alt="Canvas drawimage()原理示意"></p><p>对于本文的图片压缩，需要用的是是5个参数语法。举个例子，一张图片（假设图片对象是<code>img</code>）的原始尺寸是4000*3000，现在需要把尺寸限制为400*300大小，很简单，原理如下代码示意：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.createElement('canvas');</span><br><span class="line">var context = canvas.getContext('<span class="number">2</span>d');</span><br><span class="line">canvas.width = <span class="number">400</span>;</span><br><span class="line">canvas.height = <span class="number">300</span>;</span><br><span class="line"><span class="comment">// 核心JS就这个</span></span><br><span class="line">context.drawImage(img,<span class="number">0</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><p>把一张大的图片，直接画在一张小小的画布上。此时大图片就天然变成了小图片，压缩就这么实现了，是不是简单的有点超乎想象。</p><p>当然，若要落地于实际开发，我们还需要做些其他的工作，就是要解决图片来源和图片去向的问题。</p><h4 id="1-如何把系统中图片呈现在浏览器中？"><a href="#1-如何把系统中图片呈现在浏览器中？" class="headerlink" title="1. 如何把系统中图片呈现在浏览器中？"></a>1. 如何把系统中图片呈现在浏览器中？</h4><p>HTML5 file API可以让图片在上传之前直接在浏览器中显示，通常使用<code>FileReader</code>方法，代码示意如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(), img = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="comment">// 读文件成功的回调</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// e.target.result就是图片的base64地址信息</span></span><br><span class="line">  img.src = e.target.result;</span><br><span class="line">&#125;;</span><br><span class="line">eleFile.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span><br><span class="line">    reader.readAsDataURL(event.target.files\[<span class="number">0</span>\]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>于是，包含图片信息的<code>context.drawImage()</code>方法中的<code>img</code>图片就有了。</p><p><strong>2. 如果把canvas画布转换成img图像</strong><br><code>canvas</code>天然提供了2个转图片的方法，一个是：</p><p><strong>canvas.toDataURL()方法</strong></p><p>语法如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span>.toDataURL(mimeType, qualityArgument)</span><br></pre></td></tr></table></figure></p><p>可以把图片转换成base64格式信息，纯字符的图片表示法。</p><p>其中：<br><code>mimeType</code>表示<code>canvas</code>导出来的<code>base64</code>图片的类型，默认是png格式，也即是默认值是<code>&#39;image/png&#39;</code>，我们也可以指定为jpg格式<code>&#39;image/jpeg&#39;</code>或者webp等格式。<code>file</code>对象中的<code>file.type</code>就是文件的mimeType类型，在转换时候正好可以直接拿来用（如果有file对象）。<br><code>qualityArgument</code>表示导出的图片质量，只要导出为<code>jpg</code>和<code>webp</code>格式的时候此参数才有效果，默认值是<code>0.92</code>，是一个比较合理的图片质量输出参数，通常情况下，我们无需再设定。</p><p><strong>canvas.toBlob()方法</strong></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob" target="_blank" rel="noopener">语法</a>如下：</p><p>canvas.toBlob(callback, mimeType, qualityArgument)</p><p>可以把canvas转换成<a href="http://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/" target="_blank" rel="noopener">Blob文件</a>，通常用在文件上传中，因为是二进制的，对后端更加友好。</p><p>和<code>toDataURL()</code>方法相比，<code>toBlob()</code>方法是异步的，因此多了个<code>callback</code>参数，这个<code>callback</code>回调方法默认的第一个参数就是转换好的<code>blob</code>文件信息，本文demo的文件上传就是将<code>canvas</code>图片转换成二进制的<code>blob</code>文件，然后再<code>ajax</code>上传的，代码如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// canvas转为blob并上传</span><br><span class="line">canvas.toBlob(function (blob) &#123;</span><br><span class="line">  // 图片ajax上传</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line">  // 开始上传</span><br><span class="line">  xhr.open(<span class="string">"<span class="keyword">POST</span>"</span>, 'upload.php', true);</span><br><span class="line">  xhr.send(blob);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>于是，经过“图片→canvas压缩→图片”三步曲，我们完成了图片前端压缩并上传的功能。</p><p>更加完整的核心代码请参见<a href="http://www.zhangxinxu.com/study/201707/js-compress-image-before-upload.html" target="_blank" rel="noopener">demo页面</a>的左侧，如果对其他交互代码也敢兴趣，请参考页面源代码。</p><p>下面贴出完整代码：</p><p><strong>HTML代码：</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="attribute">id</span>=<span class="string">"file"</span> <span class="attribute">type</span>=<span class="string">"file"</span>&gt;</span><br></pre></td></tr></table></figure></p><p><strong>JS代码：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eleFile = <span class="built_in">document</span>.querySelector(<span class="string">'#file'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩图片需要的一些元素和对象</span></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(), img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择的文件对象</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放图片需要的canvas</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// base64地址图片加载完毕后</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 图片原始尺寸</span></span><br><span class="line">    <span class="keyword">var</span> originWidth = <span class="keyword">this</span>.width;</span><br><span class="line">    <span class="keyword">var</span> originHeight = <span class="keyword">this</span>.height;</span><br><span class="line">    <span class="comment">// 最大尺寸限制</span></span><br><span class="line">    <span class="keyword">var</span> maxWidth = <span class="number">400</span>, maxHeight = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 目标尺寸</span></span><br><span class="line">    <span class="keyword">var</span> targetWidth = originWidth, targetHeight = originHeight;</span><br><span class="line">    <span class="comment">// 图片尺寸超过400x400的限制</span></span><br><span class="line">    <span class="keyword">if</span> (originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123;</span><br><span class="line">        <span class="keyword">if</span> (originWidth / originHeight &gt; maxWidth / maxHeight) &#123;</span><br><span class="line">            <span class="comment">// 更宽，按照宽度限定尺寸</span></span><br><span class="line">            targetWidth = maxWidth;</span><br><span class="line">            targetHeight = <span class="built_in">Math</span>.round(maxWidth * (originHeight / originWidth));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetHeight = maxHeight;</span><br><span class="line">            targetWidth = <span class="built_in">Math</span>.round(maxHeight * (originWidth / originHeight));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// canvas对图片进行缩放</span></span><br><span class="line">    canvas.width = targetWidth;</span><br><span class="line">    canvas.height = targetHeight;</span><br><span class="line">    <span class="comment">// 清除画布</span></span><br><span class="line">    context.clearRect(<span class="number">0</span>, <span class="number">0</span>, targetWidth, targetHeight);</span><br><span class="line">    <span class="comment">// 图片压缩</span></span><br><span class="line">    context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, targetWidth, targetHeight);</span><br><span class="line">    <span class="comment">// canvas转为blob并上传</span></span><br><span class="line">    canvas.toBlob(<span class="function"><span class="keyword">function</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 图片ajax上传</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="comment">// 文件上传成功</span></span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">// xhr.responseText就是返回的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开始上传</span></span><br><span class="line">        xhr.open(<span class="string">"POST"</span>, <span class="string">'upload.php'</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.send(blob);    </span><br><span class="line">    &#125;, file.type || <span class="string">'image/png'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件base64化，以便获知图片原始尺寸</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    img.src = e.target.result;</span><br><span class="line">&#125;;</span><br><span class="line">eleFile.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    file = event.target.files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 选择的文件是图片</span></span><br><span class="line">    <span class="keyword">if</span> (file.type.indexOf(<span class="string">"image"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        reader.readAsDataURL(file);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h3><p>就在几个月前刚写过一篇文章“<a href="http://www.zhangxinxu.com/wordpress/?p=6165" target="_blank" rel="noopener">使用canvas在前端实现图片水印合成</a>”，实际上所使用的技术和套路和本文是如出一辙的，也是“图片→canvas水印→图片”三步曲，区别在于水印合成是连续执行两次<code>context.drawImage()</code>方法，一次是原图一次水印图片，以及最后转换成图片的时候什么是<code>toDataURL()</code>方法，其他代码逻辑和原理都是一样的。</p><p>由此及彼，利用同样的原理和代码逻辑，我们还可以实现其它很多以前前端不太好实现的功能，比方说图片的真剪裁效果，所谓“真剪裁”指不是使用个<code>overflow:hidden</code>或者<code>clip</code>这些CSS属性的“伪剪裁”，而是真正意义上就这么大区域图片信息。甚至配合一些前端算法，我们可以直接在前端进行人脸识别，图片自动美化等一系列功能再上传等等。</p><p>原理都是一样的，都是利用<code>canvas</code>作为中间媒介进行处理。</p><p>好，以上就是本文的全部内容，感谢阅读，欢迎纠错，欢迎交流！</p><p><img src="//image.zhangxinxu.com/image/blog/201611/14.png" alt=""></p><p>本文为原创文章，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。<br>本文地址：<a href="http://www.zhangxinxu.com/wordpress/?p=6308" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=6308</a></p><p>相关文章</p><ul><li><a href="https://www.zhangxinxu.com/wordpress/2013/11/xmlhttprequest-ajax-localstorage-%e6%96%87%e4%bb%b6%e6%96%ad%e7%82%b9%e7%bb%ad%e4%bc%a0/" target="_blank" rel="noopener">XMLHttpRequest实现HTTP协议下文件上传断点续传</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2015/11/html-input-type-file/" target="_blank" rel="noopener">HTML input type=file文件选择表单元素二三事</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2018/05/js-custom-gif-generate/" target="_blank" rel="noopener">纯前端实现可传图可字幕台词定制的GIF表情生成器</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2018/03/js-parse-text-file/" target="_blank" rel="noopener">小tips: 纯前端JS读取与解析本地文本类文件</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2009/11/ajax-upload%e5%a4%9a%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e6%8f%92%e4%bb%b6%e7%bf%bb%e8%af%91%e5%8f%8a%e4%b8%ad%e6%96%87%e6%bc%94%e7%a4%ba/" target="_blank" rel="noopener">Ajax Upload多文件上传插件翻译及中文演示</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/" target="_blank" rel="noopener">理解DOMString、Document、FormData、Blob、File、ArrayBuffer数据类型</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2011/09/%e5%9f%ba%e4%ba%8ehtml5%e7%9a%84%e5%8f%af%e9%a2%84%e8%a7%88%e5%a4%9a%e5%9b%be%e7%89%87ajax%e4%b8%8a%e4%bc%a0/" target="_blank" rel="noopener">基于HTML5的可预览多图片Ajax上传</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/05/canvas-picture-watermark-synthesis/" target="_blank" rel="noopener">小tips:使用canvas在前端实现图片水印合成</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2018/08/js-base64-atob-btoa-encode-decode/" target="_blank" rel="noopener">原来浏览器原生支持JS Base64编码解码</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/07/js-text-string-download-as-html-json-file/" target="_blank" rel="noopener">小tip:JS前端创建html或json文件并浏览器导出下载</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/08/svg-foreignobject/" target="_blank" rel="noopener">SVG <foreignobject>简介与截图等应用</foreignobject></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by &lt;a href=&quot;http://www.zhangxinxu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zhangxinxu&lt;/a&gt; from &lt;a href=&quot;http://www.zhangxinxu.com/wordpress/?p=6308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.zhangxinxu.com/wordpress/?p=6308&lt;/a&gt;&lt;br&gt;本文可全文转载，但需得到原作者书面许可，同时保留原作者和出处，摘要引流则随意。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://yfzhou.coding.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="https://yfzhou.coding.me/tags/HTML/"/>
    
      <category term="file" scheme="https://yfzhou.coding.me/tags/file/"/>
    
      <category term="canvas" scheme="https://yfzhou.coding.me/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>在HTML在线预览PDF、word、xls、ppt等文件</title>
    <link href="https://yfzhou.coding.me/2018/08/09/%E5%9C%A8HTML%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88PDF%E3%80%81word%E3%80%81xls%E3%80%81ppt%E7%AD%89%E6%96%87%E4%BB%B6/"/>
    <id>https://yfzhou.coding.me/2018/08/09/在HTML在线预览PDF、word、xls、ppt等文件/</id>
    <published>2018-08-09T11:04:48.000Z</published>
    <updated>2018-08-15T01:17:52.322Z</updated>
    
    <content type="html"><![CDATA[<p>最近应工作需求html预览pdf和word，一些所涉功能知识记录一下,其他教程写得太老了，可能到如今已经不再适用。</p><a id="more"></a><h2 id="html实现pdf文件在线预览功能"><a href="#html实现pdf文件在线预览功能" class="headerlink" title="html实现pdf文件在线预览功能"></a>html实现pdf文件在线预览功能</h2><h3 id="方式一、-lt-a-gt-标签"><a href="#方式一、-lt-a-gt-标签" class="headerlink" title="方式一、&lt;a&gt;标签"></a>方式一、<code>&lt;a&gt;</code>标签</h3><p>pdf文件理论上可以在浏览器直接打开预览但是需要打开新页面。在仅仅是预览pdf文件且UI要求不高的情况下可以直接通过a标签href属性实现预览<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"文档地址"</span>&gt;</span>预览pdf<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="方式二、jquery-media-js"><a href="#方式二、jquery-media-js" class="headerlink" title="方式二、jquery.media.js"></a>方式二、jquery.media.js</h3><p>通过jquery插件<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fmalsup%2Fmedia%2Fblob%2Fmaster%2Fjquery.media.js" target="_blank" rel="noopener">jquery.media.js</a>实现</p><p>这个插件可以实现pdf预览功能（包括其他各种<a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.jb51.net%2Farticle%2F58724.htm" target="_blank" rel="noopener">媒体文件</a>）但是对word等类型的文件无能为力。</p><p>实现方式：</p><p>js代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”</span> <span class="attr">src</span>=<span class="string">”jquery-1.7.1.min.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”</span> <span class="attr">src</span>=<span class="string">”jquery.media.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>html结构：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"handout_wrap_inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>调用方式：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#handout_wrap_inner'</span>).media(&#123;</span><br><span class="line">  <span class="built_in">width</span>: <span class="string">'100%'</span>,</span><br><span class="line">  <span class="built_in">height</span>: <span class="string">'100%'</span>,</span><br><span class="line">  autoplay: <span class="keyword">true</span>,</span><br><span class="line">  src:<span class="string">'http://storage.xuetangx.com/public_assets/xuetangx/PDF/PlayerAPI_v1.0.6.pdf'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="方式三、-lt-iframe-gt-标签"><a href="#方式三、-lt-iframe-gt-标签" class="headerlink" title="方式三、&lt;iframe&gt;标签"></a>方式三、<code>&lt;iframe&gt;</code>标签</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$("<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">'previewUrl'</span> <span class="attr">width</span>=<span class="string">'100%'</span> <span class="attr">height</span>=<span class="string">'100%'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>").append($('body'))</span><br></pre></td></tr></table></figure><p>此外还可以在<code>iframe</code>标签之间提供一个提示类似这样<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"previewUrl"</span> width=<span class="string">"100%"</span> height=<span class="string">"100%"</span>&gt;</span><br><span class="line">  This browser does <span class="keyword">not</span> support PDFs. </span><br><span class="line">  Please download <span class="keyword">the</span> PDF <span class="built_in">to</span> view <span class="keyword">it</span>: </span><br><span class="line">  &lt;<span class="keyword">a</span> href=<span class="string">"previewUrl"</span>&gt;Download PDF&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><h3 id="方式四、-lt-embed-gt-标签"><a href="#方式四、-lt-embed-gt-标签" class="headerlink" title="方式四、&lt;embed&gt;标签"></a>方式四、<code>&lt;embed&gt;</code>标签</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;embed <span class="attribute">src</span>=<span class="string">"previewUrl"</span> <span class="attribute">type</span>=<span class="string">"application/pdf"</span> <span class="attribute">width</span>=<span class="string">"100%"</span> <span class="attribute">height</span>=<span class="string">"100%"</span>&gt;</span><br></pre></td></tr></table></figure><p>此标签h5特性中包含四个属性：高、宽、类型、预览文件src！<br>与<code>&lt;iframe&gt;&lt;/iframe&gt;</code>不同，这个标签是自闭合的的，也就是说如果浏览器不支持PDF的嵌入，那么这个标签的内容什么都看不到！</p><h3 id="方式五、-lt-object-gt-标签"><a href="#方式五、-lt-object-gt-标签" class="headerlink" title="方式五、&lt;object&gt;标签"></a>方式五、<code>&lt;object&gt;</code>标签</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;object src=<span class="string">"previewUrl"</span> width=<span class="string">"100%"</span> height=<span class="string">"100%"</span>&gt;</span><br><span class="line">  This browser does <span class="keyword">not</span> support PDFs. </span><br><span class="line">  Please download <span class="keyword">the</span> PDF <span class="built_in">to</span> view <span class="keyword">it</span>: </span><br><span class="line">  &lt;<span class="keyword">a</span> href=<span class="string">"previewUrl"</span>&gt;Download PDF&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line">&lt;/object&gt;</span><br></pre></td></tr></table></figure><blockquote><p>除方式二以外其他都是直接通过标签将内容引入页面实现预览</p></blockquote><h3 id="方式六、PDFObject"><a href="#方式六、PDFObject" class="headerlink" title="方式六、PDFObject"></a>方式六、PDFObject</h3><p>PDFObject实际上也是通过<code>&lt;embed&gt;</code>标签实现的直接上代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Show PDF<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'pdfobject.min.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-id">#pdf_viewer</span>&#123;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="undefined">            margin: 0;</span></span><br><span class="line"><span class="undefined">            padding: 0;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pdf_viewer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(PDFObject.supportsPDFs)&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// PDF嵌入到网页</span></span></span><br><span class="line"><span class="actionscript">        PDFObject.embed(<span class="string">"index.pdf"</span>, <span class="string">"#pdf_viewer"</span> );</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        location.href = <span class="string">"/canvas"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>还可以通过以下代码进行判断是否支持PDFObject预览<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(PDFObject.supportsPDFs)&#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="string">"Yay, this browser supports inline PDFs."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   console.<span class="built_in">log</span>(<span class="string">"Boo, inline PDFs are not supported by this browser"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="方式七、PDF-js"><a href="#方式七、PDF-js" class="headerlink" title="方式七、PDF.js"></a>方式七、PDF.js</h3><p>PDF.js可以实现在html下直接浏览pdf文档，是一款开源的pdf文档读取解析插件，非常强大，能将PDF文件渲染成Canvas。PDF.js主要包含两个库文件，一个pdf.js和一个pdf.worker.js，一个负责API解析，一个负责核心解析。</p><h2 id="word、xls、ppt文件在线预览功能"><a href="#word、xls、ppt文件在线预览功能" class="headerlink" title="word、xls、ppt文件在线预览功能"></a>word、xls、ppt文件在线预览功能</h2><p>word、ppt、xls文件实现在线预览的方式比较简单可以直接通过调用微软的在线预览功能实现 (预览前提：资源必须是公共可访问的)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">iframe</span> src=<span class="string">'https://view.officeapps.live.com/op/view.aspx?src=http://storage.xuetangx.com/public_assets/xuetangx/PDF/1.xls'</span> <span class="attribute">width</span>=<span class="string">'100%'</span> height=<span class="string">'100%'</span> frameborder=<span class="string">'1'</span>&gt;</span><br><span class="line">&lt;/iframe</span><br></pre></td></tr></table></figure></p><p>src就是要实现预览的文件地址</p><p>具体文档看这<a href="https://link.jianshu.com?t=https%3A%2F%2Fblogs.office.com%2Fen-us%2F2013%2F04%2F10%2Foffice-web-viewer-view-office-documents-in-a-browser%2F%3Feu%3Dtrue" target="_blank" rel="noopener">微软接口文档</a></p><h2 id="word文件"><a href="#word文件" class="headerlink" title="word文件"></a>word文件</h2><p><a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.xdocin.com%2Fweb.html%23func" target="_blank" rel="noopener">XDOC</a>可以实现预览以<a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fchenjiaxiang520%2Farticle%2Fdetails%2F53891544" target="_blank" rel="noopener">DataURI</a>表示的DOC文档，此外XDOC还可以实现文本、带参数文本、html文本、json文本、公文等在线预览，具体实现方法请看官方文档</p><p>下面这种方式可以实现快速预览word但是对文件使用的编辑器可能会有一些限制<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"http://www.xdocin.com/xdoc?_func=to&amp;amp;_format=html&amp;amp;_cache=1&amp;amp;_xdoc=http://www.xdocin.com/demo/demo.docx"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span> <span class="attribute">rel</span>=<span class="string">"nofollow"</span>&gt;XDOC&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近应工作需求html预览pdf和word，一些所涉功能知识记录一下,其他教程写得太老了，可能到如今已经不再适用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://yfzhou.coding.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="https://yfzhou.coding.me/tags/HTML/"/>
    
      <category term="js" scheme="https://yfzhou.coding.me/tags/js/"/>
    
      <category term="office" scheme="https://yfzhou.coding.me/tags/office/"/>
    
      <category term="pdf" scheme="https://yfzhou.coding.me/tags/pdf/"/>
    
      <category term="word" scheme="https://yfzhou.coding.me/tags/word/"/>
    
      <category term="xls" scheme="https://yfzhou.coding.me/tags/xls/"/>
    
      <category term="ppt" scheme="https://yfzhou.coding.me/tags/ppt/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（主题内加入动态背景）</title>
    <link href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E5%86%85%E5%8A%A0%E5%85%A5%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/08/Hexo-Next搭建个人博客（主题内加入动态背景）/</id>
    <published>2018-08-08T08:48:48.000Z</published>
    <updated>2018-08-08T09:19:19.690Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何给Blog主题添加静态背景和动态背景特效</p><a id="more"></a><h4 id="添加静态背景"><a href="#添加静态背景" class="headerlink" title="添加静态背景"></a>添加静态背景</h4><ol><li>打开博客根目录/themes/next/source/css/_custom/custom.styl文件，编辑如下：</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Custom styles.</span></span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line"><span class="attribute">background-image</span>: url(/images/background.png);</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; <span class="comment">// 不随屏幕滚动而滚动</span></span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat; <span class="comment">// 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺</span></span><br><span class="line"><span class="comment">//background-size: contain; // 等比例铺满屏幕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将背景图命名为background.png并放入主题根目录/images下</li></ol><h4 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h4><h1 id="layout-swig"><a href="#layout-swig" class="headerlink" title="_layout.swig"></a><a href="#layout-swig" title="_layout.swig"></a>_layout.swig</h1><p>找到<code>themes\next\layout\_layout.swig</code>文件，添加内容：<br>在<code>&lt;body&gt;</code>里添加：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"bg_content"</span>&gt;</span><br><span class="line">  &lt;canvas id=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>仍是该文件，在末尾添加：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/dynamic_bg.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-bg-js"><a href="#dynamic-bg-js" class="headerlink" title="dynamic_bg.js"></a><a href="#dynamic-bg-js" title="dynamic_bg.js"></a>dynamic_bg.js</h1><p>在<code>themes\next\source\js\src</code>中新建文件<code>dynamic_bg.js</code>，代码链接中可见：<a href="https://github.com/asdfv1929/asdfv1929.github.io/blob/master/js/src/dynamic_bg.js" target="_blank" rel="noopener">dynamic_bg.js</a></p><h1 id="custom-styl"><a href="#custom-styl" class="headerlink" title="custom.styl"></a><a href="#custom-styl" title="custom.styl"></a>custom.styl</h1><p>在<code>themes\next\source\css\_custom\custom.styl</code>文件末尾添加内容：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg_content</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍如何给Blog主题添加静态背景和动态背景特效&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（添加网页音乐播放器功能）</title>
    <link href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/08/Hexo-Next搭建个人博客（添加网页音乐播放器功能）/</id>
    <published>2018-08-08T08:38:02.000Z</published>
    <updated>2018-08-15T03:51:04.598Z</updated>
    
    <content type="html"><![CDATA[<p>为博客添加网页音乐播放器功能  </p><p>效果图：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/music01.png" alt=""></p><a id="more"></a><h1 id="download"><a href="#download" class="headerlink" title="download"></a><a href="#download" title="download"></a>download</h1><p>点击访问Aplayer源码：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">GitHub Aplayer</a>。下载到本地，解压后将<code>dist</code>文件夹复制到<code>themes\next\source</code>文件夹下。</p><h1 id="music-js"><a href="#music-js" class="headerlink" title="music.js"></a><a href="#music-js" title="music.js"></a>music.js</h1><p>新建<code>themes\next\source\dist\music.js</code>文件，添加内容：  </p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const ap = new APlayer(&#123;</span><br><span class="line">    <span class="attribute">container</span>: document<span class="variable">.getElementById</span>('aplayer'),</span><br><span class="line">    fixed: true,</span><br><span class="line">    autoplay: false,</span><br><span class="line">    audio: [</span><br><span class="line">&#123;</span><br><span class="line">        name: "canon in d",</span><br><span class="line">        artist: 'Brian Crain',</span><br><span class="line">        url: 'http://pd2tflnys<span class="variable">.bkt</span><span class="variable">.clouddn</span><span class="variable">.com</span>/Brian%20Crain%20-%20canon%20in%20d<span class="variable">.mp</span>3',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/QGb9Vtyw7qHS00uEvPfM6g==/843325418547559<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        name: "Apologize",</span><br><span class="line">        artist: 'Martin Ermen',</span><br><span class="line">        url: 'http://pd2tflnys<span class="variable">.bkt</span><span class="variable">.clouddn</span><span class="variable">.com</span>/Martin%20Ermen%20-%20Apologize<span class="variable">.mp</span>3',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/-_6mcI4VV5IKaiwhUAytbg==/1791104441647901<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        name: "River Flows in You",</span><br><span class="line">        artist: 'Yiruma',</span><br><span class="line">        url: 'http://pd2tflnys<span class="variable">.bkt</span><span class="variable">.clouddn</span><span class="variable">.com</span>/Yiruma%20-%20River%20Flows%20in%20You<span class="variable">.flac</span>',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/8ZRSyI0ZN_4ah8uzsNd1mA==/2324367581169008<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: '惊蛰',</span><br><span class="line">        artist: '音阙诗听/王梓钰',</span><br><span class="line">        url: 'http://www<span class="variable">.ytmp</span>3<span class="variable">.cn</span>/down/48755<span class="variable">.mp</span>3',</span><br><span class="line">        cover: 'http://p1<span class="variable">.music</span>.126<span class="variable">.net</span>/5MmXpaP9r88tNzExPGMI8Q==/109951163370350985<span class="variable">.jpg</span>?param=130y130',</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>源码中对应的参数解释，这边都有： <a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">Aplayer 中文文档</a></p><p><code>audio</code>对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：<a href="http://up.mcyt.net/" target="_blank" rel="noopener">http://up.mcyt.net/</a> ，搜索对应的音乐，然后复制<code>url</code>和右击封面图片链接粘贴到对应的位置上就行了。</p><p>注：由于该外链网站没有歌词链接，我这边没有进行配置，所以播放器在播放音乐时点击歌词是没有显示的。</p><h1 id="layout-swig"><a href="#layout-swig" class="headerlink" title="_layout.swig"></a><a href="#layout-swig" title="_layout.swig"></a>_layout.swig</h1><p>打开<code>themes\next\layout\_layout.swig</code>文件，将<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/dist/APlayer.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/dist/music.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>添加到<code>&lt;body itemscope ...&gt;</code>后面就行，即在<code>&lt;body&gt;&lt;/body&gt;</code>里面。</p><p>重新生成，访问页面，就能看到左下角的音乐播放器了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为博客添加网页音乐播放器功能  &lt;/p&gt;
&lt;p&gt;效果图：&lt;br&gt;&lt;img src=&quot;https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/music01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（添加统计访客量以及文章阅读量）</title>
    <link href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/08/Hexo-Next搭建个人博客（添加统计访客量以及文章阅读量）/</id>
    <published>2018-08-08T01:04:37.000Z</published>
    <updated>2018-08-15T03:50:25.881Z</updated>
    
    <content type="html"><![CDATA[<p>使用不蒜子和Lean Cloud给文章添加阅读量和统计访客功能</p><a id="more"></a><h2 id="不蒜子统计功能"><a href="#不蒜子统计功能" class="headerlink" title="不蒜子统计功能"></a>不蒜子统计功能</h2><p>NexT主题集成了不蒜子统计功能,以下为我的配置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only <span class="keyword">if</span> the other configs are <span class="literal">false</span></span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  # custom uv span <span class="keyword">for</span> the whole site</span><br><span class="line">  site_uv: <span class="literal">true</span></span><br><span class="line">  site_uv_header: &lt;i <span class="attribute">class</span>=<span class="string">"fa fa-user"</span>&gt;&lt;/i&gt;</span><br><span class="line">  site_uv_footer: 人次</span><br><span class="line">  # custom pv span <span class="keyword">for</span> the whole site</span><br><span class="line">  site_pv: <span class="literal">true</span></span><br><span class="line">  site_pv_header: &lt;i <span class="attribute">class</span>=<span class="string">"fa fa-eye"</span>&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span <span class="keyword">for</span> one<span class="built_in"> page </span>only</span><br><span class="line">  page_pv: <span class="literal">true</span></span><br><span class="line">  page_pv_header: &lt;i <span class="attribute">class</span>=<span class="string">"fa fa-file-o"</span>&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure></p><p>当<code>enable: true</code>时，代表开启全局开关。若s<code>ite_uv、site_pv、page_pv</code>的值均为<code>false</code>时，不蒜子仅作记录而不会在页面上显示。<br>当<code>site_uv: true</code>时，代表在页面底部显示站点的UV值。<br>当<code>site_pv: true</code>时，代表在页面底部显示站点的PV值。<br>当<code>page_pv: true</code>时，代表在文章页面的标题下显示该页面的PV值（阅读数）。<br><code>site_uv_header</code>和<code>site_uv_footer</code>这几个为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。 </p><p>效果图：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/read02.png" alt=""><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/read01.png" alt=""></p><h2 id="LeanCloud阅读次数统计"><a href="#LeanCloud阅读次数统计" class="headerlink" title="LeanCloud阅读次数统计"></a>LeanCloud阅读次数统计</h2><p>首先一句话介绍Lean Cloud:</p><blockquote><p><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>（aka. AVOS Cloud）提供一站式后端云服务，从数据存储、实时聊天、消息推送到移动统计，涵盖应用开发的多方面后端需求。</p></blockquote><p>相比不蒜子的统计，LeanCloud的文章阅读量统计更加稳定靠谱，所以本人也把网站的文章内统计改为LeanCloud的了。</p><h3 id="配置LeanCloud"><a href="#配置LeanCloud" class="headerlink" title="配置LeanCloud"></a><a href="#配置LeanCloud" title="配置LeanCloud"></a>配置<a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a></h3><p>在注册完成LeanCloud帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到<code>AppID</code>以及<code>AppKey</code>这两个参数即可正常使用文章阅读量统计的功能了。</p><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a><a href="#创建应用" title="创建应用"></a>创建应用</h4><ul><li>我们新建一个应用来专门进行博客的访问统计的数据操作。首先，打开控制台，如下图所示：</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/open_consoloe.png" alt="" title="打开控制台"></p><ul><li>在出现的界面点击<code>创建应用</code>：</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/create_app.png" alt="" title="创建应用"></p><ul><li>在接下来的页面，新建的应用名称我们可以随意输入，即便是输入的不满意我们后续也是可以更改的:</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/creating_app.png" alt="" title="创建的新应用名称"></p><ul><li>这里为了演示的方便，我新创建一个取名为test的应用。创建完成之后我们点击新创建的应用的名字来进行该应用的参数配置：</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/create_class.png" alt="" title="打开应用参数配置界面"></p><ul><li>在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。点击左侧右上角的齿轮图标，新建Class：<br>在弹出的选项中选择<code>创建Class</code>来新建Class用来专门保存我们博客的文章访问量等数据:<br>点击<code>创建Class</code>之后，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证我们前面对NexT主题的修改兼容，此处的<strong>新建Class名字必须为<code>Counter</code></strong>:</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/creating_class.png" alt="" title="权限配置"></p><ul><li>由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择<code>无限制</code>。</li></ul><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/open_app_key.png" alt="" title="打开应用设置"></p><p>创建完成之后，左侧数据栏应该会多出一栏名为<code>Counter</code>的栏目，这个时候我们点击顶部的设置，切换到test应用的操作界面:<br>在弹出的界面中，选择左侧的<code>应用Key</code>选项，即可发现我们创建应用的<code>AppID</code>以及<code>AppKey</code>，有了它，我们就有权限能够通过主题中配置好的Javascript代码与这个应用的Counter表进行数据存取操作了:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/opened_app_key.png" alt="" title="获取Appid、Appkey"></p><p>复制<code>AppID</code>以及<code>AppKey</code>并在NexT主题的<code>_config.yml</code>文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span>  </span><br><span class="line"><span class="attr"> enable:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr"> app_id:</span> <span class="string">joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz</span>  </span><br><span class="line"><span class="attr"> app_key:</span> <span class="string">E9UJsJpw1omCHuS22PdSpKoh</span></span><br></pre></td></tr></table></figure><p>这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的<code>发布日期</code>以及<code>文章的标题</code>，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。</p><h3 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a><a href="#后台管理" title="后台管理"></a>后台管理</h3><p>当你配置部分完成之后，初始的文章统计量显示为0，但是这个时候我们LeanCloud对应的应用的<code>Counter</code>表中并没有相应的记录，只是单纯的显示为0而已，当博客文章在配置好阅读量统计服务之后第一次打开时，便会自动向服务器发送数据来创建一条数据，该数据会被记录在对应的应用的<code>Counter</code>表中。</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/read03.png" alt="" title="后台管理"></p><p>我们可以修改其中的<code>time</code>字段的数值来达到修改某一篇文章的访问量的目的（博客文章访问量快递提升人气的装逼利器）。双击具体的数值，修改之后回车即可保存。</p><ul><li><code>url</code>字段被当作唯一<code>ID</code>来使用，因此如果你不知道带来的后果的话请不要修改。</li><li><code>title</code>字段显示的是博客文章的标题，用于后台管理的时候区分文章之用，没有什么实际作用。</li><li>其他字段皆为自动生成，具体作用请查阅LeanCloud官方文档，如果你不知道有什么作用请不要随意修改。</li></ul><h3 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a><a href="#Web安全" title="Web安全"></a>Web安全</h3><p>因为AppID以及AppKey是暴露在外的，因此如果一些别用用心之人知道了之后用于其它目的是得不偿失的，为了确保只用于我们自己的博客，建议开启Web安全选项，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。</p><p>选择应用的设置的<code>安全中心</code>选项卡:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/open_safe_center.png" alt="" title="进入安全中心"></p><p>在<code>Web 安全域名</code>中填入我们自己的博客域名，来确保数据调用的安全:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/bind_domain.png" alt="" title="锁定域名"></p><p>如果你不知道怎么填写安全域名而或者填写完成之后发现博客文章访问量显示不正常，打开浏览器调试模式，发现如下图的输出:</p><p><img src="http://7xkj6q.com1.z0.glb.clouddn.com/static/images/leancloud-page-anlysis/broswer_403.png" alt="" title="Web安全域名填写错误"></p><p>这说明你的安全域名填写错误，导致服务器拒绝了数据交互的请求，你可以更改为正确的安全域名或者你不知道如何修改请在本博文中留言或者放弃设置Web安全域名。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用不蒜子和Lean Cloud给文章添加阅读量和统计访客功能&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（集成DaoVoice在线联系功能）</title>
    <link href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/08/Hexo-Next搭建个人博客（集成DaoVoice在线联系功能）/</id>
    <published>2018-08-08T00:56:39.000Z</published>
    <updated>2018-08-15T03:45:20.198Z</updated>
    
    <content type="html"><![CDATA[<p>之前有访问过一些大佬的个人博客，里面有个在线联系功能，看着不错，所以也试着在自己的站点上接入了此功能。  </p><a id="more"></a><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a><a href="#注册" title="注册"></a>注册</h1><p>首先在<a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a>注册个账号，点击-&gt;<a href="http://dashboard.daovoice.io/get-started?invite_code=b3c7d22e" target="_blank" rel="noopener">邀请码</a>是<code>b3c7d22e</code>。<br><a href="https://s1.ax1x.com/2018/01/21/pW5DRP.png" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/21/pW5DRP.png" alt="pW5DRP.png"></a></p><p>完成后，会得到一个<code>app_id</code>，后面会用到：<br><a href="https://s1.ax1x.com/2018/01/21/pW5yM8.png" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/21/pW5yM8.png" alt="appid"></a></p><h1 id="修改head-swig"><a href="#修改head-swig" class="headerlink" title="修改head.swig"></a><a href="#修改head-swig" title="修改head.swig"></a>修改head.swig</h1><p>修改<code>/themes/next/layout/_partials/head.swig</code>文件，添加内容如下：  </p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.daovoice %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">  (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")</span></span><br><span class="line"><span class="xml">  daovoice('init', &#123;</span></span><br><span class="line"><span class="xml">      app_id: "</span><span class="template-variable">&#123;&#123;theme.daovoice_app_id&#125;&#125;</span><span class="xml">"</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">  daovoice('update');</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>位置贴图：<br><a href="https://imgchr.com/i/pWIwmF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/21/pWIwmF.md.png" alt="pWIwmF.md.png"></a></p><h1 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a><a href="#主题配置文件" title="主题配置文件"></a>主题配置文件</h1><p>在<code>_config.yml</code>文件中添加内容：  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Online contact </span></span><br><span class="line"><span class="attr">daovoice:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">daovoice_app_id:</span> <span class="string">这里输入前面获取的app_id</span></span><br></pre></td></tr></table></figure><h1 id="聊天窗口配置"><a href="#聊天窗口配置" class="headerlink" title="聊天窗口配置"></a><a href="#聊天窗口配置" title="聊天窗口配置"></a>聊天窗口配置</h1><p>附上我的聊天窗口的颜色、位置等设置信息：<br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice01.png" alt=""></p><p>至此，网页的在线联系功能已经完成，重新<code>hexo d -g</code>上传GitHub后，页面上就能看到效果了。</p><p>效果图：</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice02.png?x-oss-process=style/w200" alt=""></p><p>可以关注小程序接收回复消息，很方便</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice03.png?x-oss-process=style/w200" alt=""><br><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/daovoice04.png?x-oss-process=style/w200" alt=""></p><p>现在往右下角看看(～￣▽￣)～ ，欢迎撩我（滑稽）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有访问过一些大佬的个人博客，里面有个在线联系功能，看着不错，所以也试着在自己的站点上接入了此功能。  &lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（集成LiveRe来必力文章评论功能）</title>
    <link href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90LiveRe%E6%9D%A5%E5%BF%85%E5%8A%9B%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/08/Hexo-Next搭建个人博客（集成LiveRe来必力文章评论功能）/</id>
    <published>2018-08-08T00:55:15.000Z</published>
    <updated>2018-08-15T03:48:32.668Z</updated>
    
    <content type="html"><![CDATA[<p>　　由于众所周知的原因，多说评论和网易云跟帖先后都宣布关闭评论服务，一直没有找到好的替换方案。昨天无意看到韩国的Livere（来必力）评论，瞬间就喜欢上了~UI好看，加载时候的那个小幽灵也好可爱=w=而且是国外的，应该没那么容易关闭吧2333下面记录一下步骤~  </p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><a href="#准备" title="准备"></a>准备</h2><ol><li>去<a href="https://livere.com/" target="_blank" rel="noopener">Livere官网</a>注册Livere账号。</li><li>选择City版（免费），安装</li><li>进入管理页面-&gt;代码管理-&gt;一般网站，复制data-uid</li></ol><h2 id="在Hexo中添加Livere"><a href="#在Hexo中添加Livere" class="headerlink" title="在Hexo中添加Livere"></a><a href="#在Hexo中添加Livere" title="在Hexo中添加Livere"></a>在Hexo中添加Livere</h2><p>以下基于主题Next，其他主题做法类似</p><ol><li>打开<code>博客根目录/themes/next/_config.yml</code></li><li><p>将# Third Party Services Settings 栏目下其他评论系统如duoshuo、gentie、youyan、disqus用#注释掉，加入以下内容</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Livere评论系统</span></span><br><span class="line">    livere_uid: 上一步中你获取的<span class="class"><span class="keyword">data</span>-uid</span></span><br></pre></td></tr></table></figure></li><li><p>在博客根目录<code>/themes/layout/_scripts/third-party/comments/</code>目录中新建txt文件，重命名为livere.swig，编辑内容如下：</p></li></ol><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.livere_uid %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">      (function(d, s) &#123;</span></span><br><span class="line"><span class="xml">        var j, e = d.getElementsByTagName(s)[0];</span></span><br><span class="line"><span class="xml">        if (typeof LivereTower === 'function') &#123; return; &#125;</span></span><br><span class="line"><span class="xml">        j = d.createElement(s);</span></span><br><span class="line"><span class="xml">        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';</span></span><br><span class="line"><span class="xml">        j.async = true;</span></span><br><span class="line"><span class="xml">        e.parentNode.insertBefore(j, e);</span></span><br><span class="line"><span class="xml">      &#125;)(document, 'script');</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>在<code>博客根目录/themes/layout/_scripts/third-party/comments.swig</code>文件中追加：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> './comments/livere.swig' %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></li><li><p>在博客根目录<code>/themes/layout/_partials/comments.swig</code>文件中条件最后追加 LiveRe 插件是否引用的判断逻辑：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">elseif</span> theme.livere_uid %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"lv-container"</span> <span class="attr">data-id</span>=<span class="string">"city"</span> <span class="attr">data-uid</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.livere_uid &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></li></ol><p>重新<code>hexo clean、hexo d -g</code>，然后就可以看到来必力评论啦~ </p><p>ps:因为是国外的，评论加载有点慢。 </p><h6 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/liveRe01.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　由于众所周知的原因，多说评论和网易云跟帖先后都宣布关闭评论服务，一直没有找到好的替换方案。昨天无意看到韩国的Livere（来必力）评论，瞬间就喜欢上了~UI好看，加载时候的那个小幽灵也好可爱=w=而且是国外的，应该没那么容易关闭吧2333下面记录一下步骤~  &lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（集成Algolia站内搜索引擎）</title>
    <link href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90Algolia%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/08/Hexo-Next搭建个人博客（集成Algolia站内搜索引擎）/</id>
    <published>2018-08-08T00:53:22.000Z</published>
    <updated>2018-08-15T03:34:05.846Z</updated>
    
    <content type="html"><![CDATA[<p>起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。 注：Algolia搜索在版本<strong> 5.1.0 </strong>中引入，要使用此功能请确保所使用的 NexT 版本在此之后</p><a id="more"></a><h2 id="首先注册Algolia账户"><a href="#首先注册Algolia账户" class="headerlink" title="首先注册Algolia账户"></a>首先注册Algolia账户</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.algolia.com%2Fusers%2Fsign_in" target="_blank" rel="noopener">Algolia 登陆页面https://www.algolia.com/users/sign_in</a> ，可以使用 GitHub 或者 Google 账户直接登录，也可以注册一个新账户。我直接用谷歌账户登陆了，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。</p><p>注册完成后，创建一个新的 Index，这个 index name 之后会用到<br><img src="https://upload-images.jianshu.io/upload_images/3899681-c00f0825ef763c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-algolia --save  <span class="comment"># 目前最新版本是1.2.5，下面的操作都是基于这个版本的文档</span></span><br></pre></td></tr></table></figure></p><h2 id="获取-Key，更新站点根目录配置"><a href="#获取-Key，更新站点根目录配置" class="headerlink" title="获取 Key，更新站点根目录配置"></a>获取 Key，更新站点根目录配置</h2><p><img src="http://www.qingpingshan.com/uploads/allimg/180511/1440043942-0.png" alt=""></p><p>前往站点根目录打开_config.yml添加以下代码<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algolia Search API Key</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line"><span class="attr">  applicationID:</span> <span class="string">'你的Application ID'</span></span><br><span class="line"><span class="attr">  apiKey:</span> <span class="string">'你的Search-Only API Key'</span></span><br><span class="line"><span class="attr">  adminApiKey:</span> <span class="string">'你的Admin API Key'</span></span><br><span class="line"><span class="attr">  indexName:</span> <span class="string">'输入刚才创建index name'</span></span><br><span class="line"><span class="attr">  chunkSize:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure></p><h2 id="修改Algolia搜索ACL（访问控制列表）"><a href="#修改Algolia搜索ACL（访问控制列表）" class="headerlink" title="修改Algolia搜索ACL（访问控制列表）"></a>修改Algolia搜索ACL（访问控制列表）</h2><p><img src="http://www.qingpingshan.com/uploads/allimg/180511/1440041313-1.png" alt=""></p><p>选中后保存。</p><h2 id="操作完成后去你的博客跟路径执行命令"><a href="#操作完成后去你的博客跟路径执行命令" class="headerlink" title="操作完成后去你的博客跟路径执行命令"></a>操作完成后去你的博客跟路径执行命令</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">HEXO_ALGOLIA_INDEXING_KEY</span>=你的Search-Only API Key</span><br></pre></td></tr></table></figure><p>查看是否设置成功如果没有值就设置失败<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo algolia</span></span><br></pre></td></tr></table></figure></p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia02.png" alt=""></p><h2 id="成功后修改Next主题配置文件"><a href="#成功后修改Next主题配置文件" class="headerlink" title="成功后修改Next主题配置文件"></a>成功后修改Next主题配置文件</h2><p>更改Next主题配置文件，找到 Algolia Search 配置部分：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Algolia Search</span></span><br><span class="line"><span class="symbol">algolia_search:</span></span><br><span class="line"><span class="symbol">  enable:</span> true</span><br><span class="line"><span class="symbol">  hits:</span></span><br><span class="line"><span class="symbol">    per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">  labels:</span></span><br><span class="line"><span class="symbol">    input_placeholder:</span> 输入关键字</span><br><span class="line"><span class="symbol">    hits_empty:</span> <span class="string">"没有找到与 $&#123;query&#125; 相关的内容"</span></span><br><span class="line"><span class="symbol">    hits_stats:</span> <span class="string">"$&#123;hits&#125;条相关记录，共耗时$&#123;time&#125; ms"</span></span><br></pre></td></tr></table></figure></p><p>将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。这个是我修改的文本。</p><p>最终效果</p><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia01.png" alt=""></p><h2 id="总结一下集成遇到的BUG"><a href="#总结一下集成遇到的BUG" class="headerlink" title="总结一下集成遇到的BUG"></a>总结一下集成遇到的BUG</h2><h6 id="Please-set-an-HEXO-ALGOLIA-INDEXING-KEY-environment-variable-to-enable-content-indexing"><a href="#Please-set-an-HEXO-ALGOLIA-INDEXING-KEY-environment-variable-to-enable-content-indexing" class="headerlink" title="Please set an HEXO_ALGOLIA_INDEXING_KEY environment variable to enable content indexing."></a>Please set an <code>HEXO_ALGOLIA_INDEXING_KEY</code> environment variable to enable content indexing.</h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia04.png" alt=""></p><p>原因：Algolia Search API Key indexName 错了</p><p>解决方案：看下之前新建index的名字</p><h6 id="Not-enough-rights-to-update-an-object-near-line-1-column-1635"><a href="#Not-enough-rights-to-update-an-object-near-line-1-column-1635" class="headerlink" title="Not enough rights to update an object near line:1 column:1635"></a>Not enough rights to update an object near line:1 column:1635</h6><p><img src="https://yfzhou.oss-cn-beijing.aliyuncs.com/blog/img/algolia03.png" alt=""></p><p>原因：没有修改Algolia搜索ACL（访问控制列表）</p><p>解决方案： 按步骤3勾选上就可以</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/fa2354d61e37" title="hexo+next添加algolia搜索" target="_blank" rel="noopener">《hexo+next添加algolia搜索》</a></li></ul><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ul><li><a href="https://www.npmjs.com/package/hexo-algolia" title="《hexo-algolia》" target="_blank" rel="noopener">《hexo-algolia》</a></li></ul><h2 id="更多教程可以来我yufeng-Zhou独立博客里面看到"><a href="#更多教程可以来我yufeng-Zhou独立博客里面看到" class="headerlink" title="更多教程可以来我yufeng.Zhou独立博客里面看到"></a>更多教程可以来我<a href="http://yfzhou.coding.me/">yufeng.Zhou</a>独立博客里面看到</h2><p><strong>转载请注明出处<a href="http://yfzhou.coding.me/">http://yfzhou.coding.me/</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。 注：Algolia搜索在版本&lt;strong&gt; 5.1.0 &lt;/strong&gt;中引入，要使用此功能请确保所使用的 NexT 版本在此之后&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（托管到Github和Coding）</title>
    <link href="https://yfzhou.coding.me/2018/08/07/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%89%98%E7%AE%A1%E5%88%B0Github%E5%92%8CCoding%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/07/Hexo-Next搭建个人博客（托管到Github和Coding）/</id>
    <published>2018-08-07T14:55:27.000Z</published>
    <updated>2018-08-07T15:15:51.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇很详细的独立博客搭建教程，意在帮助小白们能快速入门，拥有自己的独立博客。作者已在window平台已搭建成功，博客效果请点<a href="https://yfzhou.coding.me/">链接</a>查看。  </p><h3 id="为什么用Hexo搭建独立博客？"><a href="#为什么用Hexo搭建独立博客？" class="headerlink" title="为什么用Hexo搭建独立博客？"></a>为什么用Hexo搭建独立博客？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><a id="more"></a><h3 id="Github和Coding又是什么？"><a href="#Github和Coding又是什么？" class="headerlink" title="Github和Coding又是什么？"></a>Github和Coding又是什么？</h3><ul><li>Github是国外免费的Git代码托管平台。利用Github Page服务可以免费创建一个静态网站。</li><li>Coding则是国内Git代码托管平台。国内首个Git代码托管平台GitCafe已被Coding收购。也提供page服务。</li></ul><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/02.png" alt="GitCafe"></p><h3 id="为什么用两个代码托管平台？"><a href="#为什么用两个代码托管平台？" class="headerlink" title="为什么用两个代码托管平台？"></a>为什么用两个代码托管平台？</h3><p>很多人都把hexo托管到github上，因为github大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问coding比github是要快不少的。还可以利用域名解析实现国内的走coding，海外的走github，分流网站的访问。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><blockquote><p>Git是什么？<br>Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br>了解更多，参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">git教程</a></p></blockquote><ul><li><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">点击下载</a>，然后按默认选项安装即可。<img src="http://7xs5l8.com1.z0.glb.clouddn.com/00.png" alt="Bash"></li><li>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</li></ul><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/0.jpg" alt="命令窗口"></p><ul><li>安装完成后，还需要最后一步设置，在命令行输入<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></li></ul><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p><p><strong>注意</strong><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="将博客托管到Github和Coding上"><a href="#将博客托管到Github和Coding上" class="headerlink" title="将博客托管到Github和Coding上"></a>将博客托管到Github和Coding上</h3><h4 id="托管到github"><a href="#托管到github" class="headerlink" title="托管到github"></a>托管到github</h4><ul><li>注册github帐号<br>访问<a href="https://github.com/" target="_blank" rel="noopener">官网</a>注册,你的username和邮箱十分重要，GitHub上很多通知都是通过邮箱的。比如你的主页上传并构建成功会通过邮箱通知，更重要的是，如果构建失败的话也会在邮件中说明原因。</li><li>创建项目仓库<br>注册并登陆Github官网成功后，点击页面右上角的+，选择New repository。<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan20163281.png" alt="+"><br>在Repository name中填写Github账号名.github.io<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE02.png" alt="创建仓库"><br>点击Create repository，完成创建。</li></ul><h4 id="托管到coding"><a href="#托管到coding" class="headerlink" title="托管到coding"></a>托管到coding</h4><ul><li>注册coding帐号<br>访问<a href="https://coding.net/" target="_blank" rel="noopener">官网</a>注册并登录</li><li>创建仓库<br>点+创建项目<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE04.png" alt="+"><br>填写项目名称描述创建即可,<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan1637925-3cbdade49c4ed7ba.png" alt="创建"></li></ul><h4 id="配置SHH"><a href="#配置SHH" class="headerlink" title="配置SHH"></a>配置SHH</h4><p>配置shh key是让本地git项目与远程的github建立联系  </p><ul><li><p>检查是否已经有SSH Key，打开Git Bash，输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure></li><li><p>如果没有.ssh这个目录，则生成一个新的SSH，输入</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"your e-mail"</span></span><br></pre></td></tr></table></figure></li></ul><p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」  </p><ul><li>接下来几步都直接按回车键,然后系统会要你输入密码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="xml"><span class="tag">&lt;<span class="name">输入加密串</span>&gt;</span></span></span><br><span class="line"><span class="xml">Enter same passphrase again:<span class="tag">&lt;<span class="name">再次输入加密串</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><p>这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。<br>注意：输入密码的时候没有*字样的，你直接输入就可以了。  </p><ul><li>最后看到这样的界面，就成功设置ssh key了<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhanssh%20key.jpg" alt="ssh key"></li></ul><h4 id="添加-SSH-Key-到-GitHub和Coding"><a href="#添加-SSH-Key-到-GitHub和Coding" class="headerlink" title="添加 SSH Key 到 GitHub和Coding"></a>添加 SSH Key 到 GitHub和Coding</h4><ul><li><p>打开Git Bash，然后输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure></li><li><p>进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE05.png" alt=""></p></li><li>输入cat命令，打开id_rsa.pub文件<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cat</span> <span class="selector-tag">id_rsa</span><span class="selector-class">.pub</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE06.png" alt="">  </p><ul><li>再鼠标全选中右击复制  </li><li>再配置到GitHub和Coding的SSH中<br>进入Github官网，点击+旁边的头像，再按settings进入设置<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE07.png" alt=""><br>在点击New SSH key创建<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE08.png" alt=""><br>title输入邮箱，key里面粘贴刚才右击复制的内容,再点Add SSH key<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE10.png" alt=""><br>同样进入coding,点击账户，在点SSH公钥设置即可<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE11.png" alt=""></li></ul><h4 id="测试SSH是否配置成功"><a href="#测试SSH是否配置成功" class="headerlink" title="测试SSH是否配置成功"></a>测试SSH是否配置成功</h4><ul><li><p>打开Git Bash，然后输入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-T</span> <span class="selector-tag">git</span>@<span class="keyword">github</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure></li><li><p>如配置了密码则要输入密码,输完按回车<br>如果显示以下内容，则说明Github中的ssh配置成功。</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username<span class="comment">! You've successfully authenticated, but GitHub does not</span></span><br><span class="line"><span class="keyword">provide</span> shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure></li><li><p>再输入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-T</span> <span class="selector-tag">git</span>@<span class="keyword">git</span>.<span class="keyword">coding</span>.<span class="keyword">net</span></span><br></pre></td></tr></table></figure></li></ul><p>如果显示以下则说明coding中的ssh配置成功<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello username You've connected <span class="keyword">to</span> Coding.net <span class="keyword">by</span> SSH successfully!</span><br></pre></td></tr></table></figure></p><h4 id="创建Github-Pages和Coding-Pages-服务"><a href="#创建Github-Pages和Coding-Pages-服务" class="headerlink" title="创建Github Pages和Coding Pages 服务"></a>创建Github Pages和Coding Pages 服务</h4><ul><li>GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">更多</a></li><li>官网点击代码再点击Coding Pages 服务开启。分支和github分支写一样，填写master<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE13.png" alt=""></li></ul><h4 id="将博客网站上传到GitHub和Coding中"><a href="#将博客网站上传到GitHub和Coding中" class="headerlink" title="将博客网站上传到GitHub和Coding中"></a>将博客网站上传到GitHub和Coding中</h4><ul><li>打开D:\blog文件夹中的_config.yml文件，找到如下位置，填写</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span></span><br><span class="line"><span class="symbol">      github:</span> git@github.com:yourname/yourname.github.io.git,master</span><br><span class="line"><span class="symbol">      coding:</span> git@git.coding.net:yourname/yourname.git,master</span><br></pre></td></tr></table></figure><p><strong>注：</strong> (1) 其中yourname替换成你的Github账户名;(2)注意在yml文件中，:后面都是要带空格的。<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan%E6%88%AA%E5%9B%BE14.png" alt="">  </p><ul><li>在<strong>blog文件夹</strong>中空白处右击打开Git Bash输入<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure></li></ul><p>此时，通过访问<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a>和<a href="http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。" target="_blank" rel="noopener">http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。</a></p><h4 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h4><p>本网站使用的是Next主题。该主题简洁易用，在移动端也表现不错。  </p><ul><li><p>下载主题<br>在<strong>blog文件夹</strong>中空白处右击打开Git Bash输入</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure></li><li><p>修改网站的主题为Next<br>打开D:\blog下的_config.yml文件，找到theme字段，将其修改为next</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: http://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: http://hexo.io/themes/</span></span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></li><li><p>验证主题是否可用<br>输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo</span> s <span class="comment">#启动服务，调试用</span></span><br></pre></td></tr></table></figure></li></ul><p>再在浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>确认网站主题是否切换为Next.  </p><ul><li>博客blog根目录下的_config.yml配置网站信息<br>_config.yml配置请点<a href="https://github.com/xirong/hexo-theme-next/blob/master/_config_root.yml" target="_blank" rel="noopener">参考</a></li></ul><h3 id="注册及绑定自己的域名地址"><a href="#注册及绑定自己的域名地址" class="headerlink" title="注册及绑定自己的域名地址"></a>注册及绑定自己的域名地址</h3><h4 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h4><p>推荐选择国内的万网或者国外的Goddady进行域名的注册，注册完还需改下绑定DNS服务商</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>如果你选择的是万网注册的域名，可以使用其自带的域名解析服务。<br>也可以选择免费的<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a>  </p><ul><li>域名解析填写如下图<br><img src="http://7xs5l8.com1.z0.glb.clouddn.com/wangzhan1637925-bc9fbfb9af5e3b77.png" alt="">  </li><li>打开blog文件夹下的source文件夹，新建CNAME文件,内容填写自己的域名<br>CNAME文件设置的目的是，通过访问 yourname.github.io 可以跳转到你所注册的域名上。<br>github是直接项目里面加CNAME文件。coding是直接在项目主页设置的，去coding项目主页添加CNAME，绑定域名。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要按照上面步骤一步步设置，相信你也可以拥有自己的独立博客。希望此文对还在搭建hexo独立博客的小伙伴有所帮助。主题相关配置查看下面的，hexo和next帮助文档。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.jeyzhang.com/hexo-github-blog-building.html" target="_blank" rel="noopener">《Hexo+Github: 搭建属于自己的静态博客》</a></li><li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool" target="_blank" rel="noopener">《hexo你的博客》</a></li><li><a href="http://blog.shijinrong.cn/2016/01/03/2016-01-03-how-to-build-blog/" target="_blank" rel="noopener">《如何使用10个小时搭建出个人域名而又Geek的独立博客？》</a></li><li><a href="http://tengj.top/2016/03/06/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding/" target="_blank" rel="noopener">《将hexo博客同时托管到github和coding》</a></li><li><a href="https://segmentfault.com/q/1010000004557073?_ea=651524" target="_blank" rel="noopener">《个人域名如何同时绑定 github 和 coding 上的博客》</a></li><li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785/" target="_blank" rel="noopener">《如何搭建一个独立博客——简明Github Pages与Hexo教程》</a></li><li><a href="http://mousycoder.com/2015/10/19/classic-tutorial-of-hexo-blog/" target="_blank" rel="noopener">《「搭建Hexo博客」简明教程》</a></li><li><a href="http://www.ixirong.com/2015/05/17/how-to-build-ixirong-blog/" target="_blank" rel="noopener">《使用 github Pages 服务建立 ixirong.com 独立博客全过程》</a></li><li><a href="http://shenshanlaoyuan.com/" target="_blank" rel="noopener">深山老猿</a></li></ul><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">《Hexo文档》</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">《Next使用文档》</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《Git教程》</a></li><li><a href="https://help.github.com/" target="_blank" rel="noopener">《Github帮助文档》</a></li><li><a href="https://coding.net/help/" target="_blank" rel="noopener">《Coding帮助文档》</a></li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">《Markdown 语法说明》</a></li></ul><h2 id="更多教程可以来我yufeng-Zhou独立博客里面看到"><a href="#更多教程可以来我yufeng-Zhou独立博客里面看到" class="headerlink" title="更多教程可以来我yufeng.Zhou独立博客里面看到"></a>更多教程可以来我<a href="http://yfzhou.coding.me/">yufeng.Zhou</a>独立博客里面看到</h2><p><strong>转载请注明出处<a href="http://yfzhou.coding.me/">http://yfzhou.coding.me/</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是一篇很详细的独立博客搭建教程，意在帮助小白们能快速入门，拥有自己的独立博客。作者已在window平台已搭建成功，博客效果请点&lt;a href=&quot;https://yfzhou.coding.me/&quot;&gt;链接&lt;/a&gt;查看。  &lt;/p&gt;
&lt;h3 id=&quot;为什么用Hexo搭建独立博客？&quot;&gt;&lt;a href=&quot;#为什么用Hexo搭建独立博客？&quot; class=&quot;headerlink&quot; title=&quot;为什么用Hexo搭建独立博客？&quot;&gt;&lt;/a&gt;为什么用Hexo搭建独立博客？&lt;/h3&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next搭建个人博客（安装与部署）</title>
    <link href="https://yfzhou.coding.me/2018/08/07/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%89/"/>
    <id>https://yfzhou.coding.me/2018/08/07/Hexo-Next搭建个人博客（安装与部署）/</id>
    <published>2018-08-07T11:25:18.000Z</published>
    <updated>2018-08-08T02:05:03.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的静态站点生成框架，它基于 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 。 它有以下特点：</p><ul><li><h6 id="超快速度"><a href="#超快速度" class="headerlink" title="  超快速度"></a><i class="fa fa-bolt"></i>  超快速度</h6><p><i>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</i></p></li><li><h6 id="支持Markdown"><a href="#支持Markdown" class="headerlink" title="  支持Markdown"></a><i class="fa fa-pencil"></i>  支持Markdown</h6><p> <i>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 </i></p></li><li><h6 id="一键部署"><a href="#一键部署" class="headerlink" title=" 一键部署"></a><i class="fa fa-cloud-upload"></i> 一键部署</h6> <i>只需一条指令即可部署到Github Pages，或其他网站 </i></li><li><h6 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title=" 丰富的插件"></a><i class="fa fa-cog"></i> 丰富的插件</h6> <i>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 </i></li></ul><a id="more"></a><p>通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件</a> 来快速的插入特定形式的内容。</p><p>基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 因其 精于心，简于形 的风格，一直被广大用户所喜爱。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a><a href="#安装前提" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序:</p><blockquote><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p></blockquote><p>如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><blockquote><p><strong>Mac 用户</strong></p><p>您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a><a href="#安装-Git" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载安装 git 。 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Download Now</a></li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>，<a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装</li><li>Linux（Ubuntu，Debian）：<code>sudo apt-get install git-core</code></li><li>Linux（Fedora，Red Hat，CentOS）：<code>sudo yum install git-core</code></li></ul><blockquote><p><strong>Windows 用户</strong></p><p>由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p></blockquote><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a><a href="#安装-Node-js" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。（nvm：Node Version Manager）<br>windows 下使用 nvm 请看这里： <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a> ，首先需要下载安装 nvm 。 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">Download Now</a><br>windows下安装完nvm以后，我们可以打开命令行中执行命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nvm  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvm install latest</span></span><br></pre></td></tr></table></figure></p><p>执行完以后，重启命令行，执行命令 <code>node -v</code> ，如果出现版本号，那么 <code>Node.js</code> 就安装成功了。</p><p>如果没有安装成功，那可能就是墙的原因。建议下载 <code>Node.js</code> 直接安装。 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Download Now</a></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a><a href="#安装-Hexo" title="安装 Hexo"></a>安装 Hexo</h2><p>有了 Node.js ，我们可以使用 npm 安装 Hexo。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure></p><p>安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。<code>D:\blog</code> ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure></p><p>等待安装，安装完成后，指定文件夹 的目录如下：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.  </span><br><span class="line">├── <span class="variable">_config</span>.yml  </span><br><span class="line">├── package.json  </span><br><span class="line">├── scaffolds  </span><br><span class="line">├── source  </span><br><span class="line">|   ├── <span class="variable">_drafts</span>  </span><br><span class="line">|   └── <span class="variable">_posts</span>  </span><br><span class="line">└──</span><br></pre></td></tr></table></figure></p><p>我们继续执行命令  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s --debug</span></span><br></pre></td></tr></table></figure><p>Hexo 将 source 文件夹中除 <em>posts 文件夹之外，开头命名为</em> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。<br>这个时候，我们在浏览器中访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，就可以看到基于 Hexo 的默认主题的原型</p><h2 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a><a href="#安装-NexT-主题" title="安装 NexT 主题"></a>安装 NexT 主题</h2><h3 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a><a href="#下载-NexT-主题" title="下载 NexT 主题"></a>下载 NexT 主题</h3><p>依旧是在当前目录下，使用 Git checkout 代码：  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>等待下载完成。</p><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>我们约定，将前者称为 <span id="inline-blue">站点配置文件</span>，后者称为 <span id="inline-purple">主题配置文件</span></p><h3 id="启用-NexT-主题"><a href="#启用-NexT-主题" class="headerlink" title="启用 NexT 主题"></a><a href="#启用-NexT-主题" title="启用 NexT 主题"></a>启用 NexT 主题</h3><p>打开 <span id="inline-blue">站点配置文件</span>文件 ，找到 theme 字段，并将其值更改为 next 。<br>到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a><a href="#验证主题" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示：</p><p>INFO  Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.  </p><p>此时即可使用浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，检查站点是否正确运行。</p><p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p><p>现在，我们已经成功安装并启用了 NexT 主题。  </p><p>关于更多基本操作和基础知识，请查阅 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 与 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 官方文档.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#总结" title="总结"></a>总结</h1><h2 id="本地调试步骤"><a href="#本地调试步骤" class="headerlink" title="本地调试步骤"></a><a href="#本地调试步骤" title="本地调试步骤"></a>本地调试步骤</h2><p>三部曲：  </p><blockquote><p>$ hexo clean<br>$ hexo g<br>$ hexo s –debug  </p></blockquote><p>这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。</p><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a><a href="#部署步骤" title="部署步骤"></a>部署步骤</h2><p>三部曲：  </p><blockquote><p>$ hexo clean<br>$ hexo g<br>$ hexo d  </p></blockquote><p>当然在部署之前，需要先配置好配置文件中的 deploy。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><a href="#常用命令" title="常用命令"></a>常用命令</h2><blockquote><p>$ hexo new “postName”  #新建文章<br>$ hexo new page “pageName” # 新建页面<br>$ hexo generate # 生成静态页面至public目录<br>$ hexo server # 开启预览访问端口(默认端口4000，’ctrl+c’关闭server)<br>$ hexo deploy # 项目部署<br>$ hexo help # 查看帮助<br>$ hexo version # 查看Hexo的版本  </p></blockquote><h2 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a><a href="#简写命令" title="简写命令"></a>简写命令</h2><blockquote><p>$ hexo new == hexo n<br>$ hexo generate == hexo g<br>$ hexo server == hexo s<br>$ hexo deploy == hexo d<br>$ hexo generate + $ hexo server == $ hexo s -g<br>$ hexo generate + $ hexo deploy == $ hexo d -g</p></blockquote><h2 id="常见问题1"><a href="#常见问题1" class="headerlink" title="常见问题1"></a><a href="#常见问题1" title="常见问题1"></a>常见问题1</h2><p>在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：<br>错误的设置：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">author</span>:yufeng.Zhou</span><br><span class="line"><span class="attribute">email</span>:<span class="number">18851200889</span><span class="variable">@163</span>.com</span><br><span class="line"><span class="attribute">language</span>:zh-CN</span><br></pre></td></tr></table></figure></p><p>正确的设置：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">author</span>: yufeng.Zhou</span><br><span class="line"><span class="attribute">email</span>: <span class="number">18851200889</span><span class="variable">@163</span>.com</span><br><span class="line"><span class="attribute">language</span>: zh-CN</span><br></pre></td></tr></table></figure></p><h2 id="常见问题2"><a href="#常见问题2" class="headerlink" title="常见问题2"></a><a href="#常见问题2" title="常见问题2"></a>常见问题2</h2><p>关于 Git 提交中用户名和 Email 的设置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"Your name"</span>  </span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"Your email"</span></span><br></pre></td></tr></table></figure></p><h2 id="常见问题3"><a href="#常见问题3" class="headerlink" title="常见问题3"></a><a href="#常见问题3" title="常见问题3"></a>常见问题3</h2><p>Hexo 中的图标使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。<br><i class="fa fa-github"></i><code>&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-lg"></i><code>&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-2x"></i><code>&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的静态站点生成框架，它基于 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt; 。 它有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h6 id=&quot;超快速度&quot;&gt;&lt;a href=&quot;#超快速度&quot; class=&quot;headerlink&quot; title=&quot;  超快速度&quot;&gt;&lt;/a&gt;&lt;i class=&quot;fa fa-bolt&quot;&gt;&lt;/i&gt;  超快速度&lt;/h6&gt;&lt;p&gt;&lt;i&gt;Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。&lt;/i&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h6 id=&quot;支持Markdown&quot;&gt;&lt;a href=&quot;#支持Markdown&quot; class=&quot;headerlink&quot; title=&quot;  支持Markdown&quot;&gt;&lt;/a&gt;&lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt;  支持Markdown&lt;/h6&gt;&lt;p&gt; &lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 &lt;/i&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h6 id=&quot;一键部署&quot;&gt;&lt;a href=&quot;#一键部署&quot; class=&quot;headerlink&quot; title=&quot; 一键部署&quot;&gt;&lt;/a&gt;&lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt; 一键部署&lt;/h6&gt; &lt;i&gt;只需一条指令即可部署到Github Pages，或其他网站 &lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;h6 id=&quot;丰富的插件&quot;&gt;&lt;a href=&quot;#丰富的插件&quot; class=&quot;headerlink&quot; title=&quot; 丰富的插件&quot;&gt;&lt;/a&gt;&lt;i class=&quot;fa fa-cog&quot;&gt;&lt;/i&gt; 丰富的插件&lt;/h6&gt; &lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 &lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://yfzhou.coding.me/tags/Hexo/"/>
    
      <category term="Next" scheme="https://yfzhou.coding.me/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker笔记</title>
    <link href="https://yfzhou.coding.me/2018/08/01/FreeMarker%E7%AC%94%E8%AE%B0/"/>
    <id>https://yfzhou.coding.me/2018/08/01/FreeMarker笔记/</id>
    <published>2018-08-01T01:24:56.000Z</published>
    <updated>2018-08-21T12:25:34.476Z</updated>
    
    <content type="html"><![CDATA[<h5 id="FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html-web-页面-和-代码自动生成工具来快速了解FreeMarker。"><a href="#FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html-web-页面-和-代码自动生成工具来快速了解FreeMarker。" class="headerlink" title="FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html web 页面 和 代码自动生成工具来快速了解FreeMarker。"></a>FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html web 页面 和 代码自动生成工具来快速了解FreeMarker。</h5><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>FreeMarker是一款用java语言编写的模版引擎，它虽然不是web应用框架，但它很合适作为web应用框架的一个组件。</p><a id="more"></a><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>==轻量级==模版引擎，不需要Servlet环境就可以很轻松的嵌入到应用程序中</li><li>能生成各种文本，如html，xml，java，等</li><li>入门==简单==，它是用java编写的，很多语法和java相似</li></ol><h3 id="FreeMarker-程序"><a href="#FreeMarker-程序" class="headerlink" title="FreeMarker 程序"></a>FreeMarker 程序</h3><p>这里通过模拟简单的代码自动生产工具来感受第一个FreeMarker程序。</p><h6 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h6><p><img src="https://note.youdao.com/yws/api/personal/file/7F3E305ECC7C4D43B3723E432DABD9F5?method=download&amp;shareKey=871330817cb4fa023023ff95f9c3a3de" alt="image"></p><h6 id="eclipse安装freemarker插件"><a href="#eclipse安装freemarker插件" class="headerlink" title="eclipse安装freemarker插件"></a>eclipse安装freemarker插件</h6><blockquote><p>Help –&gt; Install New Software</p><p>点add，再出来的对话框中的Location中输入：<a href="http://download.jboss.org/jbosstools/updates/stable/indigo/" target="_blank" rel="noopener">http://download.jboss.org/jbosstools/updates/stable/indigo/</a></p><p>name随便取一个即可。然后会列出来所有可用的插件，<br>JBoss Application Development 下找到 FreeMarker IDE选中 点击Next </p><p>安装好重启eclipse就可以了。</p><p>过程可能有点慢，请==耐心等待==。</p></blockquote><h6 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hello.ftl模板(部分)<br><img src="https://note.youdao.com/yws/api/personal/file/65DD084F98E647AB86F1D08C5440559F?method=download&amp;shareKey=78c42c5bd58a114675064cd0e0386924" alt="image"></p><p>FreeMarkerDemo.java 核心方法，使用 FreeMarker 模版引擎。</p><pre style="max-height: 35em;"><code>package com.freemarker.hello.templates;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import com.freemarker.hello.pojo.User;import freemarker.template.Configuration;import freemarker.template.Template;/** * 最常见的问题： java.io.FileNotFoundException: xxx does not exist. 解决方法：要有耐心 * FreeMarker jar 最新的版本（2.3.23）提示 Configuration 方法被弃用 代码自动生产基本原理： 数据填充 * freeMarker 占位符 */public class FreeMarkerDemo {    private static final String TEMPLATE_PATH = "src/main/java/com/freemarker/hello/templates";    private static final String CLASS_PATH = "src/main/java/com/freemarker/hello";    private static List<user> users = new ArrayList<user>();    static {        User u1 = new User("1", 22, "迟到峰");        User u2 = new User("2", 23, "要饭楚");        User u3 = new User("3", 27, "BUG李");        User u4 = new User("4", 25, "删库冬");        User u5 = new User("5", 29, "瓜子军");        User u6 = new User("6", 28, "老韩");        User u7 = new User(null, 25, null);        users.add(u1);        users.add(u2);        users.add(u3);        users.add(u4);        users.add(u5);//        users.add(null);        users.add(u6);//        users.add(u7);//        users.clear();    }    public static void main(String[] args) {        // step1 创建freeMarker配置实例        Configuration configuration = new Configuration(Configuration.VERSION_2_3_23);        Writer out = null;        try {            // step2 获取模版路径            configuration.setDirectoryForTemplateLoading(new File(TEMPLATE_PATH));            // step3 创建数据模型            Map<string, object=""> dataMap = new HashMap<string, object="">();            dataMap.put("classPath", "com.freemarker.hello");            dataMap.put("htmlName", "使用FreeMarker生成html模板");            dataMap.put("helloWorld", "通过简单的 <代码自动生产程序> 演示 FreeMarker的HelloWorld！");            dataMap.put("author", "周宇峰");            dataMap.put("github", "github.com/542869246");            dataMap.put("name", "abcdefg");            dataMap.put("dateTime",new Date());            dataMap.put("users", users);            // step4 加载模版文件            Template template = configuration.getTemplate("hello.ftl");            // step5 生成数据            File docFile = new File(CLASS_PATH + "\\" + "hello.html");            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(docFile)));            // step6 输出文件            template.process(dataMap, out);            System.out.println("文件创建成功 !");        } catch (Exception e) {            e.printStackTrace();        } finally {            try {                if (null != out) {                    out.flush();                }            } catch (Exception e2) {                e2.printStackTrace();            }        }    }}</代码自动生产程序></string,></string,></user></user></code></pre><p>运行程序后刷新项目，会发现多了一个hello.html文件。</p><h2 id="语法详解"><a href="#语法详解" class="headerlink" title="语法详解"></a>语法详解</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h6 id="和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。"><a href="#和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。" class="headerlink" title="和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。"></a>和java不同，FreeMarker不需要定义变量的类型，直接赋值即可。</h6><p>字符串： value = “xxxx” 。 单引号和双引号是一样的。字符串中可以使用转义字符”\”。如果字符串内有大量的特殊字符，则可以在引号的前面加上一个字母r，则字符串内的所有字符都将直接输出。string = r”xxxx”。</p><p>数值：value = 1.2。数值可以直接等于，但是不能用科学计数法。</p><p>布尔值：true or false。</p><p>List集合：list = [1,2,3] ; list=[1..100] 表示 1 到 100 的集合，反之亦然。</p><p>Map集合：map = {“key” : “value” , “key2” : “value2”}，key 必须是字符串</p><p>时间对象:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="built_in">put</span>(<span class="string">"date1"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">$&#123;date1?<span class="keyword">string</span>(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)&#125;</span><br></pre></td></tr></table></figure><p>JaveBean：Freemarker中对于javabean的处理跟EL表达式一致，类型可自动转化！非常方便！</p><h6 id="注释：-lt-–-abcd-–-gt"><a href="#注释：-lt-–-abcd-–-gt" class="headerlink" title="注释：&lt;#– abcd –&gt;"></a>注释：&lt;#– abcd –&gt;</h6><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h6 id="声明变量和输出"><a href="#声明变量和输出" class="headerlink" title="声明变量和输出:"></a>声明变量和输出:</h6><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign name=<span class="string">"zyf"</span>&gt;         <span class="comment">//声明一个变量值为zyf的变量name</span></span><br><span class="line">$&#123;name&#125;                      <span class="comment">//输出name  结果为zyf</span></span><br><span class="line">&lt;#assign cname=<span class="string">r"特殊字符完成输出(https://github.com/542869246)"</span>&gt;</span><br><span class="line">$&#123;cname&#125;</span><br></pre></td></tr></table></figure><h5 id="字符串连接："><a href="#字符串连接：" class="headerlink" title="字符串连接："></a>字符串连接：</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用嵌套或者+ 进行字符串连接操作</span></span><br><span class="line"><span class="symbol">$</span>&#123;<span class="string">"Hello $&#123;name&#125; !"</span>&#125; / <span class="symbol">$</span>&#123;<span class="string">"Hello "</span> + name + <span class="string">" !"</span>&#125;</span><br><span class="line"><span class="comment">//输出：Hello zyf ! / Hello zyf !</span></span><br></pre></td></tr></table></figure><h5 id="字符串截取："><a href="#字符串截取：" class="headerlink" title="字符串截取："></a>字符串截取：</h5><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign a=<span class="string">"abcdefg"</span>&gt;</span><br><span class="line">$&#123;a[<span class="number">1</span>]&#125;                     <span class="comment">//b</span></span><br><span class="line">$&#123;a[<span class="number">1.</span><span class="number">.5</span>]&#125;                  <span class="comment">//bcdef</span></span><br><span class="line">$&#123;a?substring(<span class="number">3</span>)&#125;           <span class="comment">//efg</span></span><br><span class="line">$&#123;a?substring(<span class="number">3</span>,<span class="number">2</span>)&#125;         <span class="comment">//ef</span></span><br></pre></td></tr></table></figure><blockquote><p>string[index]。index 可以是一个值，也可以是形如 0..2 表示下标从0开始，到下标为2结束。一共是三个数。</p><p>substring（start,end）从一个字符串中截取子串。</p><p>start:截取子串开始的索引，start必须大于等于0，小于等于end。</p><p>end: 截取子串的长度，end必须大于等于0，小于等于字符串长度，如果省略该参数，默认为字符串长度。</p></blockquote><h3 id="算数运算："><a href="#算数运算：" class="headerlink" title="算数运算："></a>算数运算：</h3><p>支持”+”、”－”、”*”、”/“、”%”运算符</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="attr">#assign number1</span>=<span class="number">10</span> <span class="symbol">number2</span>=<span class="number">5</span> &gt;</span><br><span class="line"><span class="string">"+"</span>:$&#123;<span class="symbol">number1</span> + <span class="symbol">number2</span> &#125;       <span class="comment">//15</span></span><br><span class="line"><span class="string">"-"</span>:$&#123;<span class="symbol">number1</span> - <span class="symbol">number2</span> &#125;       <span class="comment">//5</span></span><br><span class="line"><span class="string">"*"</span>:$&#123;<span class="symbol">number1</span> * <span class="symbol">number2</span> &#125;       <span class="comment">//50</span></span><br><span class="line"><span class="string">"/"</span>:$&#123;<span class="symbol">number1</span> / <span class="symbol">number2</span> &#125;       <span class="comment">//2</span></span><br><span class="line"><span class="string">"%"</span>:$&#123;<span class="symbol">number1</span> <span class="meta">%</span> <span class="symbol">number2</span> &#125;       <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>表达式中支持的比较运算符有如下几种：</p><ol><li>=（或者==）：判断两个值是否相等；</li><li>!=：判断两个值是否不相等；<br>注： =和!=可以用作字符串、数值和日期的比较，但两边的数据类型必须相同。而且FreeMarker的比较是精确比较，==不会忽略大小写及空格==。</li><li>>（或者gt）：大于</li><li>>=（或者gte）：大于等于</li><li>&lt;（或者lt）：小于</li><li>&lt;=（或者lte）：小于等于</li><li><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="attr">#if number1</span> + <span class="symbol">number2</span> gte <span class="number">12</span> || <span class="symbol">number1</span> - <span class="symbol">number2</span> <span class="keyword">lt</span> <span class="number">6</span>&gt;</span><br><span class="line"><span class="string">"*"</span> : $&#123;<span class="symbol">number1</span> * <span class="symbol">number2</span>&#125;</span><br><span class="line">&lt;<span class="attr">#else&gt;</span></span><br><span class="line"><span class="attr">"/" : $&#123;number1</span> / <span class="symbol">number2</span>&#125;</span><br><span class="line">&lt;/<span class="attr">#if&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>上面这些比较运算符可以用于数字和日期，但不能用于字符串。大部分时候，使用==gt比&gt;有更好的效果==，因为FreeMarker会把&gt;解释成标签的结束字符。可以使用括号来避免这种情况，如：&lt;#if (x&gt;y)&gt;。</p></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>&amp;&amp;：逻辑与；</li><li>||：逻辑或；</li><li>!：逻辑非<blockquote><p>逻辑运算符只能用于布尔值。</p></blockquote></li></ol><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><blockquote><p>FreeMarker还提供了一些内建函数来转换输出,可以在任何变量后紧跟?,?后紧跟内建函数,就可以通过内建函数来轮换输出变量.下面是常用的内建的字符串函数</p></blockquote><h5 id="字符串相关常用的内建函数："><a href="#字符串相关常用的内建函数：" class="headerlink" title="字符串相关常用的内建函数："></a>字符串相关常用的内建函数：</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign data = <span class="string">"abcd1234"</span>&gt;</span><br><span class="line">html：对字符串进行HTML编码，将字符串中的&lt;、&gt;、&amp;和“替换为对应得&amp;lt;&amp;gt;&amp;quot:&amp;amp</span><br><span class="line"></span><br><span class="line">cap_first：使字符串第一个字母大写 <span class="variable">$&#123;data</span>?cap_first&#125;</span><br><span class="line"></span><br><span class="line">lower_case：将字符串转成小写 <span class="variable">$&#123;data</span>?lower_case&#125;</span><br><span class="line"></span><br><span class="line">upper_case：将字符串转成大写 <span class="variable">$&#123;data</span>?upper_case&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trim</span>:去掉字符串前后的空白字符 <span class="variable">$&#123;data</span>?<span class="keyword">trim</span>&#125;</span><br><span class="line"></span><br><span class="line">length:返回字符串的长度 $&#123;<span class="string">"string"</span>?length&#125;</span><br><span class="line"></span><br><span class="line">index_of(substring,start)在字符串中查找某个子串，返回找到子串的第一个字符的索引，如果没有找到子串，则返回-1。</span><br><span class="line">Start参数用于指定从字符串的那个索引处开始搜索，start为数字值。</span><br><span class="line">如果start大于字符串长度，则start取值等于字符串长度，如果start小于0， 则start取值为0。</span><br><span class="line">$&#123;<span class="string">"string"</span>?index_of(<span class="string">"in"</span>) 结果为3</span><br><span class="line">$&#123;<span class="string">"string"</span>?index_of(<span class="string">"ab"</span>) 结果为-1</span><br><span class="line"></span><br><span class="line"><span class="keyword">replace</span>用于将字符串中的一部分从左到右替换为另外的字符串。</span><br><span class="line">$&#123;<span class="string">"strabg"</span>?<span class="keyword">replace</span>(<span class="string">"ab"</span>,<span class="string">"in"</span>)&#125; 结果为<span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">split</span>使用指定的分隔符将一个字符串拆分为一组字符串</span><br><span class="line">&lt;#<span class="keyword">list</span> <span class="string">"This|is|split"</span>?<span class="keyword">split</span>(<span class="string">"|"</span>") <span class="keyword">as</span> s&gt;</span><br><span class="line"><span class="variable">$&#123;s&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">结果为:</span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="keyword">split</span></span><br></pre></td></tr></table></figure><h5 id="集合相关常用的内建函数："><a href="#集合相关常用的内建函数：" class="headerlink" title="集合相关常用的内建函数："></a>集合相关常用的内建函数：</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>：获得集合中元素的个数 $&#123;users?<span class="built_in">size</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="数字值相关常用的内建函数："><a href="#数字值相关常用的内建函数：" class="headerlink" title="数字值相关常用的内建函数："></a>数字值相关常用的内建函数：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#assign floatData = 12.34&gt;</span></span><br><span class="line"><span class="keyword">int</span>：取得数字的整数部分 $&#123;floatData?<span class="keyword">int</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;(users?size <span class="literal">gt</span> <span class="number">15</span>)?<span class="built_in">string</span>(<span class="string">'a'</span>,<span class="string">'b'</span>) &#125;</span><br><span class="line">&lt;#assign theValue = (temp == <span class="string">"default"</span>)?<span class="built_in">string</span>(<span class="string">'true'</span>,<span class="string">'false'</span>) /&gt;</span><br></pre></td></tr></table></figure><h3 id="空值处理运算符"><a href="#空值处理运算符" class="headerlink" title="空值处理运算符"></a>空值处理运算符</h3><blockquote><p>FreeMarker对空值的处理非常严格,==FreeMarker的变量必须有值==,没有被赋值的变量就会抛出异常,因为FreeMarker未赋值的变量强制出错可以杜绝很多潜在的错误,如缺失潜在的变量命名,或者其他变量错误.这里所说的空值,实际上也包括那些并不存在的变量,对于一个Java的 null值而言,我们认为这个变量是存在的,只是它的值为null,但对于FreeMarker模板而言,它无法理解null值,null值和不存在的变量完全相同。</p></blockquote><h6 id="FreeMarker提供两个运算符来避免空值"><a href="#FreeMarker提供两个运算符来避免空值" class="headerlink" title="FreeMarker提供两个运算符来避免空值"></a>FreeMarker提供两个运算符来避免空值</h6><ol><li>!：指定缺失变量的默认值</li><li>??：判断变量是否存在</li></ol><blockquote><p>!运算符有两种用法：variable!或variable!defaultValue。第一种用法不给变量指定默认值，表明默认值是空字符串、长度为0的集合、或长度为0的Map对象。==使用!运算符指定默认值并不要求默认值的类型和变量类型相同==。</p><p>??运算符返回布尔值，如：variable??，如果变量存在，返回true，否则返回false。</p></blockquote><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#<span class="meta-keyword">if</span> user??&gt;</span></span><br><span class="line">    $&#123;user.<span class="built_in">name</span>!<span class="string">"变量为空则给一个默认值"</span>&#125;</span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">else</span>&gt;</span></span><br><span class="line">    users为空</span><br><span class="line">&lt;/<span class="meta">#<span class="meta-keyword">if</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><blockquote><p>FreeMarker的FTL指令也是模板的重要组成部分,这些指令可实现对数据模型所包含数据的抚今迭代,分支控制.除此之外,还有一些重要的功能,也是通过FTL指令来实现的. </p></blockquote><h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><blockquote><p>这是一个典型的分支控制指令,该指令的作用完全类似于Java语言中的if,if指令的语法格式如下<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#assign age=23&gt; </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">if</span> (age&gt;60)&gt;老年人 </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">elseif</span> (age&gt;40)&gt;中年人 </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">elseif</span> (age&gt;20)&gt;青年人 </span></span><br><span class="line">&lt;<span class="meta">#<span class="meta-keyword">else</span>&gt; 少年人 </span></span><br><span class="line">&lt;/<span class="meta">#<span class="meta-keyword">if</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h4 id="switch-case指令"><a href="#switch-case指令" class="headerlink" title="switch case指令"></a>switch case指令</h4><blockquote><p>switch（expr）,其中expr只能是字符串、基本类型int或者包装类Integer，也包括不同的长度整型，例如short<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#switch being.size&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#case "small"&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> small  </span><br><span class="line">          &lt;<span class="comment">#break&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#case "medium"&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> medium  </span><br><span class="line">          &lt;<span class="comment">#break&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#case "large"&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> large  </span><br><span class="line">          &lt;<span class="comment">#break&gt;  </span></span><br><span class="line">  &lt;<span class="comment">#default&gt;  </span></span><br><span class="line">          This will be processed <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> neither  </span><br><span class="line">&lt;/<span class="comment">#switch&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h4 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h4><blockquote><p>list指令是一个迭代输出指令,用于迭代输出数据模型中的集合<br>sequence是集合(collection)的表达式，item是循环变量的名字，不能是表达式。<br>当在遍历sequence时，会将遍历变量的值保存到item中</p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">&lt;#<span class="keyword">list</span> sequence <span class="keyword">as</span> item&gt;    </span><br><span class="line">  <span class="variable">$&#123;item&#125;</span>   </span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历users集合 获取user对象属性</span></span><br><span class="line">&lt;#<span class="keyword">list</span> users <span class="keyword">as</span> user&gt;    </span><br><span class="line">  <span class="variable">$&#123;user</span>.id&#125;--<span class="variable">$&#123;user</span>.age&#125;--&#123;user.name&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><h6 id="List指令还隐含了两个循环变量："><a href="#List指令还隐含了两个循环变量：" class="headerlink" title="List指令还隐含了两个循环变量："></a>List指令还隐含了两个循环变量：</h6><p>item_index:当前迭代项在所有迭代项中的位置，是数字值。</p><p>item_has_next:用于判断当前迭代项是否是所有迭代项中的最后一项。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">users</span> <span class="attr">as</span> <span class="attr">user</span>&gt;</span>    </span></span><br><span class="line"><span class="xml">  $</span><span class="template-variable">&#123;user_index&#125;</span><span class="xml">--$</span><span class="template-variable">&#123;user.id&#125;</span><span class="xml">--$</span><span class="template-variable">&#123;user.age&#125;</span><span class="xml">--</span><span class="template-variable">&#123;user.name&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#if</span> !<span class="attr">user_has_next</span>&gt;</span></span></span><br><span class="line"><span class="xml">        共有$</span><span class="template-variable">&#123;users?size&#125;</span><span class="xml">最后一个用户是:$</span><span class="template-variable">&#123;user.name&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">#if</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h6 id="对List进行排序"><a href="#对List进行排序" class="headerlink" title="对List进行排序"></a>对List进行排序</h6><blockquote><p>通常我们的排序操作都是通过DAO层来实现的，如果我们想随时更改我们的排序，那么就必须修改我们的DAO层代码，确实不方便。但Freemarker为我们提供了这样的排序方法，解决了这个问题。</p></blockquote><ol><li>sort升序排序函数<br>sort对序列(sequence)进行排序，要求序列中的变量必须是：字符串（按首字母排序）,数字，日期值。</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> <span class="keyword">list</span>?<span class="keyword">sort</span> <span class="keyword">as</span> <span class="keyword">l</span>&gt;…&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>sort_by函数<br>sort_by有一个参数,该参数用于指定想要排序的子变量，排序是按照变量对应的值进行排序,如：</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list users?sort_by(<span class="string">"age"</span>) <span class="keyword">as</span> user&gt;…&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>age是User对象的属性，排序是按age的值进行的。</p><ol start="3"><li>reverse降序排序函数</li></ol><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="built_in">list</span> <span class="built_in">list</span>? reverse <span class="keyword">as</span> l&gt;…&lt;/#<span class="built_in">list</span>&gt;。</span><br></pre></td></tr></table></figure><p>reverse使用同sort相同。reverse还可以同sort_by一起使用<br>如：想让用户按年龄降序排序，那么可以这个样写</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list users?sort_by(<span class="string">"age"</span>)?reverse <span class="keyword">as</span> user&gt;…&lt;/#list&gt;</span><br></pre></td></tr></table></figure><h5 id="使用list指令遍历map"><a href="#使用list指令遍历map" class="headerlink" title="使用list指令遍历map"></a>使用list指令遍历map</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个map,注意在freemarker中,map的key只能是字符串来作为key</span></span><br><span class="line">&lt;#assign userMap=&#123;<span class="string">"1"</span>,<span class="string">"刘德华"</span>,<span class="string">"2"</span>:<span class="string">"张学友"</span>&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取map中的值</span></span><br><span class="line"><span class="variable">$&#123;userMap</span>[<span class="string">"1"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取map的keys</span></span><br><span class="line">&lt;#assign  keys=userMap?keys/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历map 首选获取key的集合</span></span><br><span class="line">&lt;#<span class="keyword">list</span> keys <span class="keyword">as</span> key&gt;</span><br><span class="line">  key:<span class="variable">$&#123;key&#125;</span>-value:<span class="variable">$&#123;userMap</span>[<span class="string">"$&#123;key&#125;"</span>]&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接遍历map的第二种方式</span></span><br><span class="line">&lt;#<span class="keyword">list</span> userMap?keys <span class="keyword">as</span> key&gt;</span><br><span class="line">  key:<span class="variable">$&#123;key&#125;</span>--value:<span class="variable">$&#123;userMap</span>[<span class="string">"$&#123;key&#125;"</span>]&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接遍历map的values</span></span><br><span class="line">&lt;#<span class="keyword">list</span> userMap?values <span class="keyword">as</span> value&gt;</span><br><span class="line"> <span class="variable">$&#123;value&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><blockquote><p>include指令的作用类似于JSP的包含指令,用于包含指定页</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">现在有hello.ftl、inc1.ftl与inc2<span class="selector-class">.ftl</span> <span class="number">3</span>个模板</span><br><span class="line">在inc1.ftl与inc2.ftl中的内容分别是:</span><br><span class="line">&lt;<span class="selector-id">#assign</span> username=<span class="string">"刘德华"</span>&gt;与&lt;<span class="selector-id">#assign</span> username=<span class="string">"张学友"</span>&gt;</span><br><span class="line"></span><br><span class="line">接着在hello.ftl模版中用include将inc1.ftl包含进来</span><br><span class="line">&lt;<span class="selector-id">#include</span> <span class="string">"/inc/inc1.ftl"</span>&gt;</span><br><span class="line">$&#123;username&#125;</span><br><span class="line">此刻获取的结果是:刘德华</span><br><span class="line"></span><br><span class="line">接着我们在hello.ftl用include将inc1.ftl与inc2.ftl同时进行包含进来</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-id">#include</span> <span class="string">"/inc/inc1.ftl"</span>&gt;</span><br><span class="line">&lt;<span class="selector-id">#include</span> <span class="string">"/inc/inc2.ftl"</span>&gt;</span><br><span class="line">$&#123;username&#125;</span><br><span class="line"></span><br><span class="line">此刻获取的值是:张学友</span><br></pre></td></tr></table></figure><h6 id="总结：出现这种情况，在-两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖-，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入"><a href="#总结：出现这种情况，在-两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖-，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入" class="headerlink" title="总结：出现这种情况，在==两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖==，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入"></a>总结：出现这种情况，在==两个模版中都分别存在变量名都相同的变量的时候，include包含进来，会进行覆盖==，include只时候将其公共的静态文件进行包含，而里面不涉及到内部函数以及变量声明之类的，当涉及到这种问题，我们就要用import进行导入</h6><h4 id="import指令"><a href="#import指令" class="headerlink" title="import指令"></a>import指令</h4><blockquote><p>该指令用于导入FreeMarker模板中的所有变量,并将该变量放置在指定的Map对象中</p></blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接着上面</span><br><span class="line">在hello.ftl用<span class="keyword">import</span>指令将inc1.ftl与inc2.ftll模板文件中的所有变量,同时导入进来</span><br><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/inc/inc1.ftl"</span> <span class="keyword">as</span> inc1&gt;</span><br><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/inc/inc2.ftl"</span> <span class="keyword">as</span> inc2&gt;</span><br><span class="line"></span><br><span class="line">$&#123;inc1.username&#125;    <span class="comment">//刘德华</span></span><br><span class="line">$&#123;inc2.username&#125;    <span class="comment">//张学友</span></span><br></pre></td></tr></table></figure><h4 id="noparse指令"><a href="#noparse指令" class="headerlink" title="noparse指令"></a>noparse指令</h4><blockquote><p>noparse指令指定FreeMarker不处理该指定里包含的内容,该指令的语法格式如下</p></blockquote><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#noparse</span>&gt;</span>...<span class="tag">&lt;/<span class="name">#noparse</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">看如下的例子: </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#noparse</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">books</span> <span class="attr">as</span> <span class="attr">book</span>&gt;</span> </span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$</span><span class="template-variable">&#123;book.name&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>作者:$</span><span class="template-variable">&#123;book.author&#125;</span><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#noparse</span>&gt;</span> </span></span><br><span class="line"><span class="xml">输出如下: </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">books</span> <span class="attr">as</span> <span class="attr">book</span>&gt;</span> </span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$</span><span class="template-variable">&#123;book.name&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>作者:$</span><span class="template-variable">&#123;book.author&#125;</span><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="assign指令"><a href="#assign指令" class="headerlink" title="assign指令"></a>assign指令</h4><blockquote><p>assign指令在前面已经使用了多次,它用于为该模板页面创建或替换一个顶层变量,assign指令的用法有多种,包含创建或替换一个顶层变量, 或者创建或替换多个变量等,它的最简单的语法如下:&lt;#assign name=value [in namespacehash]&gt;,这个用法用于指定一个名为name的变量,该变量的值为value,此外,FreeMarker允许在使用 assign指令里增加in子句,in子句用于将创建的name变量放入namespacehash命名空间中</p><p>assign指令还有如下用法:</p></blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign name1=value1 name2=value2 ... nameN=valueN [<span class="keyword">in</span> namespacehash]&gt;</span><br><span class="line">这个语法可以同时创建或替换多个顶层变量,此外,还有一种复杂的用法,如果需要创建或替换的变量值是一个复杂的表达式,则可以使用如下语法格式:</span><br><span class="line">&lt;#assign name [<span class="keyword">in</span> namespacehash]&gt;capture this&lt;/#assign&gt;</span><br><span class="line">在这个语法中,是指将assign指令的内容赋值给name变量.如下例子:</span><br><span class="line">&lt;#assign x&gt; </span><br><span class="line">&lt;#list [<span class="string">"星期一"</span>, <span class="string">"星期二"</span>, <span class="string">"星期三"</span>, <span class="string">"星期四"</span>, <span class="string">"星期五"</span>, <span class="string">"星期六"</span>, <span class="string">"星期天"</span>] <span class="keyword">as</span> n&gt; </span><br><span class="line">$&#123;n&#125; </span><br><span class="line">&lt;/#list&gt; </span><br><span class="line">&lt;/#assign&gt; </span><br><span class="line">$&#123;x&#125; </span><br><span class="line">上面的代码将产生如下输出:星期一 星期二 星期三 星期四 星期五 星期六 星期天</span><br></pre></td></tr></table></figure><h6 id="虽然assign指定了这种复杂变量值的用法-但是我们也不要滥用这种用法-如下例子"><a href="#虽然assign指定了这种复杂变量值的用法-但是我们也不要滥用这种用法-如下例子" class="headerlink" title="虽然assign指定了这种复杂变量值的用法,但是我们也不要滥用这种用法,如下例子:"></a>虽然assign指定了这种复杂变量值的用法,但是我们也不要滥用这种用法,如下例子:</h6><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">x</span>&gt;</span>Hello $</span><span class="template-variable">&#123;user&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">#assign</span>&gt;</span></span></span><br><span class="line"><span class="xml">以上代码改为如下写法更合适:</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">x</span>=<span class="string">"Hello $</span></span></span><span class="template-variable">&#123;user&#125;</span><span class="xml"><span class="tag"><span class="string">!"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="setting指令"><a href="#setting指令" class="headerlink" title="setting指令"></a>setting指令</h4><blockquote><p>该指令用于设置FreeMarker的运行环境,该指令的语法格式如下:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#setting</span> <span class="attr">name</span>=<span class="string">value</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个格式中,name的取值范围包含如下几个：</p><p>locale:该选项指定该模板所用的国家/语言选项 </p><p>number_format:指定格式化输出数字的格式</p><p>boolean_format:指定两个布尔值的语法格式,默认值是true,false </p><p>date_format,time_format,datetime_format:指定格式化输出日期的格式 </p><p>time_zone:设置格式化输出日期时所使用的时区</p><h4 id="自定义指令-macro指令-宏"><a href="#自定义指令-macro指令-宏" class="headerlink" title="自定义指令(macro指令)(宏)"></a>自定义指令(macro指令)(宏)</h4><p>语法：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro name param1 param2 ... paramN&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#nested loopvar1, loopvar2, ..., loopvarN&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#return&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure><p>用例：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义名为test的指令</span></span><br><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">test</span> foo bar=<span class="string">"Bar"</span> baaz=-1&gt;</span><br><span class="line">这是自定义指令: <span class="variable">$&#123;foo&#125;</span>, <span class="variable">$&#123;bar&#125;</span>, <span class="variable">$&#123;baaz&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用test指令</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> bar=<span class="string">"b"</span> baaz=5*5-2/&gt; <span class="comment">//这是自定义指令: a, b, 23</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> bar=<span class="string">"b"</span>/&gt;            <span class="comment">//这是自定义指令: a, b, -1</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> baaz=5*5-2/&gt;         <span class="comment">//这是自定义指令: a, Bar, 23</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span>/&gt;                    <span class="comment">//这是自定义指令: a, Bar, -1</span></span><br></pre></td></tr></table></figure><blockquote><p>可以提前返回，比如&lt;#return/&gt; 但是不能&lt;#return 1&gt;， ==A macro cannot return a value== </p><p>==宏主要作用是拼接内容，把宏内部的字符串展示出来，return返回值没有意义==。</p></blockquote><h4 id="function指令-函数"><a href="#function指令-函数" class="headerlink" title="function指令(函数)"></a>function指令(函数)</h4><p>用例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">#function</span> <span class="attr">buildPageUrl</span> <span class="attr">url</span> <span class="attr">pageNum</span> <span class="attr">data</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">pageUrl</span> = <span class="string">"$</span></span></span><span class="template-variable">&#123;url&#125;</span><span class="xml"><span class="tag"><span class="string">?pageNum=$</span></span></span><span class="template-variable">&#123;pageNum&#125;</span><span class="xml"><span class="tag"><span class="string">&amp;pageSize=$</span></span></span><span class="template-variable">&#123;data.pageSize&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#return</span> <span class="attr">pageUrl</span>/&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#function</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;buildPageUrl(url2,page.pageNum+1,page)&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><blockquote><p>与宏的调用方式不同，直接 ${buildPageUrl(url2,page.pageNum+1,page)}执行函数。==返回值才是最关键的结果，不是为了显示函数内部的字符串内容==。</p></blockquote><h3 id="参考文章（特别鸣谢）："><a href="#参考文章（特别鸣谢）：" class="headerlink" title="参考文章（特别鸣谢）："></a>参考文章（特别鸣谢）：</h3><p><a href="https://blog.csdn.net/qq_34129814/article/details/76218863" target="_blank" rel="noopener">https://blog.csdn.net/qq_34129814/article/details/76218863</a></p><p><a href="https://segmentfault.com/a/1190000011768799" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011768799</a></p><p><a href="https://blog.csdn.net/fhx007/article/details/7902040/" target="_blank" rel="noopener">https://blog.csdn.net/fhx007/article/details/7902040/</a></p><p><a href="https://www.cnblogs.com/qitian1/p/6463098.html" target="_blank" rel="noopener">https://www.cnblogs.com/qitian1/p/6463098.html</a></p><hr><blockquote><h4 id="源码地址："><a href="#源码地址：" class="headerlink" title="源码地址："></a>源码地址：</h4></blockquote><h6 id="github-https-github-com-542869246-myfreemarker"><a href="#github-https-github-com-542869246-myfreemarker" class="headerlink" title="github: https://github.com/542869246/myfreemarker"></a>github: <a href="https://github.com/542869246/myfreemarker" target="_blank" rel="noopener">https://github.com/542869246/myfreemarker</a></h6><h6 id="码云-https-gitee-com-zyf542869246-myfreemarker"><a href="#码云-https-gitee-com-zyf542869246-myfreemarker" class="headerlink" title="码云: https://gitee.com/zyf542869246/myfreemarker"></a>码云: <a href="https://gitee.com/zyf542869246/myfreemarker" target="_blank" rel="noopener">https://gitee.com/zyf542869246/myfreemarker</a></h6><hr><h6 id="Author-周宇峰"><a href="#Author-周宇峰" class="headerlink" title="Author:周宇峰"></a>Author:周宇峰</h6><h6 id="Github-https-github-com-542869246"><a href="#Github-https-github-com-542869246" class="headerlink" title="Github:https://github.com/542869246"></a>Github:<a href="https://github.com/542869246" target="_blank" rel="noopener">https://github.com/542869246</a></h6><h6 id="码云-https-gitee-com-zyf542869246"><a href="#码云-https-gitee-com-zyf542869246" class="headerlink" title="码云:https://gitee.com/zyf542869246"></a>码云:<a href="https://gitee.com/zyf542869246" target="_blank" rel="noopener">https://gitee.com/zyf542869246</a></h6><h6 id="Time-2018-5-14-1-45-11"><a href="#Time-2018-5-14-1-45-11" class="headerlink" title="Time:2018/5/14 1:45:11"></a>Time:2018/5/14 1:45:11</h6>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html-web-页面-和-代码自动生成工具来快速了解FreeMarker。&quot;&gt;&lt;a href=&quot;#FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html-web-页面-和-代码自动生成工具来快速了解FreeMarker。&quot; class=&quot;headerlink&quot; title=&quot;FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html web 页面 和 代码自动生成工具来快速了解FreeMarker。&quot;&gt;&lt;/a&gt;FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具。本章内容通过如何使用FreeMarker生成Html web 页面 和 代码自动生成工具来快速了解FreeMarker。&lt;/h5&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;FreeMarker是一款用java语言编写的模版引擎，它虽然不是web应用框架，但它很合适作为web应用框架的一个组件。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://yfzhou.coding.me/categories/java/"/>
    
    
      <category term="java" scheme="https://yfzhou.coding.me/tags/java/"/>
    
      <category term="FreeMarker" scheme="https://yfzhou.coding.me/tags/FreeMarker/"/>
    
      <category term="模板引擎" scheme="https://yfzhou.coding.me/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>My New Project</title>
    <link href="https://yfzhou.coding.me/2018/07/30/My-New-Project/"/>
    <id>https://yfzhou.coding.me/2018/07/30/My-New-Project/</id>
    <published>2018-07-30T11:07:18.000Z</published>
    <updated>2018-08-07T12:03:52.745Z</updated>
    
    <content type="html"><![CDATA[<p>写啥好呢？</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写啥好呢？&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="https://yfzhou.coding.me/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="https://yfzhou.coding.me/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yfzhou.coding.me/2018/07/29/hello-world/"/>
    <id>https://yfzhou.coding.me/2018/07/29/hello-world/</id>
    <published>2018-07-29T14:45:48.000Z</published>
    <updated>2018-08-07T12:03:47.366Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="https://yfzhou.coding.me/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="https://yfzhou.coding.me/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
</feed>
